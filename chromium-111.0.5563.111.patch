From b0b664bf60f914744a7127d483c8d744d1d38e9d Mon Sep 17 00:00:00 2001
From: Virtual-Browser <virtual.browser.2020@gmail.com>
Date: Tue, 13 Jun 2023 21:43:04 +0800
Subject: [PATCH] support for win7

---
 .../address_space_randomization.cc            |  24 +-
 .../address_space_randomization.h             |   8 +-
 .../address_space_randomization_unittest.cc   |   8 +
 .../page_allocator_internals_win.h            |  32 +-
 base/base_paths_win.cc                        |   3 +
 base/debug/invalid_access_win.cc              |  12 +
 base/files/file_util_win.cc                   |  36 +-
 base/memory/discardable_shared_memory.cc      |  14 +-
 .../platform_shared_memory_region_win.cc      |  22 +-
 base/path_service_unittest.cc                 |   9 +-
 base/process/launch_win.cc                    |   9 +
 base/process/process_unittest.cc              |   8 +-
 base/process/process_win.cc                   |  16 +-
 base/task/thread_pool/thread_group.cc         |  16 +-
 base/test/launcher/test_launcher.cc           |  11 +-
 base/test/launcher/test_launcher_unittest.cc  |  18 +
 base/test/launcher/unit_test_launcher.cc      |  10 +
 base/test/launcher/unit_test_launcher.h       |   2 +
 base/threading/platform_thread_win.cc         |  21 +-
 .../threading/platform_thread_win_unittest.cc |  22 +-
 base/win/core_winrt_util_unittest.cc          |  12 +-
 base/win/default_apps_util.cc                 |   7 +
 base/win/default_apps_util.h                  |   4 +
 base/win/event_trace_controller_unittest.cc   |  19 +-
 base/win/hstring_compare.cc                   |  10 +-
 base/win/hstring_compare_unittest.cc          |  28 +-
 base/win/hstring_reference_unittest.cc        |  14 +-
 base/win/map_unittest.cc                      |  20 +-
 base/win/registry.cc                          |  13 +-
 base/win/registry_unittest.cc                 |  49 +-
 base/win/scoped_handle_unittest.cc            |  29 +
 base/win/scoped_hstring_unittest.cc           |  14 +-
 .../scoped_process_information_unittest.cc    |   5 +
 base/win/scoped_winrt_initializer.cc          |   8 +-
 base/win/scoped_winrt_initializer_unittest.cc |  21 +-
 base/win/shortcut_unittest.cc                 |  59 ++
 base/win/win_util.cc                          |  48 +-
 chrome/browser/about_flags.cc                 |   9 +
 .../caption_settings_dialog_win.cc            |   7 +-
 .../browser/chrome_content_browser_client.cc  |   7 +
 .../browser/chrome_content_browser_client.h   |   1 +
 .../device_reauth/win/authenticator_win.cc    |   6 +
 .../language_settings_private_api_unittest.cc |   9 +-
 .../external_protocol_handler_browsertest.cc  |  20 +
 chrome/browser/icon_loader_browsertest.cc     |   6 +
 .../importer/edge_importer_browsertest_win.cc |   8 +
 .../media/webrtc/webrtc_browsertest_base.cc   |  13 +
 .../media/webrtc/webrtc_browsertest_base.h    |   3 +
 ...antivirus_metrics_provider_win_unittest.cc |  51 +-
 ...chrome_browser_main_extra_parts_metrics.cc |   3 +
 .../net/stub_resolver_config_reader.cc        |  16 +-
 ..._platform_bridge_win_interactive_uitest.cc |  48 +-
 ...tification_platform_bridge_win_unittest.cc |  24 +-
 ...ication_helper_launches_chrome_unittest.cc |   6 +
 .../spelling_menu_observer_browsertest.cc     |  28 +-
 .../chrome_cleaner/reporter_runner_win.cc     |  22 +-
 .../chrome_cleaner/reporter_runner_win.h      |   4 +
 .../reporter_runner_win_unittest.cc           |  12 +
 chrome/browser/shell_integration.cc           |  38 +-
 chrome/browser/shell_integration.h            |   4 +
 chrome/browser/shell_integration_win.cc       |  69 +-
 chrome/browser/shell_integration_win.h        |  16 +
 ..._check_host_chrome_impl_win_browsertest.cc |   4 +
 ...check_language_policy_handlers_unittest.cc |   3 +
 .../spellchecker/spellcheck_service.cc        |  13 +-
 .../browser/spellchecker/spellcheck_service.h |   2 +-
 .../spellcheck_service_browsertest.cc         |   6 +
 .../spellcheck_service_unittest.cc            |   6 +
 chrome/browser/themes/theme_helper_win.cc     |   8 +-
 chrome/browser/ui/browser_ui_prefs.cc         |   7 +-
 .../win/native_chrome_color_mixer_win.cc      |  26 +-
 chrome/browser/ui/frame/window_frame_util.cc  |   2 +
 .../default_browser_infobar_delegate.cc       |   7 +
 .../default_browser_infobar_delegate.h        |   1 +
 .../startup_browser_creator_browsertest.cc    |  70 +-
 .../chrome_native_app_window_views_win.cc     |  18 +-
 .../apps/chrome_native_app_window_views_win.h |  11 +-
 .../apps/glass_app_window_frame_view_win.cc   |  30 +-
 .../views/bookmarks/bookmark_bar_view_test.cc |  13 +-
 .../ui/views/chrome_views_delegate_win.cc     |  17 +-
 .../views/create_application_shortcut_view.cc |  12 +-
 .../browser_desktop_window_tree_host_win.cc   |  32 +-
 .../browser_desktop_window_tree_host_win.h    |   2 +
 .../browser_non_client_frame_view_unittest.cc |  10 +-
 chrome/browser/ui/views/frame/browser_view.cc |   3 +
 .../views/frame/glass_browser_frame_view.cc   |  76 +-
 .../ui/views/frame/glass_browser_frame_view.h |   1 +
 .../frame/minimize_button_metrics_win.cc      |  47 +-
 .../views/frame/minimize_button_metrics_win.h |   9 +-
 .../ui/views/infobars/confirm_infobar.cc      |  11 +-
 .../ui/views/infobars/confirm_infobar.h       |   3 +
 .../views/tabs/tab_hover_card_bubble_view.cc  |  40 +-
 .../views/tabs/tab_hover_card_bubble_view.h   |   7 +-
 .../tab_hover_card_bubble_view_unittest.cc    |  26 +-
 chrome/browser/ui/views/tabs/tab_strip.cc     |  10 +-
 .../toolbar_action_hover_card_bubble_view.cc  |  20 +-
 .../ui/views/tooltip/tooltip_browsertest.cc   |  43 +
 .../touch_events_interactive_uitest_win.cc    |  15 +
 .../web_app_navigation_button_container.cc    |  38 +-
 .../app_management_page_handler.cc            |   5 +-
 .../webui/conflicts/conflicts_data_fetcher.cc |  15 +-
 .../settings_localized_strings_provider.cc    |   4 +-
 .../ui/webui/settings/settings_utils_win.cc   |  15 +-
 chrome/browser/ui/webui/welcome/welcome_ui.cc |   7 +-
 .../vr/test/gl_test_environment_unittest.cc   |   9 +
 .../os_integration/os_integration_manager.cc  |  34 +
 .../os_integration_manager_unittest.cc        |  10 +
 .../protocol_handling_sub_manager.cc          |  16 +-
 ..._file_handler_registration_win_unittest.cc |   7 +-
 .../web_app_handler_registration_utils_win.cc |  28 +-
 ...handler_registration_utils_win_unittest.cc |  50 +-
 ...tocol_handler_registration_win_unittest.cc |  20 +
 .../web_app_shortcut_win_unittest.cc          |   3 +
 .../webshare/share_service_browsertest.cc     |   8 +
 .../webshare/share_service_unittest.cc        |   3 +
 .../win/fake_data_transfer_manager.cc         |   5 +
 .../webshare/win/fake_data_transfer_manager.h |   2 +
 .../win/fake_data_transfer_manager_interop.cc |   5 +
 .../win/fake_data_transfer_manager_interop.h  |   2 +
 ..._data_transfer_manager_interop_unittest.cc |   2 +
 .../fake_data_transfer_manager_unittest.cc    |   3 +
 ...oped_fake_data_transfer_manager_interop.cc |   6 +
 ...coped_fake_data_transfer_manager_interop.h |   2 +
 .../scoped_share_operation_fake_components.cc |   6 +
 .../scoped_share_operation_fake_components.h  |   2 +
 .../webshare/win/share_operation_unittest.cc  |  28 +
 .../win/show_share_ui_for_window_operation.cc |  13 +-
 ..._share_ui_for_window_operation_unittest.cc |   2 +
 .../incompatible_applications_browsertest.cc  |   4 +
 .../incompatible_applications_updater.cc      |   6 +-
 ...ompatible_applications_updater_unittest.cc |  40 +
 .../module_blocklist_cache_updater.cc         |   4 +-
 .../third_party_blocking_browsertest.cc       |   4 +
 .../third_party_conflicts_manager_unittest.cc |   9 +-
 chrome/browser/win/parental_controls.cc       |   4 +-
 chrome/browser/win/titlebar_config.cc         |   4 +-
 .../system_restore_point_component.cc         |  24 +-
 chrome/chrome_cleaner/ipc/sandbox.cc          |   4 +-
 .../os/task_scheduler_unittest.cc             |  11 +
 chrome/chrome_cleaner/test/cleaner_test.cc    |   6 +
 chrome/chrome_cleaner/test/test_util.cc       |   7 +-
 chrome/chrome_elf/chrome_elf_security.cc      |  23 +-
 chrome/chrome_elf/hook_util/hook_util.cc      |  38 +
 chrome/chrome_elf/hook_util/hook_util.h       |  12 +
 chrome/chrome_elf/nt_registry/nt_registry.cc  |  95 +++
 chrome/chrome_elf/nt_registry/nt_registry.h   |  27 +-
 .../nt_registry/nt_registry_functions.h       |  42 +
 .../nt_registry/nt_registry_unittest.cc       |  84 ++
 chrome/chrome_elf/third_party_dlls/hook.cc    |  24 +-
 .../gaiacp/scoped_user_profile.cc             |  39 +-
 .../test/gcp_gls_output_unittest.cc           |  48 +-
 chrome/installer/setup/install.cc             |   2 +
 chrome/installer/setup/setup_main.cc          |   4 +-
 chrome/installer/setup/user_experiment.cc     |   5 +
 chrome/installer/util/install_util.cc         |   4 +-
 chrome/installer/util/shell_util.cc           | 279 ++++++-
 chrome/installer/util/shell_util.h            |  13 +
 .../util/shell_util_interactive_uitest.cc     |   5 +
 chrome/installer/util/shell_util_unittest.cc  |  50 +-
 chrome/installer/util/taskbar_util.cc         |   6 +-
 .../chrome_content_renderer_client.cc         |   7 +
 chrome/test/delayload/delayloads_unittest.cc  |  10 +-
 chrome/updater/run_all_unittests.cc           |   8 +
 chrome/updater/util/unittest_util.cc          |  12 +-
 chrome/updater/win/installer/installer.cc     |   2 +-
 .../embedder_support/user_agent_utils.cc      |  77 +-
 .../user_agent_utils_unittest.cc              |  43 +-
 .../infobars/core/confirm_infobar_delegate.cc |   4 +
 .../infobars/core/confirm_infobar_delegate.h  |   4 +
 .../system_memory_pressure_evaluator.cc       |   7 +-
 .../services/quarantine/quarantine_win.cc     |  21 +-
 .../services/quarantine/test_support_win.cc   |   7 +-
 .../browser/spellcheck_platform_win.cc        |   9 +-
 .../browser/windows_spell_checker.cc          |   3 +-
 .../browser/windows_spell_checker_unittest.cc |  27 +-
 .../spellcheck/common/spellcheck_features.cc  |  11 +-
 .../spellcheck/common/spellcheck_features.h   |   2 +
 .../renderer/spellcheck_provider_unittest.cc  |   8 +
 content/app/initialize_mojo_core.cc           |  13 +-
 content/browser/BUILD.gn                      |   2 +
 ..._node_textrangeprovider_win_browsertest.cc |   6 +
 content/browser/browser_main_loop.cc          |  11 +
 .../font_unique_name_browsertest.cc           |   1 +
 content/browser/form_controls_browsertest.cc  |  17 +
 content/browser/gpu/gpu_internals_ui.cc       |   5 +-
 ...gin_sandboxed_process_launcher_delegate.cc |  11 +-
 .../direct_manipulation_helper_win.cc         |   9 +
 .../direct_manipulation_win_browsertest.cc    |  13 +
 .../direct_manipulation_win_unittest.cc       |   7 +
 .../dwrite_font_lookup_table_builder_win.cc   | 773 ++++++++++++++++++
 .../dwrite_font_lookup_table_builder_win.h    | 255 ++++++
 ..._font_lookup_table_builder_win_unittest.cc | 241 ++++++
 .../dwrite_font_proxy_impl_win.cc             |  45 +-
 .../dwrite_font_proxy_impl_win.h              |  10 +
 .../dwrite_font_proxy_impl_win_unittest.cc    | 171 ++++
 .../renderer_host/render_process_host_impl.cc |   1 +
 ...er_widget_host_view_aura_vk_browsertest.cc |  31 +
 content/child/font_warmup_win.cc              |   8 +-
 content/child/font_warmup_win_unittest.cc     |  25 +
 content/child/runtime_features.cc             |   9 +-
 ...webthemeengine_impl_default_browsertest.cc |  48 +-
 .../public/browser/content_browser_client.cc  |   4 +
 .../public/browser/content_browser_client.h   |   5 +
 content/public/common/content_features.cc     |  11 +-
 content/public/common/content_switches.cc     |   4 +
 content/public/common/content_switches.h      |   1 +
 .../content_renderer_pepper_host_factory.cc   |   8 +-
 .../renderer/pepper/resource_creation_impl.cc |  10 +-
 content/renderer/render_view_browsertest.cc   |  10 +
 .../renderer/renderer_blink_platform_impl.cc  |  20 +
 .../renderer/renderer_blink_platform_impl.h   |   2 +
 .../browser/shell_content_browser_client.cc   |   5 +
 .../browser/shell_content_browser_client.h    |   1 +
 content/test/BUILD.gn                         |   1 +
 .../aom/aom-live-region-expected-uia-win7.txt |   5 +
 .../aom-modal-dialog-expected-uia-win7.txt    |   7 +
 .../aria-contentinfo-expected-uia-win7.txt    |   3 +
 .../aria-describedby-expected-uia-win7.txt    |   5 +
 .../aria-description-expected-uia-win7.txt    |   5 +
 ...ria-details-multiple-expected-uia-win7.txt |  11 +
 ...a-tree-discontinuous-expected-uia-win7.txt |   7 +
 .../aria/aria-treegrid-expected-uia-win7.txt  |  79 ++
 .../add-alert-content-expected-uia-win7.txt   |   5 +
 ...-dialog-described-by-expected-uia-win7.txt |   6 +
 .../event/add-dialog-expected-uia-win7.txt    |   6 +
 .../add-dialog-no-info-expected-uia-win7.txt  |   6 +
 ...a-combo-box-collapse-expected-uia-win7.txt |   5 +
 .../event/aria-flow-to-expected-uia-win7.txt  |  11 +
 .../aria-level-changed-expected-uia-win7.txt  |   3 +
 .../aria-live-changed-expected-uia-win7.txt   |   4 +
 ...ria-posinset-changed-expected-uia-win7.txt |   2 +
 ...aria-setsize-changed-expected-uia-win7.txt |   3 +
 .../description-change-expected-uia-win7.txt  |   0
 ...tion-change-indirect-expected-uia-win7.txt |   4 +
 .../live-region-add-expected-uia-win7.txt     |   4 +
 ...n-add-live-attribute-expected-uia-win7.txt |   2 +
 .../live-region-change-expected-uia-win7.txt  |   2 +
 ...ubar-show-hide-menus-expected-uia-win7.txt |  32 +
 .../menulist-collapse-expected-uia-win7.txt   |   8 +
 ...nulist-collapse-next-expected-uia-win7.txt |  11 +
 ...ility-hidden-changed-expected-uia-win7.txt |   3 +
 .../html/a-name-calc-expected-uia-win7.txt    |  15 +
 .../button-name-calc-expected-uia-win7.txt    |  20 +
 .../html/footer-expected-uia-win7.txt         |   3 +
 ...date-with-popup-open-expected-uia-win7.txt | 134 +++
 ...aria-setsize-unknown-expected-uia-win7.txt |  15 +
 ...ze-unknown-flattened-expected-uia-win7.txt |  32 +
 .../html/output-expected-uia-win7.txt         |   7 +
 content/test/dwrite_font_fake_sender_win.cc   |   9 +
 content/test/dwrite_font_fake_sender_win.h    |   6 +
 device/bluetooth/bluetooth_adapter_factory.cc |  15 +-
 device/bluetooth/bluetooth_adapter_win.cc     |  11 +-
 device/bluetooth/bluetooth_adapter_win.h      |   8 +-
 device/bluetooth/bluetooth_low_energy_win.cc  |  39 +-
 device/bluetooth/bluetooth_low_energy_win.h   |   9 +-
 .../bluetooth_low_energy_win_fake.cc          |  33 +-
 .../bluetooth/bluetooth_low_energy_win_fake.h |   1 +
 .../bluetooth/bluetooth_task_manager_win.cc   |   8 +
 device/bluetooth/test/bluetooth_test_win.cc   |  73 +-
 device/bluetooth/test/bluetooth_test_win.h    |   1 +
 .../gamepad/gamepad_platform_data_fetcher.h   |   4 +-
 .../gamepad/wgi_data_fetcher_win_unittest.cc  |   8 +
 device/gamepad/xinput_data_fetcher_win.cc     |  19 +-
 .../api/app_window/app_window_apitest.cc      |  10 +
 .../dxgi_shared_handle_manager_unittest.cc    |   6 +-
 .../dxgi_swap_chain_image_backing.cc          |   5 +-
 gpu/config/gpu_info_collector_win.cc          |  57 +-
 gpu/ipc/service/gpu_watchdog_thread.cc        |  19 +-
 .../service/gpu_watchdog_thread_unittest.cc   |  16 +-
 media/audio/audio_encoders_unittest.cc        |   6 +
 .../audio/win/audio_low_latency_input_win.cc  |   4 +
 media/audio/win/core_audio_util_win.cc        |  16 +-
 media/audio/win/core_audio_util_win.h         |   4 +
 .../audio/win/core_audio_util_win_unittest.cc |   9 +-
 media/base/win/dxgi_device_manager.cc         |  13 +-
 .../win/dxgi_device_scope_handle_unittest.cc  |  20 +-
 .../video/video_capture_device_unittest.cc    |  13 +-
 .../win/gpu_memory_buffer_tracker_unittest.cc |  27 +-
 .../win/video_capture_device_factory_win.cc   |  10 +-
 ...deo_capture_device_factory_win_unittest.cc |  25 +-
 .../video_capture_device_mf_win_unittest.cc   |  17 +-
 .../win/video_capture_device_utils_win.cc     |  27 +-
 .../windows/d3d11_texture_wrapper_unittest.cc |  16 +
 .../windows/d3d11_video_decoder_unittest.cc   |  17 +-
 .../dxva_video_decode_accelerator_win.cc      |  31 +-
 ...foundation_video_encode_accelerator_win.cc |  71 +-
 ..._foundation_video_encode_accelerator_win.h |   2 +
 media/gpu/windows/mf_audio_encoder.cc         |  19 +-
 .../gpu/windows/supported_profile_helpers.cc  |   3 +
 .../supported_profile_helpers_unittest.cc     |  27 +-
 media/midi/midi_manager_win.cc                |   4 +-
 .../services/gpu_mojo_media_client_win.cc     |  15 +-
 .../win/media_foundation_renderer.cc          |   9 +-
 .../renderers/win/media_foundation_renderer.h |   4 +-
 ...ia_foundation_renderer_integration_test.cc |  12 +-
 .../win/media_foundation_renderer_unittest.cc |  29 +-
 mojo/core/embedder/embedder.cc                |  27 +-
 mojo/core/embedder/embedder.h                 |  15 +-
 net/base/network_change_notifier_win.cc       |  11 +
 .../network_change_notifier_win_unittest.cc   |   5 +
 net/cert/cert_verify_proc.cc                  |  17 +-
 net/cert/cert_verify_proc_unittest.cc         |  38 +-
 net/cert/cert_verify_proc_win.cc              |  72 +-
 remoting/base/url_request_context_getter.cc   |  18 +
 remoting/host/desktop_session_win.cc          |  52 +-
 remoting/host/host_attributes.cc              |  17 +-
 remoting/host/input_injector_win.cc           |   3 +-
 .../remote_open_url/remote_open_url_util.cc   |   7 +
 remoting/host/win/evaluate_3d_display_mode.cc |   6 +
 sandbox/features.cc                           |   4 -
 sandbox/features.h                            |   4 +
 sandbox/policy/switches.cc                    |   1 +
 .../policy/win/sandbox_policy_feature_test.cc |   4 +-
 .../policy/win/sandbox_policy_feature_test.h  |   3 +
 sandbox/policy/win/sandbox_win.cc             |  89 +-
 sandbox/win/src/address_sanitizer_test.cc     |   1 +
 sandbox/win/src/app_container_base.cc         |  65 +-
 sandbox/win/src/app_container_base.h          |   3 +-
 sandbox/win/src/app_container_test.cc         |  30 +-
 sandbox/win/src/app_container_unittest.cc     |   1 +
 sandbox/win/src/broker_services.cc            |  29 +-
 sandbox/win/src/broker_services.h             |   2 +
 sandbox/win/src/file_policy_test.cc           |   6 +
 sandbox/win/src/filesystem_policy.cc          |   1 +
 sandbox/win/src/handle_closer.cc              |   1 +
 sandbox/win/src/handle_closer_agent.cc        |   6 +
 sandbox/win/src/handle_inheritance_test.cc    |   1 +
 sandbox/win/src/heap_helper.cc                |   5 +
 sandbox/win/src/integrity_level_test.cc       |   1 +
 sandbox/win/src/interception.cc               |  23 +-
 sandbox/win/src/job.cc                        |  46 +-
 sandbox/win/src/job.h                         |  22 +-
 sandbox/win/src/job_unittest.cc               | 105 ++-
 sandbox/win/src/lpc_policy_test.cc            |  57 +-
 sandbox/win/src/named_pipe_policy_test.cc     |   1 +
 sandbox/win/src/nt_internals.h                |   6 +
 sandbox/win/src/policy_broker.cc              |   1 +
 sandbox/win/src/policy_target_test.cc         |  26 +-
 sandbox/win/src/process_mitigations.cc        | 210 +++--
 .../win/src/process_mitigations_deathtest.cc  |  16 +
 .../process_mitigations_dyncode_unittest.cc   |   9 +
 ...ss_mitigations_extensionpoints_unittest.cc |  22 +
 .../win/src/process_mitigations_unittest.cc   | 275 +++++--
 .../process_mitigations_win32k_dispatcher.cc  |   1 +
 .../process_mitigations_win32k_unittest.cc    |   7 +
 sandbox/win/src/process_policy_test.cc        |   1 +
 .../win/src/process_thread_interception.cc    |   1 +
 sandbox/win/src/restricted_token_unittest.cc  |   3 +
 sandbox/win/src/restricted_token_utils.cc     | 128 ++-
 sandbox/win/src/restricted_token_utils.h      |   4 +-
 sandbox/win/src/sandbox.h                     |  12 +-
 sandbox/win/src/sandbox_policy_base.cc        |  42 +-
 sandbox/win/src/sandbox_policy_base.h         |  10 +-
 sandbox/win/src/service_resolver.h            |  94 ++-
 sandbox/win/src/service_resolver_32.cc        | 334 +++++---
 sandbox/win/src/service_resolver_64.cc        |   5 +-
 sandbox/win/src/service_resolver_unittest.cc  | 166 ++--
 sandbox/win/src/startup_information_helper.cc |   2 +
 sandbox/win/src/startup_information_helper.h  |   4 +-
 sandbox/win/src/target_process.cc             |  47 +-
 sandbox/win/src/target_process.h              |  13 +
 sandbox/win/src/target_services.cc            |   1 +
 sandbox/win/src/win_utils.cc                  |  30 +
 sandbox/win/src/win_utils.h                   |   5 +
 sandbox/win/src/win_utils_unittest.cc         |   9 +-
 sandbox/win/src/window.cc                     |  54 ++
 sandbox/win/tests/common/controller.cc        |   6 +-
 .../tests/integration_tests/cfi_unittest.cc   |   7 +
 .../win/location_provider_winrt_unittest.cc   |   9 +-
 .../power_save_blocker_win.cc                 |  13 +
 .../face_detection_impl_win_unittest.cc       |   5 +
 .../face_detection_provider_win.cc            |   6 +
 .../text_detection_impl_win.cc                |  10 +
 .../text_detection_impl_win_unittest.cc       |   5 +
 third_party/blink/common/BUILD.gn             |   1 +
 .../dwrite_rasterizer_support.cc              |  30 +
 third_party/blink/public/common/BUILD.gn      |   4 +
 .../dwrite_rasterizer_support.h               |  19 +
 .../dwrite_font_proxy/dwrite_font_proxy.mojom |  46 +-
 third_party/blink/public/platform/platform.h  |   5 +
 .../modules/font_access/font_metadata.cc      |   7 +-
 .../fonts/web_font_typeface_factory.cc        |  10 +-
 .../fonts/win/font_unique_name_lookup_win.cc  | 133 ++-
 .../fonts/win/font_unique_name_lookup_win.h   |  24 +-
 .../rtc_video_decoder_adapter.cc              |   3 +
 .../rtc_video_decoder_stream_adapter.cc       |   3 +
 third_party/centipede/src                     |   1 +
 third_party/cros-components/src               |   1 +
 third_party/crossbench                        |   1 +
 .../histograms/metadata/others/histograms.xml |  33 +
 .../platform/ax_platform_node_win.cc          |  58 +-
 .../inspect/ax_inspect_test_helper.cc         |  15 +-
 ...ative_window_occlusion_tracker_unittest.cc |   7 +-
 .../native_window_occlusion_tracker_win.cc    |   7 +-
 ..._occlusion_tracker_win_interactive_test.cc |   8 +
 ui/base/ime/init/input_method_factory.cc      |   4 +-
 ui/base/ime/win/input_method_win_base.cc      |   6 +-
 ...screen_keyboard_display_manager_tab_tip.cc |   5 +-
 ...creen_keyboard_display_manager_unittest.cc |   4 +
 ui/base/ime/win/tsf_input_scope.cc            |  12 +-
 ui/base/ime/win/tsf_input_scope_unittest.cc   |   3 +
 ui/base/pointer/touch_ui_controller.cc        |   4 +-
 ui/base/ui_base_features.cc                   |   7 +-
 ui/base/ui_base_switches.cc                   |   3 +
 ui/base/ui_base_switches.h                    |   1 +
 ui/base/win/lock_state.cc                     |  10 +-
 ui/base/win/shell.cc                          |  31 +-
 ui/base/win/shell.h                           |  15 +-
 ui/color/win/accent_color_observer.cc         |  40 +-
 ui/display/win/uwp_text_scale_factor.cc       |  14 +-
 ui/gfx/font_fallback_unittest.cc              |  13 +
 ui/gfx/font_fallback_win_unittest.cc          |   5 +
 ui/gfx/render_text.cc                         |  40 +-
 ui/gfx/render_text_unittest.cc                |  20 +-
 ui/gfx/test/font_fallback_test_data.cc        | 118 ++-
 ui/gfx/test/font_fallback_test_data.h         |   6 +-
 ui/gfx/win/direct_write.cc                    |  32 +-
 ui/gl/direct_composition_child_surface_win.cc |   5 +-
 ui/message_center/views/message_view.cc       |   6 +-
 ui/native_theme/caption_style_win.cc          |   8 +-
 ui/native_theme/caption_style_win_unittest.cc |  33 +-
 ui/platform_window/win/win_window.cc          |   7 +-
 .../select_file_dialog_win_unittest.cc        |   5 +
 ui/snapshot/snapshot_aura_unittest.cc         |  56 +-
 ui/snapshot/snapshot_win.cc                   |  30 +-
 ui/views/BUILD.gn                             |   8 +
 ui/views/bubble/bubble_border.cc              |  38 +-
 ui/views/bubble/bubble_border.h               |   9 +-
 ui/views/bubble/bubble_border_unittest.cc     |   3 +-
 .../bubble/bubble_dialog_delegate_view.cc     |  23 +-
 .../bubble_dialog_delegate_view_unittest.cc   |  18 +-
 ui/views/bubble/bubble_frame_view_unittest.cc |  16 +-
 ui/views/corewm/cursor_height_provider_win.cc | 178 ++++
 ui/views/corewm/cursor_height_provider_win.h  |  21 +
 ui/views/corewm/tooltip_win.cc                | 186 +++++
 ui/views/corewm/tooltip_win.h                 |  92 +++
 ui/views/examples/bubble_example.cc           |   7 +-
 ui/views/examples/bubble_example.h            |   1 +
 .../desktop_window_tree_host_win.cc           |  26 +-
 .../desktop_window_tree_host_win.h            |  11 +
 ui/views/widget/widget_hwnd_utils.cc          |  15 +-
 ui/views/widget/widget_interactive_uitest.cc  |   6 +
 ui/views/win/fullscreen_handler.cc            |   7 +
 ui/views/win/hwnd_message_handler.cc          | 119 ++-
 ui/views/win/hwnd_message_handler.h           |  11 +
 ui/views/win/hwnd_message_handler_delegate.h  |   5 +
 ui/views/window/dialog_delegate.cc            |   9 +
 447 files changed, 8971 insertions(+), 1502 deletions(-)
 create mode 100644 content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
 create mode 100644 content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
 create mode 100644 content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc
 create mode 100644 content/test/data/accessibility/aom/aom-live-region-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/aom/aom-modal-dialog-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/aria/aria-contentinfo-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/aria/aria-describedby-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/aria/aria-description-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/aria/aria-details-multiple-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/aria/aria-tree-discontinuous-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/aria/aria-treegrid-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/add-alert-content-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/add-dialog-described-by-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/add-dialog-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/add-dialog-no-info-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/aria-combo-box-collapse-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/aria-flow-to-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/aria-level-changed-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/aria-live-changed-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/aria-posinset-changed-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/aria-setsize-changed-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/description-change-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/description-change-indirect-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/live-region-add-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/live-region-add-live-attribute-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/live-region-change-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/menubar-show-hide-menus-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/menulist-collapse-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/menulist-collapse-next-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/event/visibility-hidden-changed-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/html/a-name-calc-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/html/button-name-calc-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/html/footer-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/html/input-date-with-popup-open-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/html/list-item-aria-setsize-unknown-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/html/list-item-aria-setsize-unknown-flattened-expected-uia-win7.txt
 create mode 100644 content/test/data/accessibility/html/output-expected-uia-win7.txt
 create mode 100644 third_party/blink/common/dwrite_rasterizer_support/dwrite_rasterizer_support.cc
 create mode 100644 third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h
 create mode 160000 third_party/centipede/src
 create mode 160000 third_party/cros-components/src
 create mode 160000 third_party/crossbench
 create mode 100644 ui/views/corewm/cursor_height_provider_win.cc
 create mode 100644 ui/views/corewm/cursor_height_provider_win.h
 create mode 100644 ui/views/corewm/tooltip_win.cc
 create mode 100644 ui/views/corewm/tooltip_win.h

diff --git a/base/allocator/partition_allocator/address_space_randomization.cc b/base/allocator/partition_allocator/address_space_randomization.cc
index dcaa8d3b2e282..907853ef216f4 100644
--- a/base/allocator/partition_allocator/address_space_randomization.cc
+++ b/base/allocator/partition_allocator/address_space_randomization.cc
@@ -10,7 +10,9 @@
 #include "build/build_config.h"
 
 #if BUILDFLAG(IS_WIN)
-#include <windows.h>
+#include <windows.h>  // Must be in front of other Windows header files.
+
+#include <versionhelpers.h>
 #endif
 
 namespace partition_alloc {
@@ -22,10 +24,26 @@ uintptr_t GetRandomPageBase() {
   random <<= 32ULL;
   random |= static_cast<uintptr_t>(internal::RandomValue());
 
-  // The ASLRMask() and ASLROffset() constants will be suitable for the
-  // OS and build configuration.
+// The ASLRMask() and ASLROffset() constants will be suitable for the
+// OS and build configuration.
+#if BUILDFLAG(IS_WIN) && !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
+  // Windows >= 8.1 has the full 47 bits. Use them where available.
+  static bool windows_81 = false;
+  static bool windows_81_initialized = false;
+  if (!windows_81_initialized) {
+    windows_81 = IsWindows8Point1OrGreater();
+    windows_81_initialized = true;
+  }
+  if (!windows_81) {
+    random &= internal::ASLRMaskBefore8_10();
+  } else {
+    random &= internal::ASLRMask();
+  }
+  random += internal::ASLROffset();
+#else
   random &= internal::ASLRMask();
   random += internal::ASLROffset();
+#endif  // BUILDFLAG(IS_WIN) && !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
 #else   // PA_CONFIG(HAS_64_BITS_POINTERS)
 #if BUILDFLAG(IS_WIN)
   // On win32 host systems the randomization plus huge alignment causes
diff --git a/base/allocator/partition_allocator/address_space_randomization.h b/base/allocator/partition_allocator/address_space_randomization.h
index e4767ca7bd394..e76125677f17e 100644
--- a/base/allocator/partition_allocator/address_space_randomization.h
+++ b/base/allocator/partition_allocator/address_space_randomization.h
@@ -56,12 +56,16 @@ AslrMask(uintptr_t bits) {
 
   #elif BUILDFLAG(IS_WIN)
 
-    // Windows 8.10 and newer support the full 48 bit address range. Since
-    // ASLROffset() is non-zero and may cause a carry, use 47 bit masks. See
+    // Windows 8.10 and newer support the full 48 bit address range. Older
+    // versions of Windows only support 44 bits. Since ASLROffset() is non-zero
+    // and may cause a carry, use 47 and 43 bit masks. See
     // http://www.alex-ionescu.com/?p=246
     constexpr PA_ALWAYS_INLINE uintptr_t ASLRMask() {
       return AslrMask(47);
     }
+    constexpr PA_ALWAYS_INLINE uintptr_t ASLRMaskBefore8_10() {
+      return AslrMask(43);
+    }
     // Try not to map pages into the range where Windows loads DLLs by default.
     constexpr PA_ALWAYS_INLINE uintptr_t ASLROffset() {
       return 0x80000000ULL;
diff --git a/base/allocator/partition_allocator/address_space_randomization_unittest.cc b/base/allocator/partition_allocator/address_space_randomization_unittest.cc
index 196e7e3d1976d..d8211de8d6a69 100644
--- a/base/allocator/partition_allocator/address_space_randomization_unittest.cc
+++ b/base/allocator/partition_allocator/address_space_randomization_unittest.cc
@@ -17,6 +17,8 @@
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
 #include "base/win/windows_version.h"
+// versionhelpers.h must be included after windows.h.
+#include <versionhelpers.h>
 #endif
 
 namespace partition_alloc {
@@ -26,6 +28,12 @@ namespace {
 uintptr_t GetMask() {
   uintptr_t mask = internal::ASLRMask();
 #if defined(ARCH_CPU_64_BITS)
+// Sanitizers use their own ASLR mask constant.
+#if BUILDFLAG(IS_WIN) && !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
+  if (!IsWindows8Point1OrGreater()) {
+    mask = internal::ASLRMaskBefore8_10();
+  }
+#endif  // BUILDFLAG(IS_WIN) && !defined(MEMORY_TOOL_REPLACES_ALLOCATOR))
 #elif defined(ARCH_CPU_32_BITS)
 #if BUILDFLAG(IS_WIN)
   BOOL is_wow64 = FALSE;
diff --git a/base/allocator/partition_allocator/page_allocator_internals_win.h b/base/allocator/partition_allocator/page_allocator_internals_win.h
index 7c73ccda1500e..f3bb11989a44d 100644
--- a/base/allocator/partition_allocator/page_allocator_internals_win.h
+++ b/base/allocator/partition_allocator/page_allocator_internals_win.h
@@ -5,6 +5,8 @@
 #ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 #define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 
+#include <versionhelpers.h>
+
 #include <cstdint>
 
 #include "base/allocator/partition_allocator/oom.h"
@@ -16,6 +18,17 @@
 
 namespace partition_alloc::internal {
 
+namespace {
+
+// On Windows, discarded pages are not returned to the system immediately and
+// not guaranteed to be zeroed when returned to the application.
+using DiscardVirtualMemoryFunction = DWORD(WINAPI*)(PVOID virtualAddress,
+                                                    SIZE_T size);
+DiscardVirtualMemoryFunction s_discard_virtual_memory =
+    reinterpret_cast<DiscardVirtualMemoryFunction>(-1);
+
+}  // namespace
+
 // |VirtualAlloc| will fail if allocation at the hint address is blocked.
 constexpr bool kHintIsAdvisory = false;
 std::atomic<int32_t> s_allocPageErrorCode{ERROR_SUCCESS};
@@ -224,10 +237,27 @@ bool TryRecommitSystemPagesInternal(
 }
 
 void DiscardSystemPagesInternal(uintptr_t address, size_t length) {
+  if (s_discard_virtual_memory ==
+      reinterpret_cast<DiscardVirtualMemoryFunction>(-1)) {
+    // DiscardVirtualMemory's minimum supported client is Windows 8.1 Update.
+    // So skip GetProcAddress("DiscardVirtualMemory") if windows version is
+    // smaller than Windows 8.1.
+    if (IsWindows8Point1OrGreater()) {
+      s_discard_virtual_memory =
+          reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+              GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+    } else {
+      s_discard_virtual_memory = nullptr;
+    }
+  }
+
   void* ptr = reinterpret_cast<void*>(address);
   // Use DiscardVirtualMemory when available because it releases faster than
   // MEM_RESET.
-  DWORD ret = DiscardVirtualMemory(ptr, length);
+  DWORD ret = 1;
+  if (s_discard_virtual_memory) {
+    ret = s_discard_virtual_memory(ptr, length);
+  }
   // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
   // failure.
   if (ret) {
diff --git a/base/base_paths_win.cc b/base/base_paths_win.cc
index 3ac45e74666f7..605ad1152386d 100644
--- a/base/base_paths_win.cc
+++ b/base/base_paths_win.cc
@@ -146,6 +146,9 @@ bool PathProviderWin(int key, FilePath* result) {
       break;
     }
     case base::DIR_APP_SHORTCUTS: {
+      if (win::GetVersion() < win::Version::WIN8)
+        return false;
+
       base::win::ScopedCoMem<wchar_t> path_buf;
       if (FAILED(SHGetKnownFolderPath(FOLDERID_ApplicationShortcuts, 0, NULL,
                                       &path_buf)))
diff --git a/base/debug/invalid_access_win.cc b/base/debug/invalid_access_win.cc
index dc0d54bbc67ec..246e8e4775a43 100644
--- a/base/debug/invalid_access_win.cc
+++ b/base/debug/invalid_access_win.cc
@@ -9,6 +9,7 @@
 #include <windows.h>
 
 #include "base/check.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 
 namespace base {
@@ -41,10 +42,21 @@ void IndirectCall(FuncType* func) {
   (*func)();
 }
 
+void CreateSyntheticHeapCorruption() {
+  EXCEPTION_RECORD record = {};
+  record.ExceptionCode = STATUS_HEAP_CORRUPTION;
+  RaiseFailFastException(&record, nullptr,
+                         FAIL_FAST_GENERATE_EXCEPTION_ADDRESS);
+}
+
 }  // namespace
 
 void TerminateWithHeapCorruption() {
   __try {
+    // Pre-Windows 10, it's hard to trigger a heap corruption fast fail, so
+    // artificially create one instead.
+    if (base::win::GetVersion() < base::win::Version::WIN10)
+      CreateSyntheticHeapCorruption();
     HANDLE heap = ::HeapCreate(0, 0, 0);
     CHECK(heap);
     CHECK(HeapSetInformation(heap, HeapEnableTerminationOnCorruption, nullptr,
diff --git a/base/files/file_util_win.cc b/base/files/file_util_win.cc
index c84124e3494b9..e8d15763c5e31 100644
--- a/base/files/file_util_win.cc
+++ b/base/files/file_util_win.cc
@@ -1059,18 +1059,44 @@ bool SetNonBlocking(int fd) {
   return false;
 }
 
+namespace {
+
+// ::PrefetchVirtualMemory() is only available on Windows 8 and above. Chrome
+// supports Windows 7, so we need to check for the function's presence
+// dynamically.
+using PrefetchVirtualMemoryPtr = decltype(&::PrefetchVirtualMemory);
+
+// Returns null if ::PrefetchVirtualMemory() is not available.
+PrefetchVirtualMemoryPtr GetPrefetchVirtualMemoryPtr() {
+  HMODULE kernel32_dll = ::GetModuleHandleA("kernel32.dll");
+  return reinterpret_cast<PrefetchVirtualMemoryPtr>(
+      GetProcAddress(kernel32_dll, "PrefetchVirtualMemory"));
+}
+
+}  // namespace
+
 bool PreReadFile(const FilePath& file_path,
                  bool is_executable,
                  int64_t max_bytes) {
   DCHECK_GE(max_bytes, 0);
 
+  // On Win8 and higher use ::PrefetchVirtualMemory(). This is better than a
+  // simple data file read, more from a RAM perspective than CPU. This is
+  // because reading the file as data results in double mapping to
+  // Image/executable pages for all pages of code executed.
+  static PrefetchVirtualMemoryPtr prefetch_virtual_memory =
+      GetPrefetchVirtualMemoryPtr();
+
+  if (prefetch_virtual_memory == nullptr)
+    return internal::PreReadFileSlow(file_path, max_bytes);
+
   if (max_bytes == 0) {
-    // ::PrefetchVirtualMemory() fails when asked to read zero bytes.
+    // PrefetchVirtualMemory() fails when asked to read zero bytes.
     // base::MemoryMappedFile::Initialize() fails on an empty file.
     return true;
   }
 
-  // ::PrefetchVirtualMemory() fails if the file is opened with write access.
+  // PrefetchVirtualMemory() fails if the file is opened with write access.
   MemoryMappedFile::Access access = is_executable
                                         ? MemoryMappedFile::READ_CODE_IMAGE
                                         : MemoryMappedFile::READ_ONLY;
@@ -1082,11 +1108,7 @@ bool PreReadFile(const FilePath& file_path,
       std::min(base::saturated_cast<::SIZE_T>(max_bytes),
                base::saturated_cast<::SIZE_T>(mapped_file.length()));
   ::_WIN32_MEMORY_RANGE_ENTRY address_range = {mapped_file.data(), length};
-  // Use ::PrefetchVirtualMemory(). This is better than a
-  // simple data file read, more from a RAM perspective than CPU. This is
-  // because reading the file as data results in double mapping to
-  // Image/executable pages for all pages of code executed.
-  if (!::PrefetchVirtualMemory(::GetCurrentProcess(),
+  if (!prefetch_virtual_memory(::GetCurrentProcess(),
                                /*NumberOfEntries=*/1, &address_range,
                                /*Flags=*/0)) {
     return internal::PreReadFileSlow(file_path, max_bytes);
diff --git a/base/memory/discardable_shared_memory.cc b/base/memory/discardable_shared_memory.cc
index 23c95bad719c7..62a0b3c1f1d17 100644
--- a/base/memory/discardable_shared_memory.cc
+++ b/base/memory/discardable_shared_memory.cc
@@ -422,11 +422,23 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
 #elif BUILDFLAG(IS_WIN)
   // On Windows, discarded pages are not returned to the system immediately and
   // not guaranteed to be zeroed when returned to the application.
+  using DiscardVirtualMemoryFunction =
+      DWORD(WINAPI*)(PVOID virtualAddress, SIZE_T size);
+  static DiscardVirtualMemoryFunction discard_virtual_memory =
+      reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+          GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+
   char* address = static_cast<char*>(shared_memory_mapping_.memory()) +
                   AlignToPageSize(sizeof(SharedState));
   size_t length = AlignToPageSize(mapped_size_);
 
-  DWORD ret = DiscardVirtualMemory(address, length);
+  // Use DiscardVirtualMemory when available because it releases faster than
+  // MEM_RESET.
+  DWORD ret = ERROR_NOT_SUPPORTED;
+  if (discard_virtual_memory) {
+    ret = discard_virtual_memory(address, length);
+  }
+
   // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
   // failure.
   if (ret != ERROR_SUCCESS) {
diff --git a/base/memory/platform_shared_memory_region_win.cc b/base/memory/platform_shared_memory_region_win.cc
index e387015249731..bdf62a3e0c9c9 100644
--- a/base/memory/platform_shared_memory_region_win.cc
+++ b/base/memory/platform_shared_memory_region_win.cc
@@ -14,9 +14,14 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/process_handle.h"
+#include "base/rand_util.h"
 #include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 
-namespace base::subtle {
+namespace base {
+namespace subtle {
 
 namespace {
 
@@ -211,6 +216,18 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   }
 
   std::u16string name;
+  if (win::GetVersion() < win::Version::WIN8_1) {
+    // Windows < 8.1 ignores DACLs on certain unnamed objects (like shared
+    // sections). So, we generate a random name when we need to enforce
+    // read-only.
+    uint64_t rand_values[4];
+    RandBytes(&rand_values, sizeof(rand_values));
+    name = ASCIIToUTF16(StringPrintf("CrSharedMem_%016llx%016llx%016llx%016llx",
+                                     rand_values[0], rand_values[1],
+                                     rand_values[2], rand_values[3]));
+    DCHECK(!name.empty());
+  }
+
   SECURITY_ATTRIBUTES sa = {sizeof(sa), &sd, FALSE};
   // Ask for the file mapping with reduced permisions to avoid passing the
   // access control permissions granted by default into unpriviledged process.
@@ -267,4 +284,5 @@ PlatformSharedMemoryRegion::PlatformSharedMemoryRegion(
     const UnguessableToken& guid)
     : handle_(std::move(handle)), mode_(mode), size_(size), guid_(guid) {}
 
-}  // namespace base::subtle
+}  // namespace subtle
+}  // namespace base
diff --git a/base/path_service_unittest.cc b/base/path_service_unittest.cc
index 4cd5ecb9a07af..3bbaf21dfd10b 100644
--- a/base/path_service_unittest.cc
+++ b/base/path_service_unittest.cc
@@ -142,7 +142,14 @@ TEST_F(PathServiceTest, Get) {
   }
 #if BUILDFLAG(IS_WIN)
   for (int key = PATH_WIN_START + 1; key < PATH_WIN_END; ++key) {
-    EXPECT_PRED1(ReturnsValidPath, key);
+    bool valid = true;
+    if (key == DIR_APP_SHORTCUTS)
+      valid = base::win::GetVersion() >= base::win::Version::WIN8;
+
+    if (valid)
+      EXPECT_PRED1(ReturnsValidPath, key);
+    else
+      EXPECT_PRED1(ReturnsInvalidPath, key);
   }
 #elif BUILDFLAG(IS_APPLE)
   for (int key = PATH_MAC_START + 1; key < PATH_MAC_END; ++key) {
diff --git a/base/process/launch_win.cc b/base/process/launch_win.cc
index 615d74d1d4b5a..8ac7002543e95 100644
--- a/base/process/launch_win.cc
+++ b/base/process/launch_win.cc
@@ -349,6 +349,15 @@ Process LaunchProcess(const CommandLine::StringType& cmdline,
     startup_info->hStdError = options.stderr_handle;
   }
 
+  if (options.job_handle) {
+    // If this code is run under a debugger, the launched process is
+    // automatically associated with a job object created by the debugger.
+    // The CREATE_BREAKAWAY_FROM_JOB flag is used to prevent this on Windows
+    // releases that do not support nested jobs.
+    if (win::GetVersion() < win::Version::WIN8)
+      flags |= CREATE_BREAKAWAY_FROM_JOB;
+  }
+
   if (options.force_breakaway_from_job_)
     flags |= CREATE_BREAKAWAY_FROM_JOB;
 
diff --git a/base/process/process_unittest.cc b/base/process/process_unittest.cc
index ae7b17bfa4f04..5077df915b448 100644
--- a/base/process/process_unittest.cc
+++ b/base/process/process_unittest.cc
@@ -4,7 +4,6 @@
 
 #include "base/process/process.h"
 
-#include <string>
 #include <utility>
 
 #include "base/at_exit.h"
@@ -36,6 +35,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/base_win_buildflags.h"
+#include "base/win/windows_version.h"
 
 #include <windows.h>
 #endif
@@ -91,8 +91,7 @@ std::string GetProcessCpuCgroup(const base::Process& process) {
   return std::string();
 }
 
-bool AddProcessToCpuCgroup(const base::Process& process,
-                           const std::string& cgroup) {
+bool AddProcessToCpuCgroup(const base::Process& process, std::string& cgroup) {
   base::FilePath path(cgroup);
   path = path.Append("cgroup.procs");
   return base::WriteFile(path, base::NumberToString(process.Pid()));
@@ -412,6 +411,9 @@ TEST_F(ProcessTest, MAYBE_HeapCorruption) {
 #define MAYBE_ControlFlowViolation DISABLED_ControlFlowViolation
 #endif
 TEST_F(ProcessTest, MAYBE_ControlFlowViolation) {
+  // CFG is only supported on Windows 8.1 or greater.
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return;
   // CFG causes ntdll!RtlFailFast2 to be called resulting in uncatchable
   // 0xC0000409 (STATUS_STACK_BUFFER_OVERRUN) exception.
   EXPECT_EXIT(base::debug::win::TerminateWithControlFlowViolation(),
diff --git a/base/process/process_win.cc b/base/process/process_win.cc
index a92fe6d1a6556..074992ff8c0ff 100644
--- a/base/process/process_win.cc
+++ b/base/process/process_win.cc
@@ -292,11 +292,17 @@ bool Process::SetProcessBackgrounded(bool value) {
       power_throttling.ControlMask = 0;
       power_throttling.StateMask = 0;
     }
-    bool ret =
-        ::SetProcessInformation(Handle(), ProcessPowerThrottling,
-                                &power_throttling, sizeof(power_throttling));
-    if (ret == 0) {
-      DPLOG(ERROR) << "Setting process QoS policy fails";
+
+    static const auto set_process_information_fn =
+        reinterpret_cast<decltype(&::SetProcessInformation)>(::GetProcAddress(
+          ::GetModuleHandle(L"Kernel32.dll"), "SetProcessInformation"));
+    if (set_process_information_fn) {
+      bool ret =
+        set_process_information_fn(Handle(), ProcessPowerThrottling,
+                                  &power_throttling, sizeof(power_throttling));
+      if (ret == 0) {
+        DPLOG(ERROR) << "Setting process QoS policy fails";
+      }
     }
   }
 
diff --git a/base/task/thread_pool/thread_group.cc b/base/task/thread_pool/thread_group.cc
index 8eb2e951139b6..bc8199344a519 100644
--- a/base/task/thread_pool/thread_group.cc
+++ b/base/task/thread_pool/thread_group.cc
@@ -17,7 +17,9 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/com_init_check_hook.h"
+#include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace base {
@@ -325,8 +327,18 @@ bool ThreadGroup::ShouldYield(TaskSourceSortKey sort_key) {
 std::unique_ptr<win::ScopedWindowsThreadEnvironment>
 ThreadGroup::GetScopedWindowsThreadEnvironment(WorkerEnvironment environment) {
   std::unique_ptr<win::ScopedWindowsThreadEnvironment> scoped_environment;
-  if (environment == WorkerEnvironment::COM_MTA) {
-    scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+  switch (environment) {
+    case WorkerEnvironment::COM_MTA: {
+      if (win::GetVersion() >= win::Version::WIN8) {
+        scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+      } else {
+        scoped_environment = std::make_unique<win::ScopedCOMInitializer>(
+            win::ScopedCOMInitializer::kMTA);
+      }
+      break;
+    }
+    default:
+      break;
   }
 
   DCHECK(!scoped_environment || scoped_environment->Succeeded());
diff --git a/base/test/launcher/test_launcher.cc b/base/test/launcher/test_launcher.cc
index 98aaabe3be113..f1966015cb690 100644
--- a/base/test/launcher/test_launcher.cc
+++ b/base/test/launcher/test_launcher.cc
@@ -78,6 +78,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/strings/string_util_win.h"
+#include "base/win/windows_version.h"
 
 #include <windows.h>
 
@@ -97,8 +98,7 @@
 
 namespace base {
 
-// See
-// https://groups.google.com/a/chromium.org/d/msg/chromium-dev/nkdTP7sstSc/uT3FaE_sgkAJ
+// See https://groups.google.com/a/chromium.org/d/msg/chromium-dev/nkdTP7sstSc/uT3FaE_sgkAJ .
 using ::operator<<;
 
 // The environment variable name for the total number of test shards.
@@ -422,6 +422,13 @@ int LaunchChildTestProcessWithOptions(const CommandLine& command_line,
 
     DWORD job_flags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
 
+    // Allow break-away from job since sandbox and few other places rely on it
+    // on Windows versions prior to Windows 8 (which supports nested jobs).
+    if (win::GetVersion() < win::Version::WIN8 &&
+        flags & TestLauncher::ALLOW_BREAKAWAY_FROM_JOB) {
+      job_flags |= JOB_OBJECT_LIMIT_BREAKAWAY_OK;
+    }
+
     if (!SetJobObjectLimitFlags(job_handle.get(), job_flags)) {
       LOG(ERROR) << "Could not SetJobObjectLimitFlags.";
       return -1;
diff --git a/base/test/launcher/test_launcher_unittest.cc b/base/test/launcher/test_launcher_unittest.cc
index 6f157ba044062..f03265a6ca52e 100644
--- a/base/test/launcher/test_launcher_unittest.cc
+++ b/base/test/launcher/test_launcher_unittest.cc
@@ -33,6 +33,10 @@
 #include "testing/multiprocess_func_list.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace base {
 namespace {
 
@@ -1140,6 +1144,13 @@ TEST_F(UnitTestLauncherDelegateTester, RunMockTests) {
   command_line.AppendSwitchPath("test-launcher-summary-output", path);
   command_line.AppendSwitch("gtest_also_run_disabled_tests");
   command_line.AppendSwitchASCII("test-launcher-retry-limit", "0");
+#if BUILDFLAG(IS_WIN)
+  // In Windows versions prior to Windows 8, nested job objects are
+  // not allowed and cause this test to fail.
+  if (win::GetVersion() < win::Version::WIN8) {
+    command_line.AppendSwitch(kDontUseJobObjectFlag);
+  }
+#endif  // BUILDFLAG(IS_WIN)
 
   std::string output;
   GetAppOutputAndError(command_line, &output);
@@ -1248,6 +1259,13 @@ TEST_F(UnitTestLauncherDelegateTester, LeakedChildProcess) {
   command_line.AppendSwitchPath("test-launcher-summary-output", path);
   command_line.AppendSwitch("gtest_also_run_disabled_tests");
   command_line.AppendSwitchASCII("test-launcher-retry-limit", "0");
+#if BUILDFLAG(IS_WIN)
+  // In Windows versions prior to Windows 8, nested job objects are
+  // not allowed and cause this test to fail.
+  if (win::GetVersion() < win::Version::WIN8) {
+    command_line.AppendSwitch(kDontUseJobObjectFlag);
+  }
+#endif  // BUILDFLAG(IS_WIN)
 
   std::string output;
   int exit_code = 0;
diff --git a/base/test/launcher/unit_test_launcher.cc b/base/test/launcher/unit_test_launcher.cc
index 522e95eeb0f3c..6b2568b05f48a 100644
--- a/base/test/launcher/unit_test_launcher.cc
+++ b/base/test/launcher/unit_test_launcher.cc
@@ -117,6 +117,9 @@ void PrintUsage() {
       "  --test-launcher-shard-index=N\n"
       "    Sets the shard index to run to N (from 0 to TOTAL - 1).\n"
       "\n"
+      "  --dont-use-job-objects\n"
+      "    Avoids using job objects in Windows.\n"
+      "\n"
       "  --test-launcher-print-temp-leaks\n"
       "    Prints information about leaked files and/or directories in\n"
       "    child process's temporary directories (Windows and macOS).\n");
@@ -202,6 +205,10 @@ int LaunchUnitTestsInternal(RunTestSuiteCallback run_test_suite,
 #if BUILDFLAG(IS_POSIX)
   FileDescriptorWatcher file_descriptor_watcher(executor.task_runner());
 #endif
+  use_job_objects =
+      use_job_objects &&
+      !CommandLine::ForCurrentProcess()->HasSwitch(kDontUseJobObjectFlag);
+
   DefaultUnitTestPlatformDelegate platform_delegate;
   UnitTestLauncherDelegate delegate(&platform_delegate, batch_limit,
                                     use_job_objects, timeout_callback);
@@ -228,6 +235,9 @@ void InitGoogleTestWChar(int* argc, wchar_t** argv) {
 
 }  // namespace
 
+// Flag to avoid using job objects
+const char kDontUseJobObjectFlag[] = "dont-use-job-objects";
+
 MergeTestFilterSwitchHandler::~MergeTestFilterSwitchHandler() = default;
 void MergeTestFilterSwitchHandler::ResolveDuplicate(
     base::StringPiece key,
diff --git a/base/test/launcher/unit_test_launcher.h b/base/test/launcher/unit_test_launcher.h
index 38f0eaf0b564e..85ee2ec5720d2 100644
--- a/base/test/launcher/unit_test_launcher.h
+++ b/base/test/launcher/unit_test_launcher.h
@@ -19,6 +19,8 @@
 
 namespace base {
 
+extern const char kDontUseJobObjectFlag[];
+
 // Callback that runs a test suite and returns exit code.
 using RunTestSuiteCallback = OnceCallback<int(void)>;
 
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index d9cb025dc755e..13a185ddb989f 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -5,9 +5,9 @@
 #include "base/threading/platform_thread_win.h"
 
 #include <stddef.h>
-
 #include <string>
 
+#include "base/allocator/buildflags.h"
 #include "base/allocator/partition_allocator/partition_alloc_buildflags.h"
 #include "base/debug/activity_tracker.h"
 #include "base/debug/alias.h"
@@ -55,6 +55,14 @@ std::atomic<bool> g_use_thread_priority_lowest{false};
 // UI thread for |kAboveNormalCompositingBrowserWin| Feature.
 std::atomic<bool> g_above_normal_compositing_browser{false};
 
+// The most common value returned by ::GetThreadPriority() after background
+// thread mode is enabled on Windows 7.
+constexpr int kWin7BackgroundThreadModePriority = 4;
+
+// Value sometimes returned by ::GetThreadPriority() after thread priority is
+// set to normal on Windows 7.
+constexpr int kWin7NormalPriority = 3;
+
 // These values are sometimes returned by ::GetThreadPriority().
 constexpr int kWinNormalPriority1 = 5;
 constexpr int kWinNormalPriority2 = 6;
@@ -237,7 +245,10 @@ void AssertMemoryPriority(HANDLE thread, int memory_priority) {
       reinterpret_cast<decltype(&::GetThreadInformation)>(::GetProcAddress(
           ::GetModuleHandle(L"Kernel32.dll"), "GetThreadInformation"));
 
-  DCHECK(get_thread_information_fn);
+  if (!get_thread_information_fn) {
+    DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+    return;
+  }
 
   MEMORY_PRIORITY_INFORMATION memory_priority_information = {};
   DCHECK(get_thread_information_fn(thread, ::ThreadMemoryPriority,
@@ -540,8 +551,14 @@ ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
     return ThreadPriorityForTest::kBackground;
 
   switch (priority) {
+    case kWin7BackgroundThreadModePriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      return ThreadPriorityForTest::kBackground;
     case THREAD_PRIORITY_BELOW_NORMAL:
       return ThreadPriorityForTest::kUtility;
+    case kWin7NormalPriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      [[fallthrough]];
     case THREAD_PRIORITY_NORMAL:
       return ThreadPriorityForTest::kNormal;
     case kWinNormalPriority1:
diff --git a/base/threading/platform_thread_win_unittest.cc b/base/threading/platform_thread_win_unittest.cc
index 3fc3a9efcedd7..43d99815630d1 100644
--- a/base/threading/platform_thread_win_unittest.cc
+++ b/base/threading/platform_thread_win_unittest.cc
@@ -17,8 +17,9 @@ namespace base {
 
 // It has been observed that calling
 // :SetThreadPriority(THREAD_MODE_BACKGROUND_BEGIN) in an IDLE_PRIORITY_CLASS
-// process never affects the return value of ::GetThreadPriority() or
-// the base priority reported in Process Explorer. It does however
+// process doesn't always affect the return value of ::GetThreadPriority() or
+// the base priority reported in Process Explorer (on Win7, the values are
+// sometimes affected while on Win8+ they are never affected). It does however
 // set the memory and I/O priorities to very low. This test confirms that
 // behavior which we suspect is a Windows kernel bug. If this test starts
 // failing, the mitigation for https://crbug.com/901483 in
@@ -49,15 +50,24 @@ TEST(PlatformThreadWinTest, SetBackgroundThreadModeFailsInIdlePriorityProcess) {
   // Begin thread mode background.
   EXPECT_TRUE(::SetThreadPriority(thread_handle, THREAD_MODE_BACKGROUND_BEGIN));
 
-  // On Win10+, GetThreadPriority() stays NORMAL and memory priority becomes
-  // VERY_LOW.
+  // On Win8, GetThreadPriority() stays NORMAL. On Win7, it can stay NORMAL or
+  // switch to one of the various priorities that are observed after entering
+  // thread mode background in a NORMAL_PRIORITY_CLASS process. On all Windows
+  // versions, memory priority becomes VERY_LOW.
   //
   // Note: this documents the aforementioned kernel bug. Ideally this would
   // *not* be the case.
   const int priority_after_thread_mode_background_begin =
       ::GetThreadPriority(thread_handle);
-  EXPECT_EQ(priority_after_thread_mode_background_begin,
-            THREAD_PRIORITY_NORMAL);
+  if (win::GetVersion() == win::Version::WIN7) {
+    const ThreadPriorityForTest priority =
+        PlatformThread::GetCurrentThreadPriorityForTest();
+    EXPECT_TRUE(priority == ThreadPriorityForTest::kNormal ||
+                priority == ThreadPriorityForTest::kBackground);
+  } else {
+    EXPECT_EQ(priority_after_thread_mode_background_begin,
+              THREAD_PRIORITY_NORMAL);
+  }
   internal::AssertMemoryPriority(thread_handle, MEMORY_PRIORITY_VERY_LOW);
 
   PlatformThread::Sleep(base::Seconds(1));
diff --git a/base/win/core_winrt_util_unittest.cc b/base/win/core_winrt_util_unittest.cc
index f4f768dca745e..e920150eaf871 100644
--- a/base/win/core_winrt_util_unittest.cc
+++ b/base/win/core_winrt_util_unittest.cc
@@ -6,12 +6,18 @@
 
 #include "base/win/com_init_util.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 TEST(CoreWinrtUtilTest, PreloadFunctions) {
-  EXPECT_TRUE(ResolveCoreWinRTDelayload());
+  if (GetVersion() < Version::WIN8)
+    EXPECT_FALSE(ResolveCoreWinRTDelayload());
+  else
+    EXPECT_TRUE(ResolveCoreWinRTDelayload());
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/default_apps_util.cc b/base/win/default_apps_util.cc
index 08475da1f40e4..5ce1fdf498cb0 100644
--- a/base/win/default_apps_util.cc
+++ b/base/win/default_apps_util.cc
@@ -31,6 +31,10 @@ std::wstring GetTargetForDefaultAppsSettings(base::WStringPiece protocol) {
 
 namespace base::win {
 
+bool CanLaunchDefaultAppsSettingsModernDialog() {
+  return GetVersion() >= Version::WIN8;
+}
+
 bool LaunchDefaultAppsSettingsModernDialog(base::WStringPiece protocol) {
   // The appModelId looks arbitrary but it is the same in Win8 and Win10. There
   // is no easy way to retrieve the appModelId from the registry.
@@ -38,6 +42,9 @@ bool LaunchDefaultAppsSettingsModernDialog(base::WStringPiece protocol) {
       L"windows.immersivecontrolpanel_cw5n1h2txyewy"
       L"!microsoft.windows.immersivecontrolpanel";
 
+  if (!CanLaunchDefaultAppsSettingsModernDialog())
+    return false;
+
   Microsoft::WRL::ComPtr<IApplicationActivationManager> activator;
   HRESULT hr = ::CoCreateInstance(CLSID_ApplicationActivationManager, nullptr,
                                   CLSCTX_ALL, IID_PPV_ARGS(&activator));
diff --git a/base/win/default_apps_util.h b/base/win/default_apps_util.h
index ed39e0aa919bd..714862fe12a69 100644
--- a/base/win/default_apps_util.h
+++ b/base/win/default_apps_util.h
@@ -10,6 +10,10 @@
 
 namespace base::win {
 
+// Returns true if the OS has a default apps settings dialog. This method
+// returns false on Win7.
+BASE_EXPORT bool CanLaunchDefaultAppsSettingsModernDialog();
+
 // Launches the Windows 'settings' modern app with the 'default apps' view
 // focused. If `protocol` is not empty, it also highlights the `protocol` in
 // the dialog. Returns true if the default apps dialog was successfully opened,
diff --git a/base/win/event_trace_controller_unittest.cc b/base/win/event_trace_controller_unittest.cc
index 57467fc009d05..bb8d73bd97170 100644
--- a/base/win/event_trace_controller_unittest.cc
+++ b/base/win/event_trace_controller_unittest.cc
@@ -19,9 +19,11 @@
 #include "base/win/event_trace_controller.h"
 #include "base/win/event_trace_provider.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 namespace {
 
@@ -222,11 +224,16 @@ TEST_F(EtwTraceControllerTest, DISABLED_EnableDisable) {
 
   EXPECT_HRESULT_SUCCEEDED(controller.Stop(nullptr));
 
-  provider.WaitForCallback();
+  // Windows 7 does not call the callback when Stop() is called so we
+  // can't wait, and enable_level and enable_flags are not zeroed.
+  if (GetVersion() >= Version::WIN8) {
+    provider.WaitForCallback();
 
-  // Session should have wound down.
-  EXPECT_EQ(0, provider.enable_level());
-  EXPECT_EQ(0u, provider.enable_flags());
+    // Session should have wound down.
+    EXPECT_EQ(0, provider.enable_level());
+    EXPECT_EQ(0u, provider.enable_flags());
+  }
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_compare.cc b/base/win/hstring_compare.cc
index c2f21067a7918..8cecac97c4cdc 100644
--- a/base/win/hstring_compare.cc
+++ b/base/win/hstring_compare.cc
@@ -7,13 +7,18 @@
 #include <winstring.h>
 
 #include "base/native_library.h"
+#include "base/win/windows_version.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 HRESULT HStringCompare(HSTRING string1, HSTRING string2, INT32* result) {
   using CompareStringFunc = decltype(&::WindowsCompareStringOrdinal);
 
   static const auto compare_string_func = []() -> CompareStringFunc {
+    if (GetVersion() < Version::WIN8)
+      return nullptr;
+
     NativeLibraryLoadError load_error;
     NativeLibrary combase_module =
         PinSystemLibrary(FILE_PATH_LITERAL("combase.dll"), &load_error);
@@ -31,4 +36,5 @@ HRESULT HStringCompare(HSTRING string1, HSTRING string2, INT32* result) {
   return compare_string_func(string1, string2, result);
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_compare_unittest.cc b/base/win/hstring_compare_unittest.cc
index e9ec3fb5f5074..8aa614c76657f 100644
--- a/base/win/hstring_compare_unittest.cc
+++ b/base/win/hstring_compare_unittest.cc
@@ -5,10 +5,11 @@
 #include "base/win/hstring_compare.h"
 
 #include "base/win/hstring_reference.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace base::win {
-
+namespace base {
+namespace win {
 namespace {
 
 constexpr wchar_t kTestString12[] = L"12";
@@ -17,7 +18,21 @@ constexpr wchar_t kTestString1234[] = L"1234";
 
 }  // namespace
 
+TEST(HStringCompareTest, WorksOnWindows8AndAbove) {
+  INT32 result;
+  HRESULT hr = HStringCompare(nullptr, nullptr, &result);
+  // HStringCompare requires WinRT core functions, which are not available in
+  // older versions.
+  if (GetVersion() < Version::WIN8)
+    EXPECT_HRESULT_FAILED(hr);
+  else
+    EXPECT_HRESULT_SUCCEEDED(hr);
+}
+
 TEST(HStringCompareTest, FirstStringBeforeSecondString) {
+  if (GetVersion() < Version::WIN8)
+    return;
+
   ASSERT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
 
   const HStringReference string12(kTestString12);
@@ -29,6 +44,9 @@ TEST(HStringCompareTest, FirstStringBeforeSecondString) {
 }
 
 TEST(HStringCompareTest, StringsEqual) {
+  if (GetVersion() < Version::WIN8)
+    return;
+
   ASSERT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
 
   const HStringReference string123(kTestString123);
@@ -39,6 +57,9 @@ TEST(HStringCompareTest, StringsEqual) {
 }
 
 TEST(HStringCompareTest, FirstStringAfterSecondString) {
+  if (GetVersion() < Version::WIN8)
+    return;
+
   ASSERT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
 
   const HStringReference string123(kTestString123);
@@ -49,4 +70,5 @@ TEST(HStringCompareTest, FirstStringAfterSecondString) {
   EXPECT_EQ(1, result);
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_reference_unittest.cc b/base/win/hstring_reference_unittest.cc
index 0bbb07e451246..2227261f35dbb 100644
--- a/base/win/hstring_reference_unittest.cc
+++ b/base/win/hstring_reference_unittest.cc
@@ -8,9 +8,11 @@
 
 #include "base/strings/string_piece.h"
 #include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 namespace {
 
@@ -26,6 +28,13 @@ void VerifyHSTRINGEquals(HSTRING hstring, const wchar_t* test_string) {
 }  // namespace
 
 TEST(HStringReferenceTest, Init) {
+  // ScopedHString requires WinRT core functions, which are not available in
+  // older versions.
+  if (GetVersion() < Version::WIN8) {
+    EXPECT_FALSE(HStringReference::ResolveCoreWinRTStringDelayload());
+    return;
+  }
+
   EXPECT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
   EXPECT_TRUE(ScopedHString::ResolveCoreWinRTStringDelayload());
 
@@ -44,4 +53,5 @@ TEST(HStringReferenceTest, Init) {
   VerifyHSTRINGEquals(null_string.Get(), kEmptyString);
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/map_unittest.cc b/base/win/map_unittest.cc
index 86e2b57a5903b..b9e639cf3180e 100644
--- a/base/win/map_unittest.cc
+++ b/base/win/map_unittest.cc
@@ -14,9 +14,13 @@
 #include "base/win/hstring_reference.h"
 #include "base/win/scoped_hstring.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace ABI::Windows::Foundation::Collections {
+namespace ABI {
+namespace Windows {
+namespace Foundation {
+namespace Collections {
 
 // Add missing template specializations (since UWP doesn't provide them):
 
@@ -153,9 +157,13 @@ struct __declspec(uuid("079e2180-0c7a-4508-85ff-7a5f2b29b92b"))
     IObservableVector<IKeyValuePair<HSTRING, IInspectable*>*>
     : IObservableVector_impl<IKeyValuePair<HSTRING, IInspectable*>*> {};
 
-}  // namespace ABI::Windows::Foundation::Collections
+}  // namespace Collections
+}  // namespace Foundation
+}  // namespace Windows
+}  // namespace ABI
 
-namespace base::win {
+namespace base {
+namespace win {
 
 namespace {
 
@@ -501,6 +509,9 @@ TEST(MapTest, First) {
 TEST(MapTest, Properties) {
   // This test case validates Map against Windows property key system,
   // which is used to store WinRT device properties.
+  if (GetVersion() < Version::WIN8)
+    return;
+
   ASSERT_TRUE(ResolveCoreWinRT());
   ScopedWinrtInitializer winrt_initializer;
   ASSERT_TRUE(winrt_initializer.Succeeded());
@@ -541,4 +552,5 @@ TEST(MapTest, Properties) {
   EXPECT_EQ(kTestValue, value_stringref_lookedup.Get());
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/registry.cc b/base/win/registry.cc
index 1ea20faeb7fae..d12b3d1e33f0a 100644
--- a/base/win/registry.cc
+++ b/base/win/registry.cc
@@ -22,8 +22,10 @@
 #include "base/win/object_watcher.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/shlwapi.h"
+#include "base/win/windows_version.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 namespace {
 
@@ -82,8 +84,10 @@ bool RegKey::Watcher::StartWatching(HKEY key, ChangeCallback callback) {
     return false;
 
   DWORD filter = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
-                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY |
-                 REG_NOTIFY_THREAD_AGNOSTIC;
+                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY;
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    filter |= REG_NOTIFY_THREAD_AGNOSTIC;
+
   // Watch the registry key for a change of value.
   LONG result =
       RegNotifyChangeKeyValue(key, /*bWatchSubtree=*/TRUE, filter,
@@ -697,4 +701,5 @@ void RegistryKeyIterator::Initialize(HKEY root_key,
   Read();
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/registry_unittest.cc b/base/win/registry_unittest.cc
index 407d8b82be827..27d50daf478ac 100644
--- a/base/win/registry_unittest.cc
+++ b/base/win/registry_unittest.cc
@@ -28,7 +28,8 @@
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 namespace {
 
@@ -346,6 +347,11 @@ class RegistryWatcherThread : public SimpleThread {
 }  // namespace
 
 TEST_F(RegistryTest, WatcherNotSignaledOnInitiatingThreadExit) {
+  if (base::win::GetVersion() < base::win::Version::WIN8) {
+    // REG_NOTIFY_THREAD_AGNOSTIC is supported on Win8+.
+    return;
+  }
+
   RegKey key;
 
   ASSERT_EQ(key.Open(HKEY_CURRENT_USER, root_key().c_str(), KEY_READ),
@@ -389,6 +395,44 @@ TEST_F(RegistryTest, WatcherNotSignaledOnInitiatingThreadExit) {
   run_loop.Run();
 }
 
+TEST_F(RegistryTest, WatcherSignaledOnInitiatingThreadExitOnWin7) {
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    // REG_NOTIFY_THREAD_AGNOSTIC is used on Win8+; this test
+    // validates the behavior on Win7 where that is not available.
+    return;
+  }
+
+  RegKey key;
+
+  ASSERT_EQ(key.Open(HKEY_CURRENT_USER, root_key().c_str(), KEY_READ),
+            ERROR_SUCCESS);
+
+  auto test_task_runner = base::MakeRefCounted<base::TestMockTimeTaskRunner>(
+      base::TestMockTimeTaskRunner::Type::kBoundToThread);
+  ::testing::StrictMock<base::MockCallback<base::win::RegKey::ChangeCallback>>
+      change_cb;
+
+  test_task_runner->PostTask(FROM_HERE,
+                             BindOnce(IgnoreResult(&RegKey::StartWatching),
+                                      Unretained(&key), change_cb.Get()));
+
+  // Expect that a notification is sent when the thread exits. Exit the run loop
+  // when this happens.
+  base::RunLoop run_loop;
+  EXPECT_CALL(change_cb, Run).WillOnce([&run_loop]() { run_loop.Quit(); });
+
+  {
+    // Start the watch on a thread that then goes away.
+    RegistryWatcherThread watcher_thread(test_task_runner);
+    watcher_thread.Start();
+    watcher_thread.Join();
+  }
+  test_task_runner->DetachFromThread();
+
+  // Wait for the watcher to be signaled.
+  run_loop.Run();
+}
+
 TEST_F(RegistryTest, TestMoveConstruct) {
   RegKey key;
 
@@ -545,4 +589,5 @@ TEST_F(RegistryTestHKLM, DISABLED_Wow64NativeFromRedirected) {
 
 }  // namespace
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/scoped_handle_unittest.cc b/base/win/scoped_handle_unittest.cc
index d6f74e06e31e1..10368896bb59d 100644
--- a/base/win/scoped_handle_unittest.cc
+++ b/base/win/scoped_handle_unittest.cc
@@ -16,6 +16,7 @@
 #include "base/test/multiprocess_test.h"
 #include "base/test/test_timeouts.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "testing/multiprocess_func_list.h"
@@ -35,6 +36,18 @@ std::string FailureMessage(const std::string& msg) {
 #endif  // defined(NDEBUG) && defined(OFFICIAL_BUILD)
 }
 
+// Death tests don't seem to work on Windows 7 32-bit native with hooks enabled.
+bool DoDeathTestsWork() {
+#if defined(ARCH_CPU_32_BITS)
+    const auto* os_info = base::win::OSInfo::GetInstance();
+    if (os_info->version() <= base::win::Version::WIN7 &&
+        os_info->IsWowDisabled()) {
+      return false;
+    }
+#endif  // defined(ARCH_CPU_32_BITS)
+    return true;
+}
+
 }  // namespace
 
 namespace testing {
@@ -70,6 +83,9 @@ TEST_F(ScopedHandleTest, ScopedHandle) {
 }
 
 TEST_F(ScopedHandleDeathTest, HandleVerifierTrackedHasBeenClosed) {
+  // This test is only valid if hooks are enabled.
+  if (!DoDeathTestsWork())
+    return;
   HANDLE handle = ::CreateMutex(nullptr, false, nullptr);
   ASSERT_NE(HANDLE(nullptr), handle);
   using NtCloseFunc = decltype(&::NtClose);
@@ -88,6 +104,10 @@ TEST_F(ScopedHandleDeathTest, HandleVerifierTrackedHasBeenClosed) {
 }
 
 TEST_F(ScopedHandleDeathTest, HandleVerifierCloseTrackedHandle) {
+  // This test is only valid if hooks are enabled.
+  if (!DoDeathTestsWork())
+    return;
+
   ASSERT_DEATH(
       {
         HANDLE handle = ::CreateMutex(nullptr, false, nullptr);
@@ -110,6 +130,9 @@ TEST_F(ScopedHandleDeathTest, HandleVerifierCloseTrackedHandle) {
 }
 
 TEST_F(ScopedHandleDeathTest, HandleVerifierDoubleTracking) {
+  if (!DoDeathTestsWork())
+    return;
+
   HANDLE handle = ::CreateMutex(nullptr, false, nullptr);
   ASSERT_NE(HANDLE(nullptr), handle);
 
@@ -120,6 +143,9 @@ TEST_F(ScopedHandleDeathTest, HandleVerifierDoubleTracking) {
 }
 
 TEST_F(ScopedHandleDeathTest, HandleVerifierWrongOwner) {
+  if (!DoDeathTestsWork())
+    return;
+
   HANDLE handle = ::CreateMutex(nullptr, false, nullptr);
   ASSERT_NE(HANDLE(nullptr), handle);
 
@@ -135,6 +161,9 @@ TEST_F(ScopedHandleDeathTest, HandleVerifierWrongOwner) {
 }
 
 TEST_F(ScopedHandleDeathTest, HandleVerifierUntrackedHandle) {
+  if (!DoDeathTestsWork())
+    return;
+
   HANDLE handle = ::CreateMutex(nullptr, false, nullptr);
   ASSERT_NE(HANDLE(nullptr), handle);
 
diff --git a/base/win/scoped_hstring_unittest.cc b/base/win/scoped_hstring_unittest.cc
index 412d4fe1a6b03..d60da2052417c 100644
--- a/base/win/scoped_hstring_unittest.cc
+++ b/base/win/scoped_hstring_unittest.cc
@@ -10,9 +10,11 @@
 
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 namespace {
 
@@ -22,6 +24,13 @@ constexpr wchar_t kTestString2[] = L"456789";
 }  // namespace
 
 TEST(ScopedHStringTest, Init) {
+  // ScopedHString requires WinRT core functions, which are not available in
+  // older versions.
+  if (GetVersion() < Version::WIN8) {
+    EXPECT_FALSE(ScopedHString::ResolveCoreWinRTStringDelayload());
+    return;
+  }
+
   EXPECT_TRUE(ScopedHString::ResolveCoreWinRTStringDelayload());
 
   ScopedHString hstring = ScopedHString::Create(kTestString1);
@@ -42,4 +51,5 @@ TEST(ScopedHStringTest, Init) {
   EXPECT_EQ(kTestString2, contents);
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/scoped_process_information_unittest.cc b/base/win/scoped_process_information_unittest.cc
index a1ef141bed5b7..a9add0b7044bf 100644
--- a/base/win/scoped_process_information_unittest.cc
+++ b/base/win/scoped_process_information_unittest.cc
@@ -13,6 +13,7 @@
 #include "base/process/process.h"
 #include "base/strings/string_util.h"
 #include "base/test/multiprocess_test.h"
+#include "base/win/windows_version.h"
 #include "testing/multiprocess_func_list.h"
 
 namespace {
@@ -124,6 +125,10 @@ TEST_F(ScopedProcessInformationTest, TakeWholeStruct) {
 }
 
 TEST_F(ScopedProcessInformationTest, Duplicate) {
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    // Disabled on Windows 7 due to flakiness. https://crbug.com/1336879
+    GTEST_SKIP();
+  }
   PROCESS_INFORMATION temp_process_information;
   DoCreateProcess("ReturnSeven", &temp_process_information);
   base::win::ScopedProcessInformation process_info;
diff --git a/base/win/scoped_winrt_initializer.cc b/base/win/scoped_winrt_initializer.cc
index 85f83dab8192b..c062328cc00c6 100644
--- a/base/win/scoped_winrt_initializer.cc
+++ b/base/win/scoped_winrt_initializer.cc
@@ -13,8 +13,10 @@
 #include "base/threading/scoped_thread_priority.h"
 #include "base/win/com_init_util.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 namespace {
 
@@ -61,6 +63,7 @@ void CallRoUninitialize() {
 ScopedWinrtInitializer::ScopedWinrtInitializer()
     : hr_(CallRoInitialize(RO_INIT_MULTITHREADED)) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  DCHECK_GE(GetVersion(), Version::WIN8);
 #if DCHECK_IS_ON()
   if (SUCCEEDED(hr_))
     AssertComApartmentType(ComApartmentType::MTA);
@@ -79,4 +82,5 @@ bool ScopedWinrtInitializer::Succeeded() const {
   return SUCCEEDED(hr_);
 }
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/scoped_winrt_initializer_unittest.cc b/base/win/scoped_winrt_initializer_unittest.cc
index fc6c4998591ad..d8f021d52ef3e 100644
--- a/base/win/scoped_winrt_initializer_unittest.cc
+++ b/base/win/scoped_winrt_initializer_unittest.cc
@@ -7,11 +7,16 @@
 #include "base/test/gtest_util.h"
 #include "base/win/com_init_util.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 TEST(ScopedWinrtInitializer, BasicFunctionality) {
+  if (GetVersion() < Version::WIN8)
+    return;
+
   AssertComApartmentType(ComApartmentType::NONE);
   {
     ScopedWinrtInitializer scoped_winrt_initializer;
@@ -21,10 +26,22 @@ TEST(ScopedWinrtInitializer, BasicFunctionality) {
 }
 
 TEST(ScopedWinrtInitializer, ApartmentChangeCheck) {
+  if (GetVersion() < Version::WIN8)
+    return;
+
   ScopedCOMInitializer com_initializer;
   // ScopedCOMInitializer initialized an STA and the following should be a
   // failed request for an MTA.
   EXPECT_DCHECK_DEATH({ ScopedWinrtInitializer scoped_winrt_initializer; });
 }
 
-}  // namespace base::win
+TEST(ScopedWinrtInitializer, VersionCheck) {
+  if (GetVersion() >= Version::WIN8)
+    return;
+
+  // ScopedWinrtInitializer is unsupported on versions prior to Windows 8.
+  EXPECT_DCHECK_DEATH({ ScopedWinrtInitializer scoped_winrt_initializer; });
+}
+
+}  // namespace win
+}  // namespace base
diff --git a/base/win/shortcut_unittest.cc b/base/win/shortcut_unittest.cc
index 258dfadbb2f8c..8025079a51531 100644
--- a/base/win/shortcut_unittest.cc
+++ b/base/win/shortcut_unittest.cc
@@ -14,6 +14,7 @@
 #include "base/test/test_file_util.h"
 #include "base/test/test_shortcut_win.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -93,6 +94,11 @@ class ShortcutTest : public testing::Test {
 }  // namespace
 
 TEST_F(ShortcutTest, CreateAndResolveShortcutProperties) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   // Test all properties.
   FilePath file_1(temp_dir_.GetPath().Append(FILE_PATH_LITERAL("Link1.lnk")));
   ASSERT_TRUE(CreateOrUpdateShortcutLink(file_1, link_properties_,
@@ -140,6 +146,10 @@ TEST_F(ShortcutTest, CreateAndResolveShortcutProperties) {
 }
 
 TEST_F(ShortcutTest, CreateAndResolveShortcut) {
+  // TODO(crbug.com/1264563): Disabled on Win7 bots for being flaky.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ShortcutProperties only_target_properties;
   only_target_properties.set_target(link_properties_.target);
 
@@ -155,6 +165,10 @@ TEST_F(ShortcutTest, CreateAndResolveShortcut) {
 }
 
 TEST_F(ShortcutTest, ResolveShortcutWithArgs) {
+  // TODO(crbug.com/1264563): Disabled on Win7 bots for being flaky.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -169,6 +183,10 @@ TEST_F(ShortcutTest, ResolveShortcutWithArgs) {
 }
 
 TEST_F(ShortcutTest, CreateShortcutWithOnlySomeProperties) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1291225): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
   ShortcutProperties target_and_args_properties;
   target_and_args_properties.set_target(link_properties_.target);
   target_and_args_properties.set_arguments(link_properties_.arguments);
@@ -180,6 +198,9 @@ TEST_F(ShortcutTest, CreateShortcutWithOnlySomeProperties) {
 }
 
 TEST_F(ShortcutTest, CreateShortcutVerifyProperties) {
+  // TODO(crbug.com/1264563) Flaky on Win 7.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -187,6 +208,9 @@ TEST_F(ShortcutTest, CreateShortcutVerifyProperties) {
 }
 
 TEST_F(ShortcutTest, UpdateShortcutVerifyPropertiess) {
+  // TODO(crbug.com/1264563) Flaky on Win 7.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -197,6 +221,11 @@ TEST_F(ShortcutTest, UpdateShortcutVerifyPropertiess) {
 }
 
 TEST_F(ShortcutTest, UpdateShortcutUpdateOnlyTargetAndResolve) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -220,6 +249,11 @@ TEST_F(ShortcutTest, UpdateShortcutUpdateOnlyTargetAndResolve) {
 }
 
 TEST_F(ShortcutTest, UpdateShortcutMakeDualMode) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -235,6 +269,11 @@ TEST_F(ShortcutTest, UpdateShortcutMakeDualMode) {
 }
 
 TEST_F(ShortcutTest, UpdateShortcutRemoveDualMode) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_2_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -251,6 +290,11 @@ TEST_F(ShortcutTest, UpdateShortcutRemoveDualMode) {
 }
 
 TEST_F(ShortcutTest, UpdateShortcutClearArguments) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -272,6 +316,11 @@ TEST_F(ShortcutTest, FailUpdateShortcutThatDoesNotExist) {
 }
 
 TEST_F(ShortcutTest, ReplaceShortcutAllProperties) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -282,6 +331,11 @@ TEST_F(ShortcutTest, ReplaceShortcutAllProperties) {
 }
 
 TEST_F(ShortcutTest, ReplaceShortcutSomeProperties) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
@@ -311,6 +365,11 @@ TEST_F(ShortcutTest, FailReplaceShortcutThatDoesNotExist) {
 // Test that the old arguments remain on the replaced shortcut when not
 // otherwise specified.
 TEST_F(ShortcutTest, ReplaceShortcutKeepOldArguments) {
+  // This test is extremely flaky on Win7, so disable.
+  // TODO(crbug.com/1264563): Investigate why it's so flaky on Win7 bots.
+  if (base::win::OSInfo::GetInstance()->version() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for win7";
+
   ASSERT_TRUE(CreateOrUpdateShortcutLink(link_file_, link_properties_,
                                          ShortcutOperation::kCreateAlways));
 
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 13d8a980ea11b..b1b2f55484d7f 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -101,9 +101,11 @@ POWER_PLATFORM_ROLE GetPlatformRole() {
   return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
 }
 
-// Because we used to support versions earlier than 8.1, we dynamically load
-// this function from user32.dll, so it won't fail to load in runtime.
-// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+// Method used for Windows 8.1 and later.
+// Since we support versions earlier than 8.1, we must dynamically load this
+// function from user32.dll, so it won't fail to load in runtime. For earlier
+// Windows versions GetProcAddress will return null and report failure so that
+// callers can fall back on the deprecated SetProcessDPIAware.
 bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
   if (!IsUser32AndGdi32Available())
     return false;
@@ -124,8 +126,9 @@ bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
     return false;
   }
 
-  NOTREACHED() << "SetProcessDpiAwarenessInternal "
-                  "should be available on all platforms >= Windows 8.1";
+  DCHECK_LT(GetVersion(), Version::WIN8_1) << "SetProcessDpiAwarenessInternal "
+                                              "should be available on all "
+                                              "platforms >= Windows 8.1";
   return false;
 }
 
@@ -299,6 +302,13 @@ bool IsWindows10OrGreaterTabletMode(HWND hwnd) {
 bool IsKeyboardPresentOnSlate(HWND hwnd, std::string* reason) {
   bool result = false;
 
+  if (GetVersion() < Version::WIN8) {
+    if (reason)
+      *reason = "Detection not supported";
+    return false;
+  }
+
+  // This function is only supported for Windows 8 and up.
   if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kDisableUsbKeyboardDetect)) {
     if (reason)
@@ -544,6 +554,12 @@ void SetAbortBehaviorForCrashReporting() {
 }
 
 bool IsTabletDevice(std::string* reason, HWND hwnd) {
+  if (GetVersion() < Version::WIN8) {
+    if (reason)
+      *reason = "Tablet device detection not supported below Windows 8\n";
+    return false;
+  }
+
   if (IsWindows10OrGreaterTabletMode(hwnd))
     return true;
 
@@ -561,6 +577,12 @@ bool IsDeviceUsedAsATablet(std::string* reason) {
   // reason is NULL.
   absl::optional<bool> ret;
 
+  if (GetVersion() < Version::WIN8) {
+    if (reason)
+      *reason = "Tablet device detection not supported below Windows 8\n";
+    return false;
+  }
+
   if (GetSystemMetrics(SM_MAXIMUMTOUCHES) == 0) {
     if (reason) {
       *reason += "Device does not support touch.\n";
@@ -640,6 +662,10 @@ bool IsUser32AndGdi32Available() {
   static auto is_user32_and_gdi32_available = []() {
     // If win32k syscalls aren't disabled, then user32 and gdi32 are available.
 
+    // Can't disable win32k prior to windows 8.
+    if (GetVersion() < Version::WIN8)
+      return true;
+
     using GetProcessMitigationPolicyType =
         decltype(GetProcessMitigationPolicy)*;
     GetProcessMitigationPolicyType get_process_mitigation_policy_func =
@@ -748,11 +774,15 @@ void EnableHighDPISupport() {
   if (EnablePerMonitorV2())
     return;
 
-  // Fall back to per-monitor DPI for older versions of Win10.
-  PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
+  // Fall back to per-monitor DPI for older versions of Win10 instead of
+  // Win8.1 since Win8.1 does not have EnableChildWindowDpiMessage,
+  // necessary for correct non-client area scaling across monitors.
+  PROCESS_DPI_AWARENESS process_dpi_awareness =
+      GetVersion() >= Version::WIN10 ? PROCESS_PER_MONITOR_DPI_AWARE
+                                     : PROCESS_SYSTEM_DPI_AWARE;
   if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
-    // For windows versions where SetProcessDpiAwareness fails, try its
-    // predecessor.
+    // For windows versions where SetProcessDpiAwareness is not available or
+    // failed, try its predecessor.
     BOOL result = ::SetProcessDPIAware();
     DCHECK(result) << "SetProcessDPIAware failed.";
   }
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index 057c0d9ebc37d..79ae1a2e5983a 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -307,6 +307,7 @@
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_ASH)
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "chrome/browser/enterprise/platform_auth/platform_auth_features.h"
 #include "chrome/browser/win/titlebar_config.h"
 #endif
@@ -9526,6 +9527,14 @@ bool ShouldSkipConditionalFeatureEntry(const flags_ui::FlagsStorage* storage,
     return true;
   }
 
+#if BUILDFLAG(IS_WIN)
+  // HDR mode works, but displays everything horribly wrong prior to windows 10.
+  if (!strcmp("enable-hdr", entry.internal_name) &&
+      base::win::GetVersion() < base::win::Version::WIN10) {
+    return true;
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
 #if !BUILDFLAG(IS_ANDROID)
   // Only show the AccessCodeCast tab switching flag if the AccessCodeCast Ui is
   // displayed.
diff --git a/chrome/browser/accessibility/caption_settings_dialog_win.cc b/chrome/browser/accessibility/caption_settings_dialog_win.cc
index 3807d7ccece91..2fb5a4cdb2e86 100644
--- a/chrome/browser/accessibility/caption_settings_dialog_win.cc
+++ b/chrome/browser/accessibility/caption_settings_dialog_win.cc
@@ -9,13 +9,16 @@
 
 #include "base/functional/bind.h"
 #include "base/task/thread_pool.h"
+#include "base/win/windows_version.h"
 
 namespace {
 
 // A helper callback that opens the caption settings dialog.
 void CaptionSettingsDialogCallback() {
-  ShellExecute(nullptr, L"open", L"ms-settings:easeofaccess-closedcaptioning",
-               nullptr, nullptr, SW_SHOWNORMAL);
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    ShellExecute(NULL, L"open", L"ms-settings:easeofaccess-closedcaptioning",
+                 NULL, NULL, SW_SHOWNORMAL);
+  }
 }
 
 }  // namespace
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 6170a5656eb83..1f7176459dd49 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -4293,6 +4293,13 @@ std::string ChromeContentBrowserClient::GetDefaultDownloadName() {
   return l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME);
 }
 
+base::FilePath ChromeContentBrowserClient::GetFontLookupTableCacheDir() {
+  base::FilePath user_data_dir;
+  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+  DCHECK(!user_data_dir.empty());
+  return user_data_dir.Append(FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
   base::FilePath user_data_dir;
   base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index 071a3dd11e61b..662251e974aeb 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -397,6 +397,7 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void BrowserURLHandlerCreated(content::BrowserURLHandler* handler) override;
   base::FilePath GetDefaultDownloadDirectory() override;
   std::string GetDefaultDownloadName() override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   base::FilePath GetShaderDiskCacheDirectory() override;
   base::FilePath GetGrShaderDiskCacheDirectory() override;
   base::FilePath GetNetLogDefaultDirectory() override;
diff --git a/chrome/browser/device_reauth/win/authenticator_win.cc b/chrome/browser/device_reauth/win/authenticator_win.cc
index ea95a014f9a25..c56cb1eb92317 100644
--- a/chrome/browser/device_reauth/win/authenticator_win.cc
+++ b/chrome/browser/device_reauth/win/authenticator_win.cc
@@ -21,6 +21,7 @@
 #include "base/win/registry.h"
 #include "base/win/scoped_hstring.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/password_manager/password_manager_util_win.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -94,6 +95,11 @@ void ReportCantCheckAvailability(
 void GetBiometricAvailabilityFromWindows(
     AvailabilityCallback callback,
     scoped_refptr<base::SequencedTaskRunner> thread) {
+  // UserConsentVerifier class is only available in Win 10 onwards.
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    ReportCantCheckAvailability(thread, std::move(callback));
+    return;
+  }
   if (!ResolveCoreWinRT()) {
     ReportCantCheckAvailability(thread, std::move(callback));
     return;
diff --git a/chrome/browser/extensions/api/language_settings_private/language_settings_private_api_unittest.cc b/chrome/browser/extensions/api/language_settings_private/language_settings_private_api_unittest.cc
index 87944ed0b4a51..fb1cf26df3682 100644
--- a/chrome/browser/extensions/api/language_settings_private/language_settings_private_api_unittest.cc
+++ b/chrome/browser/extensions/api/language_settings_private/language_settings_private_api_unittest.cc
@@ -348,8 +348,13 @@ void LanguageSettingsPrivateApiTest::RunGetLanguageListTest() {
   // only reports spellchecking is supported for these languages if the language
   // pack is installed.
 #if BUILDFLAG(IS_WIN)
-  languages_to_test.push_back({"ar", "ar-SA", true, true});
-  languages_to_test.push_back({"bn", "bn-IN", false, true});
+  if (spellcheck::WindowsVersionSupportsSpellchecker()) {
+    languages_to_test.push_back({"ar", "ar-SA", true, true});
+    languages_to_test.push_back({"bn", "bn-IN", false, true});
+  } else {
+    languages_to_test.push_back({"ar", "ar-SA", true, false});
+    languages_to_test.push_back({"bn", "bn-IN", false, false});
+  }
 #else
   languages_to_test.push_back({"ar", "ar-SA", true, false});
   languages_to_test.push_back({"bn", "bn-IN", false, false});
diff --git a/chrome/browser/external_protocol/external_protocol_handler_browsertest.cc b/chrome/browser/external_protocol/external_protocol_handler_browsertest.cc
index 9d571fefc8d06..5646a00632797 100644
--- a/chrome/browser/external_protocol/external_protocol_handler_browsertest.cc
+++ b/chrome/browser/external_protocol/external_protocol_handler_browsertest.cc
@@ -21,6 +21,10 @@
 #include "content/public/test/navigation_handle_observer.h"
 #include "content/public/test/test_navigation_observer.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 class ExternalProtocolHandlerBrowserTest : public InProcessBrowserTest {
  public:
   content::WebContents* web_content() {
@@ -155,6 +159,14 @@ class TabAddedRemovedObserver : public TabStripModelObserver {
 #endif
 IN_PROC_BROWSER_TEST_F(ExternalProtocolHandlerBrowserTest,
                        MAYBE_AutoCloseTabOnNonWebProtocolNavigation) {
+#if BUILDFLAG(IS_WIN)
+  // On Win 7 the protocol is registered to be handled by Chrome and thus never
+  // reaches the ExternalProtocolHandler so we skip the test. For
+  // more info see installer/util/shell_util.cc:GetShellIntegrationEntries
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+#endif
+
   TabAddedRemovedObserver observer(browser()->tab_strip_model());
   ASSERT_EQ(browser()->tab_strip_model()->count(), 1);
   ASSERT_TRUE(
@@ -172,6 +184,14 @@ IN_PROC_BROWSER_TEST_F(ExternalProtocolHandlerBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(ExternalProtocolHandlerBrowserTest,
                        MAYBE_ProtocolLaunchEmitsConsoleLog) {
+#if BUILDFLAG(IS_WIN)
+  // On Win 7 the protocol is registered to be handled by Chrome and thus never
+  // reaches the ExternalProtocolHandler so we skip the test. For
+  // more info see installer/util/shell_util.cc:GetShellIntegrationEntries
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+#endif
+
   content::WebContentsConsoleObserver observer(web_content());
   // Wait for either "Launched external handler..." or "Failed to launch..."; the former will pass
   // the test, while the latter will fail it more quickly than waiting for a timeout.
diff --git a/chrome/browser/icon_loader_browsertest.cc b/chrome/browser/icon_loader_browsertest.cc
index 4e09d38e417e5..052248024e25b 100644
--- a/chrome/browser/icon_loader_browsertest.cc
+++ b/chrome/browser/icon_loader_browsertest.cc
@@ -13,6 +13,7 @@
 #include "ui/gfx/image/image.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "ui/display/win/dpi.h"
 #endif
 
@@ -70,6 +71,11 @@ IN_PROC_BROWSER_TEST_F(IconLoaderBrowserTest, LoadGroup) {
 
 #if BUILDFLAG(IS_WIN)
   scale = display::win::GetDPIScale();
+
+  // This test times out on Win7. Return early to avoid disabling test on
+  // all of Windows.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
 #endif
 
   // Test that an icon for a file type (group) can be loaded even
diff --git a/chrome/browser/importer/edge_importer_browsertest_win.cc b/chrome/browser/importer/edge_importer_browsertest_win.cc
index b012756919986..ac9e6ec3f48ec 100644
--- a/chrome/browser/importer/edge_importer_browsertest_win.cc
+++ b/chrome/browser/importer/edge_importer_browsertest_win.cc
@@ -159,6 +159,10 @@ class EdgeImporterBrowserTest : public InProcessBrowserTest {
 };
 
 IN_PROC_BROWSER_TEST_F(EdgeImporterBrowserTest, EdgeImporter) {
+  // Only verified to work with ESE library on Windows 8.1 and above.
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return;
+
   const BookmarkInfo kEdgeBookmarks[] = {
       {true,
        2,
@@ -278,6 +282,10 @@ IN_PROC_BROWSER_TEST_F(EdgeImporterBrowserTest, EdgeImporterLegacyFallback) {
 }
 
 IN_PROC_BROWSER_TEST_F(EdgeImporterBrowserTest, EdgeImporterNoDatabase) {
+  // Only verified to work with ESE library on Windows 8.1 and above.
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return;
+
   std::vector<BookmarkInfo> bookmark_entries;
   std::vector<FaviconGroup> favicon_groups;
 
diff --git a/chrome/browser/media/webrtc/webrtc_browsertest_base.cc b/chrome/browser/media/webrtc/webrtc_browsertest_base.cc
index fbc2acb5e8ce8..4381681a5e820 100644
--- a/chrome/browser/media/webrtc/webrtc_browsertest_base.cc
+++ b/chrome/browser/media/webrtc/webrtc_browsertest_base.cc
@@ -33,6 +33,11 @@
 #include "extensions/browser/extension_registry.h"
 #include "net/test/embedded_test_server/embedded_test_server.h"
 
+#if BUILDFLAG(IS_WIN)
+// For fine-grained suppression.
+#include "base/win/windows_version.h"
+#endif
+
 const char WebRtcTestBase::kAudioVideoCallConstraints[] =
     "{audio: true, video: true}";
 const char WebRtcTestBase::kVideoCallConstraintsQVGA[] =
@@ -522,6 +527,14 @@ std::string WebRtcTestBase::GetStreamSize(
   return result.substr(3);
 }
 
+bool WebRtcTestBase::OnWin8OrHigher() const {
+#if BUILDFLAG(IS_WIN)
+  return base::win::GetVersion() >= base::win::Version::WIN8;
+#else
+  return false;
+#endif
+}
+
 void WebRtcTestBase::OpenDatabase(content::WebContents* tab) const {
   EXPECT_EQ("ok-database-opened", ExecuteJavascript("openDatabase()", tab));
 }
diff --git a/chrome/browser/media/webrtc/webrtc_browsertest_base.h b/chrome/browser/media/webrtc/webrtc_browsertest_base.h
index 114eebd9160a9..f28d9a63fb3c9 100644
--- a/chrome/browser/media/webrtc/webrtc_browsertest_base.h
+++ b/chrome/browser/media/webrtc/webrtc_browsertest_base.h
@@ -209,6 +209,9 @@ class WebRtcTestBase : public InProcessBrowserTest {
   std::string GetStreamSize(content::WebContents* tab_contents,
                             const std::string& video_element) const;
 
+  // Returns true if we're on Windows 8 or higher.
+  bool OnWin8OrHigher() const;
+
   void OpenDatabase(content::WebContents* tab) const;
   void CloseDatabase(content::WebContents* tab) const;
   void DeleteDatabase(content::WebContents* tab) const;
diff --git a/chrome/browser/metrics/antivirus_metrics_provider_win_unittest.cc b/chrome/browser/metrics/antivirus_metrics_provider_win_unittest.cc
index 1309d0c41b69e..c238c0cf611f8 100644
--- a/chrome/browser/metrics/antivirus_metrics_provider_win_unittest.cc
+++ b/chrome/browser/metrics/antivirus_metrics_provider_win_unittest.cc
@@ -4,7 +4,6 @@
 
 #include "chrome/browser/metrics/antivirus_metrics_provider_win.h"
 
-#include <utility>
 #include <vector>
 
 #include "base/functional/bind.h"
@@ -15,6 +14,7 @@
 #include "base/threading/thread_checker.h"
 #include "base/threading/thread_restrictions.h"
 #include "base/version.h"
+#include "base/win/windows_version.h"
 #include "chrome/services/util_win/util_win_impl.h"
 #include "components/variations/hashing.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -25,36 +25,41 @@ namespace {
 void VerifySystemProfileData(const metrics::SystemProfileProto& system_profile,
                              bool expect_unhashed_value,
                              bool second_run) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   // The name of Windows Defender changed sometime in Windows 10, so any of the
   // following is possible.
   constexpr char kWindowsDefender[] = "Windows Defender";
   constexpr char kWindowsDefenderAntivirus[] = "Windows Defender Antivirus";
 
-  bool defender_found = false;
-  uint32_t last_hash = 0xdeadbeef;
-  for (const auto& av : system_profile.antivirus_product()) {
-    if (av.has_product_name_hash()) {
-      last_hash = av.product_name_hash();
-    }
-    if (av.product_name_hash() == variations::HashName(kWindowsDefender) ||
-        av.product_name_hash() ==
-            variations::HashName(kWindowsDefenderAntivirus)) {
-      defender_found = true;
-      if (expect_unhashed_value) {
-        EXPECT_TRUE(av.has_product_name());
-        EXPECT_TRUE(av.product_name() == kWindowsDefender ||
-                    av.product_name() == kWindowsDefenderAntivirus);
-      } else {
-        EXPECT_FALSE(av.has_product_name());
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    bool defender_found = false;
+    uint32_t last_hash = 0xdeadbeef;
+    for (const auto& av : system_profile.antivirus_product()) {
+      if (av.has_product_name_hash())
+        last_hash = av.product_name_hash();
+      if (av.product_name_hash() ==
+          variations::HashName(kWindowsDefender) ||
+          av.product_name_hash() ==
+          variations::HashName(kWindowsDefenderAntivirus)) {
+        defender_found = true;
+        if (expect_unhashed_value) {
+          EXPECT_TRUE(av.has_product_name());
+          EXPECT_TRUE(av.product_name() == kWindowsDefender ||
+                      av.product_name() == kWindowsDefenderAntivirus);
+        } else {
+          EXPECT_FALSE(av.has_product_name());
+        }
+        break;
       }
-      break;
     }
+    EXPECT_TRUE(defender_found)
+        << "expect_unhashed_value = " << expect_unhashed_value
+        << ", second_run = " << second_run << ", "
+        << system_profile.antivirus_product().size()
+        << " antivirus products found. Last hash is " << last_hash << ".";
   }
-  EXPECT_TRUE(defender_found)
-      << "expect_unhashed_value = " << expect_unhashed_value
-      << ", second_run = " << second_run << ", "
-      << system_profile.antivirus_product().size()
-      << " antivirus products found. Last hash is " << last_hash << ".";
 }
 
 }  // namespace
diff --git a/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc b/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
index a8597e7f4a9e8..a80b790d72fa0 100644
--- a/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
+++ b/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
@@ -425,6 +425,9 @@ void RecordIsPinnedToTaskbarHistogram() {
 // here:
 // https://blogs.blackberry.com/en/2017/10/windows-10-parallel-loading-breakdown.
 bool IsParallelDllLoadingEnabled() {
+  // Parallel DLL loading is only available on Windows 10 and above.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return false;
   base::FilePath exe_path;
   if (!base::PathService::Get(base::FILE_EXE, &exe_path))
     return false;
diff --git a/chrome/browser/net/stub_resolver_config_reader.cc b/chrome/browser/net/stub_resolver_config_reader.cc
index 14db5800fac2a..a6ef278093049 100644
--- a/chrome/browser/net/stub_resolver_config_reader.cc
+++ b/chrome/browser/net/stub_resolver_config_reader.cc
@@ -50,6 +50,7 @@
 #if BUILDFLAG(IS_WIN)
 #include "base/enterprise_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/win/parental_controls.h"
 #endif
 
@@ -82,7 +83,18 @@ enum class SecureDnsModeDetailsForHistogram {
 
 #if BUILDFLAG(IS_WIN)
 bool ShouldDisableDohForWindowsParentalControls() {
-  return GetWinParentalControls().web_filter;
+  const WinParentalControls& parental_controls = GetWinParentalControls();
+  if (parental_controls.web_filter)
+    return true;
+
+  // Some versions before Windows 8 may not fully support |web_filter|, so
+  // conservatively disable doh for any recognized parental controls.
+  if (parental_controls.any_restrictions &&
+    base::win::GetVersion() < base::win::Version::WIN8) {
+    return true;
+  }
+
+  return false;
 }
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -234,7 +246,7 @@ bool StubResolverConfigReader::ShouldDisableDohForManaged() {
 #elif BUILDFLAG(IS_WIN)
   // TODO(crbug.com/1339062): What is the correct function to use here? (This
   // may or may not obsolete the following TODO)
-  // TODO(crbug.com/1320766): For legacy compatibility, this uses
+  // TODO (crbug.com/1320766): For legacy compatibility, this uses
   // IsEnterpriseDevice() which effectively equates to a domain join check.
   // Consider whether this should use IsManagedDevice() instead.
   if (base::win::IsEnrolledToDomain())
diff --git a/chrome/browser/notifications/notification_platform_bridge_win_interactive_uitest.cc b/chrome/browser/notifications/notification_platform_bridge_win_interactive_uitest.cc
index 791ddae07ba2c..aeb7e15d89a18 100644
--- a/chrome/browser/notifications/notification_platform_bridge_win_interactive_uitest.cc
+++ b/chrome/browser/notifications/notification_platform_bridge_win_interactive_uitest.cc
@@ -2,14 +2,13 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include <wrl/client.h>
-#include <wrl/implements.h>
-
 #include <memory>
 #include <set>
 #include <string>
 #include <vector>
 
+#include <wrl/client.h>
+#include <wrl/implements.h>
 #include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
@@ -22,6 +21,7 @@
 #include "base/test/bind.h"
 #include "base/threading/thread_restrictions.h"
 #include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/notifications/notification_display_service_tester.h"
@@ -51,6 +51,12 @@ const char kLaunchIdButtonClick[] =
 const char kLaunchIdSettings[] =
     "2|0|Default|0|https://example.com/|notification_id";
 
+// Windows native notification have a dependency on WinRT (Win 8+) and the
+// built in Notification Center. Although native notifications in Chrome are
+// only available in Win 10+ we keep the minimum test coverage at Win 8 in case
+// we decide to backport.
+constexpr base::win::Version kMinimumWindowsVersion = base::win::Version::WIN8;
+
 Profile* CreateTestingProfile(const base::FilePath& path) {
   base::ScopedAllowBlockingForTesting allow_blocking;
   ProfileManager* profile_manager = g_browser_process->profile_manager();
@@ -218,6 +224,9 @@ class FakeIToastActivatedEventArgs
 };
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleEvent) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   const wchar_t kXmlDoc[] =
       LR"(<toast launch="0|0|Default|0|https://example.com/|notification_id">
  <visual>
@@ -259,6 +268,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleEvent) {
 }
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleActivation) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   base::RunLoop run_loop;
   display_service_tester_->SetProcessNotificationOperationDelegate(
       base::BindRepeating(&NotificationPlatformBridgeWinUITest::HandleOperation,
@@ -283,6 +295,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleActivation) {
 }
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleSettings) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   const wchar_t kXmlDoc[] =
       LR"(<toast launch="0|0|Default|0|https://example.com/|notification_id">
  <visual>
@@ -324,6 +339,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleSettings) {
 }
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleClose) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   base::RunLoop run_loop;
   display_service_tester_->SetProcessNotificationOperationDelegate(
       base::BindRepeating(&NotificationPlatformBridgeWinUITest::HandleOperation,
@@ -348,6 +366,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, HandleClose) {
 }
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, GetDisplayed) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   NotificationPlatformBridgeWin* bridge = GetBridge();
   ASSERT_TRUE(bridge);
 
@@ -440,6 +461,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, GetDisplayed) {
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest,
                        SynchronizeNotifications) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   NotificationPlatformBridgeWin* bridge = GetBridge();
   ASSERT_TRUE(bridge);
 
@@ -499,6 +523,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest,
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest,
                        SynchronizeNotificationsAfterClose) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   NotificationPlatformBridgeWin* bridge = GetBridge();
   ASSERT_TRUE(bridge);
   FakeIToastNotifier notifier;
@@ -544,6 +571,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest,
 // Test calling Display with a fake implementation of the Action Center
 // and validate it gets the values expected.
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, DisplayWithFakeAC) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   NotificationPlatformBridgeWin* bridge = GetBridge();
   ASSERT_TRUE(bridge);
 
@@ -577,6 +607,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, DisplayWithFakeAC) {
 }
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, CmdLineClick) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   ASSERT_NO_FATAL_FAILURE(ProcessLaunchIdViaCmdLine(kLaunchId, /*reply=*/""));
 
   // Validate the click values.
@@ -591,6 +624,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, CmdLineClick) {
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest,
                        CmdLineInlineReply) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   ASSERT_NO_FATAL_FAILURE(
       ProcessLaunchIdViaCmdLine(kLaunchIdButtonClick, "Inline reply"));
 
@@ -605,6 +641,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest,
 }
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, CmdLineButton) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   ASSERT_NO_FATAL_FAILURE(
       ProcessLaunchIdViaCmdLine(kLaunchIdButtonClick, /*reply=*/""));
 
@@ -619,6 +658,9 @@ IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, CmdLineButton) {
 }
 
 IN_PROC_BROWSER_TEST_F(NotificationPlatformBridgeWinUITest, CmdLineSettings) {
+  if (base::win::GetVersion() < kMinimumWindowsVersion)
+    return;
+
   ASSERT_NO_FATAL_FAILURE(
       ProcessLaunchIdViaCmdLine(kLaunchIdSettings, /*reply=*/""));
 
diff --git a/chrome/browser/notifications/notification_platform_bridge_win_unittest.cc b/chrome/browser/notifications/notification_platform_bridge_win_unittest.cc
index c99599812931e..67daf01f09e08 100644
--- a/chrome/browser/notifications/notification_platform_bridge_win_unittest.cc
+++ b/chrome/browser/notifications/notification_platform_bridge_win_unittest.cc
@@ -4,21 +4,22 @@
 
 #include "chrome/browser/notifications/notification_platform_bridge_win.h"
 
-#include <windows.ui.notifications.h>
-#include <wrl/client.h>
-#include <wrl/implements.h>
-
 #include <memory>
 #include <string>
 #include <utility>
 #include <vector>
 
+#include <windows.ui.notifications.h>
+#include <wrl/client.h>
+#include <wrl/implements.h>
+
 #include "base/hash/hash.h"
 #include "base/logging.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/notifications/notification_common.h"
 #include "chrome/browser/notifications/win/fake_itoastnotification.h"
 #include "chrome/browser/notifications/win/fake_notification_image_retainer.h"
@@ -97,6 +98,11 @@ class NotificationPlatformBridgeWinTest : public testing::Test {
 };
 
 TEST_F(NotificationPlatformBridgeWinTest, GroupAndTag) {
+  // This test requires WinRT core functions, which are not available in
+  // older versions of Windows.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   base::win::ScopedCOMInitializer com_initializer;
 
   NotificationPlatformBridgeWin bridge;
@@ -128,6 +134,11 @@ TEST_F(NotificationPlatformBridgeWinTest, GroupAndTag) {
 }
 
 TEST_F(NotificationPlatformBridgeWinTest, GroupAndTagUniqueness) {
+  // This test requires WinRT core functions, which are not available in
+  // older versions of Windows.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   base::win::ScopedCOMInitializer com_initializer;
 
   NotificationPlatformBridgeWin bridge;
@@ -202,6 +213,11 @@ TEST_F(NotificationPlatformBridgeWinTest, GroupAndTagUniqueness) {
 }
 
 TEST_F(NotificationPlatformBridgeWinTest, Suppress) {
+  // This test requires WinRT core functions, which are not available in
+  // older versions of Windows.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   base::win::ScopedCOMInitializer com_initializer;
 
   NotificationPlatformBridgeWin bridge;
diff --git a/chrome/browser/notifications/win/notification_helper_launches_chrome_unittest.cc b/chrome/browser/notifications/win/notification_helper_launches_chrome_unittest.cc
index 58a6d7a976805..be952b16c3291 100644
--- a/chrome/browser/notifications/win/notification_helper_launches_chrome_unittest.cc
+++ b/chrome/browser/notifications/win/notification_helper_launches_chrome_unittest.cc
@@ -31,6 +31,7 @@
 #include "base/process/process_iterator.h"
 #include "base/test/test_timeouts.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/setup/install_worker.h"
@@ -250,6 +251,11 @@ class NotificationHelperLaunchesChrome : public testing::Test {
 };
 
 TEST_F(NotificationHelperLaunchesChrome, ChromeLaunchTest) {
+  // This test requires WinRT core functions, which are not available in
+  // older versions of Windows.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   // There isn't a way to directly correlate the notification_helper.exe server
   // to this test. So we need to hunt for the server.
   base::Process notification_helper_process =
diff --git a/chrome/browser/renderer_context_menu/spelling_menu_observer_browsertest.cc b/chrome/browser/renderer_context_menu/spelling_menu_observer_browsertest.cc
index 8cc2f049f8ef6..52a070a55ede7 100644
--- a/chrome/browser/renderer_context_menu/spelling_menu_observer_browsertest.cc
+++ b/chrome/browser/renderer_context_menu/spelling_menu_observer_browsertest.cc
@@ -36,6 +36,11 @@ class SpellingMenuObserverTest : public InProcessBrowserTest {
     Reset(false);
 
 #if BUILDFLAG(IS_WIN) && BUILDFLAG(USE_BROWSER_SPELLCHECKER)
+    // Windows versions that don't support platform
+    // spellchecker fallback to Hunspell.
+    if (!spellcheck::WindowsVersionSupportsSpellchecker())
+      return;
+
     base::Value::List dictionary;
     dictionary.Append("en-US");
     menu()->GetPrefs()->SetList(spellcheck::prefs::kSpellCheckDictionaries,
@@ -115,9 +120,11 @@ class SpellingMenuObserverTest : public InProcessBrowserTest {
     if (params.misspelled_word.empty())
       callback_received_ = true;
 
-    observer_->RegisterSuggestionsCompleteCallbackForTesting(
-        base::BindOnce(&SpellingMenuObserverTest::OnSuggestionsComplete,
-                       base::Unretained(this)));
+    if (spellcheck::WindowsVersionSupportsSpellchecker()) {
+      observer_->RegisterSuggestionsCompleteCallbackForTesting(
+          base::BindOnce(&SpellingMenuObserverTest::OnSuggestionsComplete,
+                         base::Unretained(this)));
+    }
 #endif  // BUILDFLAG(IS_WIN) && BUILDFLAG(USE_BROWSER_SPELLCHECKER)
 
     observer_->InitMenu(params);
@@ -127,7 +134,8 @@ class SpellingMenuObserverTest : public InProcessBrowserTest {
     observer_->OnContextMenuShown(params, gfx::Rect());
 
 #if BUILDFLAG(IS_WIN) && BUILDFLAG(USE_BROWSER_SPELLCHECKER)
-    RunUntilCallbackReceived();
+    if (spellcheck::WindowsVersionSupportsSpellchecker())
+      RunUntilCallbackReceived();
 #endif  // BUILDFLAG(IS_WIN) && BUILDFLAG(USE_BROWSER_SPELLCHECKER)
   }
 
@@ -217,6 +225,10 @@ IN_PROC_BROWSER_TEST_F(SpellingMenuObserverTest, InitMenuWithMisspelledWord) {
 // by both Hunspell and Windows platform combines their suggestions.
 IN_PROC_BROWSER_TEST_F(SpellingMenuObserverTest,
                        WinInitMenuWithMisspelledWordCombined) {
+  // Test invalid for Windows versions that don't support platform spellchecker.
+  if (!spellcheck::WindowsVersionSupportsSpellchecker())
+    return;
+
   InitMenu("mispelled", "misspelling");
   EXPECT_EQ(6U, menu()->GetMenuSize());
 
@@ -263,6 +275,10 @@ IN_PROC_BROWSER_TEST_F(SpellingMenuObserverTest,
 // single suggestion.
 IN_PROC_BROWSER_TEST_F(SpellingMenuObserverTest,
                        WinInitMenuWithMisspelledWordNoDuplicateSuggestions) {
+  // Test invalid for Windows versions that don't support platform spellchecker.
+  if (!spellcheck::WindowsVersionSupportsSpellchecker())
+    return;
+
   InitMenu("mispelled", "misspelled");
   EXPECT_EQ(5U, menu()->GetMenuSize());
 
@@ -303,6 +319,10 @@ IN_PROC_BROWSER_TEST_F(SpellingMenuObserverTest,
 // 3 suggestions.
 IN_PROC_BROWSER_TEST_F(SpellingMenuObserverTest,
                        WinInitMenuWithMisspelledWordMaxSuggestions) {
+  // Test invalid for Windows versions that don't support platform spellchecker.
+  if (!spellcheck::WindowsVersionSupportsSpellchecker())
+    return;
+
   InitMenu("wtree", "wee");
   EXPECT_EQ(7U, menu()->GetMenuSize());
 
diff --git a/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.cc b/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.cc
index ccfbe140ddba6..0ba2145a8980f 100644
--- a/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.cc
+++ b/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.cc
@@ -8,7 +8,6 @@
 
 #include <algorithm>
 #include <memory>
-#include <string>
 #include <tuple>
 #include <utility>
 
@@ -26,6 +25,7 @@
 #include "base/task/thread_pool.h"
 #include "base/trace_event/typed_macros.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/metrics/chrome_metrics_service_accessor.h"
 #include "chrome/browser/profiles/profile.h"
@@ -541,6 +541,15 @@ void SetSwReporterTestingDelegate(SwReporterTestingDelegate* delegate) {
   g_testing_delegate_ = delegate;
 }
 
+bool ReporterTerminatesOnBrowserExit() {
+  // Windows 7 does not allow nested job objects, and the process may already
+  // be in a job (for example when running under a debugger or in Terminal
+  // Server) so only enable this on Windows 8+. The reporter will finish its
+  // scan and upload reports if the user has opted in, but not be able to
+  // prompt for cleanup if UwS is found.
+  return base::win::GetVersion() >= base::win::Version::WIN8;
+}
+
 // This function is called from a worker thread to launch the SwReporter and
 // wait for termination to collect its exit code. This task could be
 // interrupted by a shutdown at any time, so it shouldn't depend on anything
@@ -568,10 +577,13 @@ ReporterRunResult LaunchAndWaitForExit(const SwReporterInvocation& invocation) {
   // Assign the reporter process to a job. If the browser exits before the
   // reporter, the OS will close the job handle and the reporter process.
   base::win::ScopedHandle job;
-  job.Set(::CreateJobObject(nullptr, nullptr));
-  if (job.IsValid()) {
-    base::SetJobObjectLimitFlags(job.Get(), JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE);
-    launch_options.job_handle = job.Get();
+  if (ReporterTerminatesOnBrowserExit()) {
+    job.Set(::CreateJobObject(nullptr, nullptr));
+    if (job.IsValid()) {
+      base::SetJobObjectLimitFlags(job.Get(),
+                                   JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE);
+      launch_options.job_handle = job.Get();
+    }
   }
 
   base::Time start_time = Now();
diff --git a/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.h b/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.h
index 150762b4818ba..4a638714d49d5 100644
--- a/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.h
+++ b/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win.h
@@ -75,6 +75,10 @@ struct ReporterRunResult {
 // cleared.
 void SetSwReporterTestingDelegate(SwReporterTestingDelegate* delegate);
 
+// Returns true if the reporter is expected to terminate when the browser does
+// on this version of Windows. Exposed for testing.
+bool ReporterTerminatesOnBrowserExit();
+
 // Launches a reporter process based on the command-line in `invocation` and
 // returns its exit code and running time. Exposed for testing.
 ReporterRunResult LaunchAndWaitForExit(const SwReporterInvocation& invocation);
diff --git a/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win_unittest.cc b/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win_unittest.cc
index 8195346f88f4f..1b20f72b6bf84 100644
--- a/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win_unittest.cc
+++ b/chrome/browser/safe_browsing/chrome_cleaner/reporter_runner_win_unittest.cc
@@ -262,6 +262,12 @@ MULTIPROCESS_TEST_MAIN(DefaultBehaviourChild) {
 
 // Parent process.
 TEST(ReporterRunnerLaunchTest, ValidateDefaultBehaviour) {
+  if (!safe_browsing::internal::ReporterTerminatesOnBrowserExit()) {
+    // No point testing the default behaviour if we won't run the
+    // TerminateWhileRunning test.
+    GTEST_SKIP();
+  }
+
   base::Process child, grandchild;
   ASSERT_TRUE(
       CreateRunningProcesses("DefaultBehaviourChild", &child, &grandchild));
@@ -297,6 +303,12 @@ MULTIPROCESS_TEST_MAIN(SwReporterChild) {
 
 // Parent process.
 TEST(ReporterRunnerLaunchTest, TerminateWhileRunning) {
+  if (!safe_browsing::internal::ReporterTerminatesOnBrowserExit()) {
+    // Skip the test since the code being tested isn't enabled in this
+    // configuration.
+    GTEST_SKIP();
+  }
+
   base::Process child, grandchild;
   ASSERT_TRUE(CreateRunningProcesses("SwReporterChild", &child, &grandchild));
   ASSERT_TRUE(child.Terminate(/*exit_code=*/0, /*wait=*/false));
diff --git a/chrome/browser/shell_integration.cc b/chrome/browser/shell_integration.cc
index 6018e496fc903..7c57e6d5fda92 100644
--- a/chrome/browser/shell_integration.cc
+++ b/chrome/browser/shell_integration.cc
@@ -111,6 +111,12 @@ bool CanSetAsDefaultBrowser() {
   return GetDefaultBrowserSetPermission() != SET_DEFAULT_NOT_ALLOWED;
 }
 
+#if !BUILDFLAG(IS_WIN)
+bool IsElevationNeededForSettingDefaultSchemeClient() {
+  return false;
+}
+#endif  // !BUILDFLAG(IS_WIN)
+
 base::CommandLine CommandLineArgsForLauncher(
     const GURL& url,
     const std::string& extension_app_id,
@@ -284,11 +290,17 @@ void DefaultBrowserWorker::SetAsDefaultImpl(
     case SET_DEFAULT_INTERACTIVE:
 #if BUILDFLAG(IS_WIN)
       if (interactive_permitted_) {
-        win::SetAsDefaultBrowserUsingSystemSettings(
-            std::move(on_finished_callback));
-        // Early return because the function above takes care of calling
-        // `on_finished_callback`.
-        return;
+        switch (ShellUtil::GetInteractiveSetDefaultMode()) {
+          case ShellUtil::INTENT_PICKER:
+            win::SetAsDefaultBrowserUsingIntentPicker();
+            break;
+          case ShellUtil::SYSTEM_SETTINGS:
+            win::SetAsDefaultBrowserUsingSystemSettings(
+                std::move(on_finished_callback));
+            // Early return because the function above takes care of calling
+            // |on_finished_callback|.
+            return;
+        }
       }
 #endif  // BUILDFLAG(IS_WIN)
       break;
@@ -371,11 +383,17 @@ void DefaultSchemeClientWorker::SetAsDefaultImpl(
     case SET_DEFAULT_INTERACTIVE:
 #if BUILDFLAG(IS_WIN)
       if (interactive_permitted_) {
-        win::SetAsDefaultClientForSchemeUsingSystemSettings(
-            scheme_, std::move(on_finished_callback));
-        // Early return because the function above takes care of calling
-        // `on_finished_callback`.
-        return;
+        switch (ShellUtil::GetInteractiveSetDefaultMode()) {
+          case ShellUtil::INTENT_PICKER:
+            win::SetAsDefaultClientForSchemeUsingIntentPicker(scheme_);
+            break;
+          case ShellUtil::SYSTEM_SETTINGS:
+            win::SetAsDefaultClientForSchemeUsingSystemSettings(
+                scheme_, std::move(on_finished_callback));
+            // Early return because the function above takes care of calling
+            // |on_finished_callback|.
+            return;
+        }
       }
 #endif  // BUILDFLAG(IS_WIN)
       break;
diff --git a/chrome/browser/shell_integration.h b/chrome/browser/shell_integration.h
index 7f634f7dbb922..bd6bf9932e700 100644
--- a/chrome/browser/shell_integration.h
+++ b/chrome/browser/shell_integration.h
@@ -69,6 +69,10 @@ DefaultWebClientSetPermission GetDefaultSchemeClientSetPermission();
 // GetDefaultWebClientSetPermission() if this distinction is important.
 bool CanSetAsDefaultBrowser();
 
+// Returns true if making the running browser the default client for any
+// scheme requires elevated privileges.
+bool IsElevationNeededForSettingDefaultSchemeClient();
+
 // Returns a string representing the application to be launched given the
 // scheme of the requested url. This string may be a name or a path, but
 // neither is guaranteed and it should only be used as a display string.
diff --git a/chrome/browser/shell_integration_win.cc b/chrome/browser/shell_integration_win.cc
index 52cb07e231d8a..a66373b21e898 100644
--- a/chrome/browser/shell_integration_win.cc
+++ b/chrome/browser/shell_integration_win.cc
@@ -41,6 +41,7 @@
 #include "base/win/scoped_propvariant.h"
 #include "base/win/shlwapi.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/policy/policy_path_parser.h"
 #include "chrome/browser/shell_integration.h"
 #include "chrome/browser/web_applications/os_integration/web_app_shortcut_win.h"
@@ -67,7 +68,8 @@ BASE_FEATURE(kWin10UnattendedDefault,
              base::FEATURE_DISABLED_BY_DEFAULT);
 
 bool CanSetAsDefaultDirectly() {
-  return base::FeatureList::IsEnabled(kWin10UnattendedDefault);
+  return base::win::GetVersion() >= base::win::Version::WIN10 &&
+         base::FeatureList::IsEnabled(kWin10UnattendedDefault);
 }
 
 // Helper function for GetAppId to generates profile id
@@ -738,10 +740,29 @@ bool SetAsDefaultClientForScheme(const std::string& scheme) {
   return true;
 }
 
+DefaultWebClientSetPermission
+GetPlatformSpecificDefaultWebClientSetPermission() {
+  if (!install_static::SupportsSetAsDefaultBrowser())
+    return SET_DEFAULT_NOT_ALLOWED;
+  if (ShellUtil::CanMakeChromeDefaultUnattended())
+    return SET_DEFAULT_UNATTENDED;
+  if (CanSetAsDefaultDirectly())
+    return SET_DEFAULT_UNATTENDED;
+  // Setting the default web client generally requires user interaction in
+  // Windows 8+ with permitted exceptions above.
+  return SET_DEFAULT_INTERACTIVE;
+}
+
+bool IsElevationNeededForSettingDefaultSchemeClient() {
+  return base::win::GetVersion() < base::win::Version::WIN8;
+}
+
 std::u16string GetApplicationNameForScheme(const GURL& url) {
-  std::u16string application_name = GetAppForSchemeUsingAssocQuery(url);
-  if (!application_name.empty()) {
-    return application_name;
+  // Windows 8 or above has a new scheme association query.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    std::u16string application_name = GetAppForSchemeUsingAssocQuery(url);
+    if (!application_name.empty())
+      return application_name;
   }
 
   return GetAppForSchemeUsingRegistry(url);
@@ -804,6 +825,25 @@ DefaultWebClientSetPermission GetPlatformSpecificDefaultWebClientSetPermission(
 
 namespace win {
 
+bool SetAsDefaultBrowserUsingIntentPicker() {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  base::FilePath chrome_exe;
+  if (!base::PathService::Get(base::FILE_EXE, &chrome_exe)) {
+    NOTREACHED() << "Error getting app exe path";
+    return false;
+  }
+
+  if (!ShellUtil::ShowMakeChromeDefaultSystemUI(chrome_exe)) {
+    LOG(ERROR) << "Failed to launch the set-default-browser Windows UI.";
+    return false;
+  }
+
+  VLOG(1) << "Set-default-browser Windows UI completed.";
+  return true;
+}
+
 void SetAsDefaultBrowserUsingSystemSettings(
     base::OnceClosure on_finished_callback) {
   base::FilePath chrome_exe;
@@ -829,6 +869,27 @@ void SetAsDefaultBrowserUsingSystemSettings(
                                std::move(on_finished_callback)));
 }
 
+bool SetAsDefaultClientForSchemeUsingIntentPicker(const std::string& scheme) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  base::FilePath chrome_exe;
+  if (!base::PathService::Get(base::FILE_EXE, &chrome_exe)) {
+    NOTREACHED() << "Error getting app exe path";
+    return false;
+  }
+
+  std::wstring wscheme(base::UTF8ToWide(scheme));
+  if (!ShellUtil::ShowMakeChromeDefaultProtocolClientSystemUI(chrome_exe,
+                                                              wscheme)) {
+    LOG(ERROR) << "Failed to launch the set-default-client Windows UI.";
+    return false;
+  }
+
+  VLOG(1) << "Set-default-client Windows UI completed.";
+  return true;
+}
+
 void SetAsDefaultClientForSchemeUsingSystemSettings(
     const std::string& scheme,
     base::OnceClosure on_finished_callback) {
diff --git a/chrome/browser/shell_integration_win.h b/chrome/browser/shell_integration_win.h
index 4ab7f43c908b8..8e455c779bf61 100644
--- a/chrome/browser/shell_integration_win.h
+++ b/chrome/browser/shell_integration_win.h
@@ -22,12 +22,28 @@ namespace shell_integration::win {
 struct ShortcutProperties;
 enum class ShortcutOperation;
 
+// Initiates an OS shell flow which (if followed by the user) should set
+// Chrome as the default browser. Returns false if the flow cannot be
+// initialized, if it is not supported (introduced for Windows 8) or if the
+// user cancels the operation. This is a blocking call and requires a FILE
+// thread. If Chrome is already default browser, no interactive dialog will be
+// shown and this method returns true.
+bool SetAsDefaultBrowserUsingIntentPicker();
+
 // Initiates the interaction with the system settings for the default browser.
 // The function takes care of making sure |on_finished_callback| will get called
 // exactly once when the interaction is finished.
 void SetAsDefaultBrowserUsingSystemSettings(
     base::OnceClosure on_finished_callback);
 
+// Initiates an OS shell flow which (if followed by the user) should set
+// Chrome as the default handler for |scheme|. Returns false if the flow
+// cannot be initialized, if it is not supported (introduced for Windows 8)
+// or if the user cancels the operation. This is a blocking call and requires
+// a FILE thread. If Chrome is already default for |scheme|, no interactive
+// dialog will be shown and this method returns true.
+bool SetAsDefaultClientForSchemeUsingIntentPicker(const std::string& scheme);
+
 // Initiates the interaction with the system settings for the default handler of
 // |scheme|. The function takes care of making sure |on_finished_callback|
 // will get called exactly once when the interaction is finished.
diff --git a/chrome/browser/spellchecker/spell_check_host_chrome_impl_win_browsertest.cc b/chrome/browser/spellchecker/spell_check_host_chrome_impl_win_browsertest.cc
index 7fb1eb56037b9..bc4696ec86752 100644
--- a/chrome/browser/spellchecker/spell_check_host_chrome_impl_win_browsertest.cc
+++ b/chrome/browser/spellchecker/spell_check_host_chrome_impl_win_browsertest.cc
@@ -110,6 +110,10 @@ IN_PROC_BROWSER_TEST_F(SpellCheckHostChromeImplWinBrowserTest,
 }
 
 void SpellCheckHostChromeImplWinBrowserTest::RunSpellCheckReturnMessageTest() {
+  if (!spellcheck::WindowsVersionSupportsSpellchecker()) {
+    return;
+  }
+
   spellcheck_platform::SetLanguage(
       platform_spell_checker_, "en-US",
       base::BindOnce(&SpellCheckHostChromeImplWinBrowserTest::
diff --git a/chrome/browser/spellchecker/spellcheck_language_policy_handlers_unittest.cc b/chrome/browser/spellchecker/spellcheck_language_policy_handlers_unittest.cc
index d9fb21277c3cb..8d4ed2955910d 100644
--- a/chrome/browser/spellchecker/spellcheck_language_policy_handlers_unittest.cc
+++ b/chrome/browser/spellchecker/spellcheck_language_policy_handlers_unittest.cc
@@ -106,6 +106,9 @@ TEST_P(SpellcheckLanguagePolicyHandlersTest, ApplyPolicySettings) {
 #if BUILDFLAG(IS_WIN) && BUILDFLAG(USE_BROWSER_SPELLCHECKER)
   base::test::ScopedFeatureList feature_list;
   if (GetParam().windows_spellchecker_enabled) {
+    if (!spellcheck::WindowsVersionSupportsSpellchecker())
+      return;
+
     // Force Windows native spellchecking to be enabled.
     feature_list.InitAndEnableFeature(spellcheck::kWinUseBrowserSpellChecker);
   } else {
diff --git a/chrome/browser/spellchecker/spellcheck_service.cc b/chrome/browser/spellchecker/spellcheck_service.cc
index 809410c3c7337..a2f99c17fc5d9 100644
--- a/chrome/browser/spellchecker/spellcheck_service.cc
+++ b/chrome/browser/spellchecker/spellcheck_service.cc
@@ -900,14 +900,16 @@ void SpellcheckService::InitializePlatformSpellchecker() {
   // since metrics on the availability of Windows platform language packs are
   // being recorded. Thus method should only be called once, except in test
   // code.
-  if (!platform_spell_checker()) {
+  if (!platform_spell_checker() &&
+      spellcheck::WindowsVersionSupportsSpellchecker()) {
     platform_spell_checker_ = std::make_unique<WindowsSpellChecker>(
         base::ThreadPool::CreateCOMSTATaskRunner({base::MayBlock()}));
   }
 }
 
 void SpellcheckService::RecordSpellcheckLocalesStats() {
-  if (metrics_ && platform_spell_checker() && !hunspell_dictionaries_.empty()) {
+  if (spellcheck::WindowsVersionSupportsSpellchecker() && metrics_ &&
+      platform_spell_checker() && !hunspell_dictionaries_.empty()) {
     std::vector<std::string> hunspell_locales;
     for (auto& dict : hunspell_dictionaries_) {
       hunspell_locales.push_back(dict->GetLanguage());
@@ -920,9 +922,10 @@ void SpellcheckService::RecordSpellcheckLocalesStats() {
 void SpellcheckService::RecordChromeLocalesStats() {
   const auto& accept_languages =
       GetNormalizedAcceptLanguages(/* normalize_for_spellcheck */ false);
-  if (metrics_ && platform_spell_checker() && !accept_languages.empty()) {
-    spellcheck_platform::RecordChromeLocalesStats(platform_spell_checker(),
-                                                  std::move(accept_languages));
+  if (spellcheck::WindowsVersionSupportsSpellchecker() && metrics_ &&
+      platform_spell_checker() && !accept_languages.empty()) {
+    spellcheck_platform::RecordChromeLocalesStats(
+        platform_spell_checker(), std::move(accept_languages));
   }
 }
 
diff --git a/chrome/browser/spellchecker/spellcheck_service.h b/chrome/browser/spellchecker/spellcheck_service.h
index 17b0aaeb05bcb..d85904f3f0db6 100644
--- a/chrome/browser/spellchecker/spellcheck_service.h
+++ b/chrome/browser/spellchecker/spellcheck_service.h
@@ -173,7 +173,7 @@ class SpellcheckService : public KeyedService,
 
   // The returned pointer can be null if the current platform doesn't need a
   // per-profile, platform-specific spell check object. Currently, only Windows
-  // requires one.
+  // requires one, and only on certain versions.
   PlatformSpellChecker* platform_spell_checker() {
     return platform_spell_checker_.get();
   }
diff --git a/chrome/browser/spellchecker/spellcheck_service_browsertest.cc b/chrome/browser/spellchecker/spellcheck_service_browsertest.cc
index efb0d06833b7a..5a1b02acf745d 100644
--- a/chrome/browser/spellchecker/spellcheck_service_browsertest.cc
+++ b/chrome/browser/spellchecker/spellcheck_service_browsertest.cc
@@ -707,6 +707,9 @@ class SpellcheckServiceWindowsHybridBrowserTest
 
 IN_PROC_BROWSER_TEST_F(SpellcheckServiceWindowsHybridBrowserTest,
                        WindowsHybridSpellcheck) {
+  if (!spellcheck::WindowsVersionSupportsSpellchecker())
+    return;
+
   // This test specifically covers the case where spellcheck delayed
   // initialization is not enabled, so return early if it is. Other tests
   // cover the case where delayed initialization is enabled.
@@ -830,6 +833,9 @@ IN_PROC_BROWSER_TEST_F(SpellcheckServiceWindowsHybridBrowserTestDelayInit,
 
 IN_PROC_BROWSER_TEST_F(SpellcheckServiceWindowsHybridBrowserTestDelayInit,
                        WindowsHybridSpellcheckDelayInit) {
+  if (!spellcheck::WindowsVersionSupportsSpellchecker())
+    return;
+
   ASSERT_TRUE(spellcheck::UseBrowserSpellChecker());
 
   // Note that the base class forces dictionary sync to not be performed, and
diff --git a/chrome/browser/spellchecker/spellcheck_service_unittest.cc b/chrome/browser/spellchecker/spellcheck_service_unittest.cc
index 42c96836486ad..bb93f0b890d56 100644
--- a/chrome/browser/spellchecker/spellcheck_service_unittest.cc
+++ b/chrome/browser/spellchecker/spellcheck_service_unittest.cc
@@ -230,6 +230,9 @@ void SpellcheckServiceHybridUnitTestBase::RunGetDictionariesTest(
     const std::string accept_languages,
     const std::vector<std::string> spellcheck_dictionaries,
     const std::vector<SpellcheckService::Dictionary> expected_dictionaries) {
+  if (!spellcheck::WindowsVersionSupportsSpellchecker())
+    return;
+
   prefs()->SetString(language::prefs::kAcceptLanguages, accept_languages);
   base::Value::List spellcheck_dictionaries_list;
   for (std::string dict : spellcheck_dictionaries) {
@@ -257,6 +260,9 @@ void SpellcheckServiceHybridUnitTestBase::RunDictionaryMappingTest(
     const std::string expected_tag_passed_to_spellcheck,
     const std::string expected_accept_language_generic,
     const std::string expected_tag_passed_to_spellcheck_generic) {
+  if (!spellcheck::WindowsVersionSupportsSpellchecker())
+    return;
+
   InitializeSpellcheckService({full_tag});
 
   std::string supported_dictionary;
diff --git a/chrome/browser/themes/theme_helper_win.cc b/chrome/browser/themes/theme_helper_win.cc
index 0573f2db91cd1..45cf225e88007 100644
--- a/chrome/browser/themes/theme_helper_win.cc
+++ b/chrome/browser/themes/theme_helper_win.cc
@@ -6,9 +6,13 @@
 
 #include "chrome/browser/win/titlebar_config.h"
 #include "chrome/grit/theme_resources.h"
+#include "skia/ext/skia_utils_win.h"
+#include "ui/base/win/shell.h"
 
 bool ThemeHelperWin::ShouldUseNativeFrame(
     const CustomThemeSupplier* theme_supplier) const {
-  return ShouldCustomDrawSystemTitlebar() ||
-         !HasCustomImage(IDR_THEME_FRAME, theme_supplier);
+  const bool use_native_frame_if_enabled =
+      ShouldCustomDrawSystemTitlebar() ||
+      !HasCustomImage(IDR_THEME_FRAME, theme_supplier);
+  return use_native_frame_if_enabled && ui::win::IsAeroGlassEnabled();
 }
diff --git a/chrome/browser/ui/browser_ui_prefs.cc b/chrome/browser/ui/browser_ui_prefs.cc
index 21fbb85231e22..df3225597d7e0 100644
--- a/chrome/browser/ui/browser_ui_prefs.cc
+++ b/chrome/browser/ui/browser_ui_prefs.cc
@@ -5,7 +5,6 @@
 #include "chrome/browser/ui/browser_ui_prefs.h"
 
 #include <memory>
-#include <string>
 
 #include "base/numerics/safe_conversions.h"
 #include "build/build_config.h"
@@ -26,6 +25,10 @@
 #include "ui/accessibility/accessibility_features.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace {
 
 uint32_t GetHomeButtonAndHomePageIsNewTabPageFlags() {
@@ -66,7 +69,7 @@ void RegisterBrowserUserPrefs(user_prefs::PrefRegistrySyncable* registry) {
   registry->RegisterInt64Pref(prefs::kDefaultBrowserLastDeclined, 0);
   bool reset_check_default = false;
 #if BUILDFLAG(IS_WIN)
-  reset_check_default = true;
+  reset_check_default = base::win::GetVersion() >= base::win::Version::WIN10;
 #endif
   registry->RegisterBooleanPref(prefs::kResetCheckDefaultBrowser,
                                 reset_check_default);
diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index 0639765665e32..74edca8e635ee 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -14,6 +14,7 @@
 #include "chrome/browser/win/titlebar_config.h"
 #include "chrome/grit/theme_resources.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "ui/base/win/shell.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_mixer.h"
 #include "ui/color/color_provider.h"
@@ -28,7 +29,11 @@
 
 namespace {
 
-const SkColor kDefaultInactiveFrameColor = SK_ColorWHITE;
+SkColor GetDefaultInactiveFrameColor() {
+  return base::win::GetVersion() < base::win::Version::WIN10
+             ? SkColorSetRGB(0xEB, 0xEB, 0xEB)
+             : SK_ColorWHITE;
+}
 
 // This class encapsulates much of the same logic from ThemeHelperWin pertaining
 // to the calculation of frame colors on Windows 8, 10 and up. Once the
@@ -116,7 +121,7 @@ void FrameColorHelper::AddNativeChromeColors(
     } else if (dwm_inactive_frame_color_) {
       mixer[ui::kColorFrameInactive] = {dwm_inactive_frame_color_.value()};
     } else if (!ShouldCustomDrawSystemTitlebar()) {
-      mixer[ui::kColorFrameInactive] = {kDefaultInactiveFrameColor};
+      mixer[ui::kColorFrameInactive] = {GetDefaultInactiveFrameColor()};
     } else if (dwm_frame_color_) {
       mixer[ui::kColorFrameInactive] =
           ui::HSLShift({dwm_frame_color_.value()},
@@ -158,8 +163,11 @@ bool FrameColorHelper::HasCustomImage(
 
 bool FrameColorHelper::DwmColorsAllowed(
     const ui::ColorProviderManager::Key& key) const {
-  return ShouldCustomDrawSystemTitlebar() ||
-         !HasCustomImage(IDR_THEME_FRAME, key);
+  const bool use_native_frame_if_enabled =
+      (ShouldCustomDrawSystemTitlebar() ||
+       !HasCustomImage(IDR_THEME_FRAME, key)) &&
+      (base::win::GetVersion() >= base::win::Version::WIN8);
+  return use_native_frame_if_enabled && ui::win::IsAeroGlassEnabled();
 }
 
 color_utils::HSL FrameColorHelper::GetTint(
@@ -184,10 +192,14 @@ void FrameColorHelper::FetchAccentColors() {
   const auto* accent_color_observer = ui::AccentColorObserver::Get();
   dwm_accent_border_color_ =
       accent_color_observer->accent_border_color().value_or(
-          kDefaultInactiveFrameColor);
+          GetDefaultInactiveFrameColor());
 
-  dwm_frame_color_ = accent_color_observer->accent_color();
-  dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    dwm_frame_color_ = dwm_accent_border_color_;
+  } else {
+    dwm_frame_color_ = accent_color_observer->accent_color();
+    dwm_inactive_frame_color_ = accent_color_observer->accent_color_inactive();
+  }
 }
 
 ui::ColorTransform GetCaptionForegroundColor(
diff --git a/chrome/browser/ui/frame/window_frame_util.cc b/chrome/browser/ui/frame/window_frame_util.cc
index db93bd137b649..ebf8406b035fa 100644
--- a/chrome/browser/ui/frame/window_frame_util.cc
+++ b/chrome/browser/ui/frame/window_frame_util.cc
@@ -8,6 +8,7 @@
 #include "ui/gfx/geometry/size.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/ui_features.h"
 #endif  // BUILDFLAG(IS_WIN)
@@ -35,6 +36,7 @@ bool WindowFrameUtil::IsWin10TabSearchCaptionButtonEnabled(
     const Browser* browser) {
 #if BUILDFLAG(IS_WIN)
   return browser->is_type_normal() &&
+         base::win::GetVersion() >= base::win::Version::WIN10 &&
          base::FeatureList::IsEnabled(features::kWin10TabSearchCaptionButton);
 #else
   return false;
diff --git a/chrome/browser/ui/startup/default_browser_infobar_delegate.cc b/chrome/browser/ui/startup/default_browser_infobar_delegate.cc
index cb17d94002dbf..dfc281964831b 100644
--- a/chrome/browser/ui/startup/default_browser_infobar_delegate.cc
+++ b/chrome/browser/ui/startup/default_browser_infobar_delegate.cc
@@ -93,6 +93,13 @@ std::u16string DefaultBrowserInfoBarDelegate::GetButtonLabel(
   return l10n_util::GetStringUTF16(IDS_DEFAULT_BROWSER_INFOBAR_OK_BUTTON_LABEL);
 }
 
+// Setting an app as the default browser doesn't require elevation directly, but
+// it does require registering it as the protocol handler for "http", so if
+// protocol registration in general requires elevation, this does as well.
+bool DefaultBrowserInfoBarDelegate::OKButtonTriggersUACPrompt() const {
+  return shell_integration::IsElevationNeededForSettingDefaultSchemeClient();
+}
+
 bool DefaultBrowserInfoBarDelegate::Accept() {
   action_taken_ = true;
   base::RecordAction(base::UserMetricsAction("DefaultBrowserInfoBar_Accept"));
diff --git a/chrome/browser/ui/startup/default_browser_infobar_delegate.h b/chrome/browser/ui/startup/default_browser_infobar_delegate.h
index 531bc268127de..00ea64ed6e6eb 100644
--- a/chrome/browser/ui/startup/default_browser_infobar_delegate.h
+++ b/chrome/browser/ui/startup/default_browser_infobar_delegate.h
@@ -57,6 +57,7 @@ class DefaultBrowserInfoBarDelegate : public ConfirmInfoBarDelegate {
   std::u16string GetMessageText() const override;
   int GetButtons() const override;
   std::u16string GetButtonLabel(InfoBarButton button) const override;
+  bool OKButtonTriggersUACPrompt() const override;
   bool Accept() override;
 
   // The WebContents's corresponding profile.
diff --git a/chrome/browser/ui/startup/startup_browser_creator_browsertest.cc b/chrome/browser/ui/startup/startup_browser_creator_browsertest.cc
index cb825e9d676a9..5e3a81675f7c7 100644
--- a/chrome/browser/ui/startup/startup_browser_creator_browsertest.cc
+++ b/chrome/browser/ui/startup/startup_browser_creator_browsertest.cc
@@ -174,6 +174,10 @@ using testing::Return;
 #include "components/supervised_user/core/common/supervised_user_constants.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_MAC)
 #include "chrome/browser/chrome_browser_application_mac.h"
 #endif
@@ -204,6 +208,14 @@ Browser* FindOneOtherBrowser(Browser* browser) {
   return other_browser;
 }
 
+bool IsWindows10OrNewer() {
+#if BUILDFLAG(IS_WIN)
+  return base::win::GetVersion() >= base::win::Version::WIN10;
+#else
+  return false;
+#endif
+}
+
 void DisableWelcomePages(const std::vector<Profile*>& profiles) {
   for (Profile* profile : profiles)
     profile->GetPrefs()->SetBoolean(prefs::kHasSeenWelcomePage, true);
@@ -2762,6 +2774,14 @@ class StartupBrowserWebAppProtocolHandlingTest : public InProcessBrowserTest {
  protected:
   StartupBrowserWebAppProtocolHandlingTest() = default;
 
+  bool AreProtocolHandlersSupported() {
+#if BUILDFLAG(IS_WIN)
+    return base::win::GetVersion() > base::win::Version::WIN7;
+#else
+    return true;
+#endif
+  }
+
   void SetUpOnMainThread() override {
     InProcessBrowserTest::SetUpOnMainThread();
   }
@@ -2822,6 +2842,9 @@ class StartupBrowserWebAppProtocolHandlingTest : public InProcessBrowserTest {
 IN_PROC_BROWSER_TEST_F(
     StartupBrowserWebAppProtocolHandlingTest,
     WebAppLaunch_WebAppIsNotLaunchedWithProtocolUrlAndDialogCancel) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   views::NamedWidgetShownWaiter waiter(views::test::AnyWidgetTestPasskey{},
                                        "ProtocolHandlerLaunchDialogView");
 
@@ -2846,6 +2869,9 @@ IN_PROC_BROWSER_TEST_F(
 IN_PROC_BROWSER_TEST_F(
     StartupBrowserWebAppProtocolHandlingTest,
     WebAppLaunch_WebAppIsLaunchedWithProtocolUrlAndDialogAccept) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   views::NamedWidgetShownWaiter waiter(views::test::AnyWidgetTestPasskey{},
                                        "ProtocolHandlerLaunchDialogView");
 
@@ -2899,6 +2925,9 @@ IN_PROC_BROWSER_TEST_F(
 IN_PROC_BROWSER_TEST_F(
     StartupBrowserWebAppProtocolHandlingTest,
     WebAppLaunch_WebAppIsNotTranslatedWithUnhandledProtocolUrl) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   // Register web app as a protocol handler that should *not* handle the launch.
   apps::ProtocolHandlerInfo protocol_handler;
   const std::string handler_url = std::string(kStartUrl) + "/testing=%s";
@@ -2929,6 +2958,9 @@ IN_PROC_BROWSER_TEST_F(
 IN_PROC_BROWSER_TEST_F(
     StartupBrowserWebAppProtocolHandlingTest,
     WebAppLaunch_WebAppIsLaunchedWithAllowedProtocolUrlPref) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   views::NamedWidgetShownWaiter waiter(views::test::AnyWidgetTestPasskey{},
                                        "ProtocolHandlerLaunchDialogView");
 
@@ -2995,6 +3027,9 @@ IN_PROC_BROWSER_TEST_F(
 
 IN_PROC_BROWSER_TEST_F(StartupBrowserWebAppProtocolHandlingTest,
                        WebAppLaunch_WebAppIsLaunchedWithAllowedProtocol) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   // Register web app as a protocol handler that should handle the launch.
   apps::ProtocolHandlerInfo protocol_handler;
   const std::string handler_url = std::string(kStartUrl) + "/testing=%s";
@@ -3064,6 +3099,9 @@ IN_PROC_BROWSER_TEST_F(StartupBrowserWebAppProtocolHandlingTest,
 IN_PROC_BROWSER_TEST_F(
     StartupBrowserWebAppProtocolHandlingTest,
     WebAppLaunch_WebAppIsLaunchedWithDiallowedProtocolUrlPref) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   views::NamedWidgetShownWaiter waiter(views::test::AnyWidgetTestPasskey{},
                                        "ProtocolHandlerLaunchDialogView");
 
@@ -3099,6 +3137,9 @@ IN_PROC_BROWSER_TEST_F(
 IN_PROC_BROWSER_TEST_F(
     StartupBrowserWebAppProtocolHandlingTest,
     WebAppLaunch_WebAppIsLaunchedWithDisallowedOnceProtocol) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   // Register web app as a protocol handler that should handle the launch.
   apps::ProtocolHandlerInfo protocol_handler;
   const std::string handler_url = std::string(kStartUrl) + "/testing=%s";
@@ -3151,6 +3192,9 @@ class StartupBrowserWebAppProtocolAndFileHandlingTest
 // handling launch, not a protocol handling or URL launch.
 IN_PROC_BROWSER_TEST_F(StartupBrowserWebAppProtocolAndFileHandlingTest,
                        WebAppLaunch_FileProtocol) {
+  if (!AreProtocolHandlersSupported())
+    GTEST_SKIP() << "Protocol Handlers unsupported";
+
   // Install an app with protocol handlers and a handler for plain text files.
   apps::ProtocolHandlerInfo protocol_handler;
   const std::string handler_url = std::string(kStartUrl) + "/protocol=%s";
@@ -3284,9 +3328,8 @@ IN_PROC_BROWSER_TEST_F(StartupBrowserCreatorFirstRunTest, AddFirstRunTabs) {
 #endif
 IN_PROC_BROWSER_TEST_F(StartupBrowserCreatorFirstRunTest,
                        MAYBE_RestoreOnStartupURLsPolicySpecified) {
-#if BUILDFLAG(IS_WIN)
-  return;
-#endif  // BUILDFLAG(IS_WIN)
+  if (IsWindows10OrNewer())
+    return;
 
   ASSERT_TRUE(embedded_test_server()->Start());
   StartupBrowserCreator browser_creator;
@@ -3485,17 +3528,18 @@ IN_PROC_BROWSER_TEST_F(StartupBrowserCreatorFirstRunTest,
   ScopedProfileKeepAlive profile1_keep_alive(
       profile1_ptr, ProfileKeepAliveOrigin::kBrowserWindow);
 
-#if BUILDFLAG(IS_WIN)
-  // Windows has its own Welcome page but even that should not show up when
+  // Windows 10 has its own Welcome page but even that should not show up when
   // the policy is set.
-  ASSERT_EQ(1, tab_strip->count());
-  EXPECT_EQ("title1.html",
-            tab_strip->GetWebContentsAt(0)->GetVisibleURL().ExtractFileName());
-
-  browser = CloseBrowserAndOpenNew(browser, profile1_ptr);
-  ASSERT_TRUE(browser);
-  tab_strip = browser->tab_strip_model();
-#endif  // BUILDFLAG(IS_WIN)
+  if (IsWindows10OrNewer()) {
+    ASSERT_EQ(1, tab_strip->count());
+    EXPECT_EQ(
+        "title1.html",
+        tab_strip->GetWebContentsAt(0)->GetVisibleURL().ExtractFileName());
+
+    browser = CloseBrowserAndOpenNew(browser, profile1_ptr);
+    ASSERT_TRUE(browser);
+    tab_strip = browser->tab_strip_model();
+  }
 
   // Ensure that the policy page page appears on second run on Win 10, and
   // on first run on all other platforms.
diff --git a/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.cc b/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.cc
index a6e9da073de65..df237a1313549 100644
--- a/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.cc
+++ b/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.cc
@@ -23,9 +23,11 @@
 #include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
 #include "ui/views/win/hwnd_util.h"
 
-ChromeNativeAppWindowViewsWin::ChromeNativeAppWindowViewsWin() = default;
+ChromeNativeAppWindowViewsWin::ChromeNativeAppWindowViewsWin()
+    : glass_frame_view_(nullptr), is_translucent_(false) {}
 
-ChromeNativeAppWindowViewsWin::~ChromeNativeAppWindowViewsWin() = default;
+ChromeNativeAppWindowViewsWin::~ChromeNativeAppWindowViewsWin() {
+}
 
 HWND ChromeNativeAppWindowViewsWin::GetNativeAppWindowHWND() const {
   return views::HWNDForWidget(widget()->GetTopLevelWidget());
@@ -77,10 +79,14 @@ void ChromeNativeAppWindowViewsWin::InitializeDefaultWindow(
 
 std::unique_ptr<views::NonClientFrameView>
 ChromeNativeAppWindowViewsWin::CreateStandardDesktopAppFrame() {
-  auto glass_frame_view =
-      std::make_unique<GlassAppWindowFrameViewWin>(widget());
-  glass_frame_view_ = glass_frame_view.get();
-  return glass_frame_view;
+  if (ui::win::IsAeroGlassEnabled()) {
+    auto glass_frame_view =
+        std::make_unique<GlassAppWindowFrameViewWin>(widget());
+    glass_frame_view_ = glass_frame_view.get();
+    return glass_frame_view;
+  }
+  glass_frame_view_ = nullptr;
+  return ChromeNativeAppWindowViewsAura::CreateStandardDesktopAppFrame();
 }
 
 bool ChromeNativeAppWindowViewsWin::CanMinimize() const {
diff --git a/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.h b/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.h
index f6c82a03c1124..3ad212c02013a 100644
--- a/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.h
+++ b/chrome/browser/ui/views/apps/chrome_native_app_window_views_win.h
@@ -50,16 +50,17 @@ class ChromeNativeAppWindowViewsWin : public ChromeNativeAppWindowViewsAura {
   // Overridden from views::WidgetDelegate:
   bool CanMinimize() const override;
 
-  // Populated if there is a standard desktop app frame, which provides special
-  // information to the native widget implementation. This will be NULL if the
-  // frame is a non-standard app frame created by CreateNonStandardAppFrame.
-  raw_ptr<GlassAppWindowFrameViewWin> glass_frame_view_ = nullptr;
+  // Populated if there is a glass frame, which provides special information
+  // to the native widget implementation. This will be NULL if there is no
+  // glass frame. Note, this can change from NULL to non-NULL and back again
+  // throughout the life of a window, e.g. if DWM is enabled and disabled.
+  raw_ptr<GlassAppWindowFrameViewWin> glass_frame_view_;
 
   // The Windows Application User Model ID identifying the app.
   std::wstring app_model_id_;
 
   // Whether the InitParams indicated that this window should be translucent.
-  bool is_translucent_ = false;
+  bool is_translucent_;
 
   base::WeakPtrFactory<ChromeNativeAppWindowViewsWin> weak_ptr_factory_{this};
 };
diff --git a/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc b/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
index 321bd4e99eec0..3c8b7d01fe480 100644
--- a/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
+++ b/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
@@ -6,8 +6,7 @@
 
 #include <windows.h>
 
-#include <algorithm>
-
+#include "base/win/windows_version.h"
 #include "extensions/browser/app_window/native_app_window.h"
 #include "ui/base/hit_test.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
@@ -34,14 +33,33 @@ gfx::Insets GlassAppWindowFrameViewWin::GetGlassInsets() const {
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CYSIZEFRAME) +
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CYCAPTION);
 
-  return gfx::Insets::TLBR(caption_height, 0, 0, 0);
+  int frame_size =
+      base::win::GetVersion() < base::win::Version::WIN10
+          ? display::win::ScreenWin::GetSystemMetricsInDIP(SM_CXSIZEFRAME)
+          : 0;
+
+  return gfx::Insets::TLBR(caption_height, frame_size, frame_size, frame_size);
 }
 
 gfx::Insets GlassAppWindowFrameViewWin::GetClientAreaInsets(
     HMONITOR monitor) const {
-  const int frame_thickness = ui::GetFrameThickness(monitor);
-  return gfx::Insets::TLBR(0, frame_thickness, frame_thickness,
-                           frame_thickness);
+  gfx::Insets insets;
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    // This tells Windows that most of the window is a client area, meaning
+    // Chrome will draw it. Windows still fills in the glass bits because of the
+    // DwmExtendFrameIntoClientArea call in |UpdateDWMFrame|.
+    // Without this 1 pixel offset on the right and bottom:
+    //   * windows paint in a more standard way, and
+    //   * we get weird black bars at the top when maximized in multiple monitor
+    //     configurations.
+    int border_thickness = 1;
+    insets = gfx::Insets::TLBR(0, 0, border_thickness, border_thickness);
+  } else {
+    const int frame_thickness = ui::GetFrameThickness(monitor);
+    insets =
+        gfx::Insets::TLBR(0, frame_thickness, frame_thickness, frame_thickness);
+  }
+  return insets;
 }
 
 gfx::Rect GlassAppWindowFrameViewWin::GetBoundsForClientView() const {
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc b/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
index 33d086cc55eab..27219164662f9 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bar_view_test.cc
@@ -5,9 +5,6 @@
 #include "chrome/browser/ui/views/bookmarks/bookmark_bar_view.h"
 
 #include <memory>
-#include <string>
-#include <utility>
-#include <vector>
 
 #include "base/compiler_specific.h"
 #include "base/functional/bind.h"
@@ -74,6 +71,7 @@
 #endif
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "ui/aura/window_tree_host.h"
 #endif
 
@@ -1453,6 +1451,7 @@ class BookmarkBarViewTest14 : public BookmarkBarViewEventTestBase {
   }
 
  private:
+
   void Step2() {
     // Menu should NOT be showing.
     views::MenuItemView* menu = bb_view_->GetMenu();
@@ -1595,6 +1594,14 @@ class BookmarkBarViewTest17 : public BookmarkBarViewEventTestBase {
 
  protected:
   void DoTestOnMessageLoop() override {
+#if BUILDFLAG(IS_WIN)
+    // TODO(crbug.com/453796): Flaky on Windows7.
+    if (base::win::GetVersion() <= base::win::Version::WIN7) {
+      Done();
+      return;
+    }
+#endif
+
     // Move the mouse to the other folder on the bookmark bar and press the
     // left mouse button.
     views::LabelButton* button = bb_view_->other_bookmarks_button();
diff --git a/chrome/browser/ui/views/chrome_views_delegate_win.cc b/chrome/browser/ui/views/chrome_views_delegate_win.cc
index 10c435d18fc38..04d59046f38f1 100644
--- a/chrome/browser/ui/views/chrome_views_delegate_win.cc
+++ b/chrome/browser/ui/views/chrome_views_delegate_win.cc
@@ -15,6 +15,7 @@
 #include "chrome/browser/ui/views/native_widget_factory.h"
 #include "chrome/browser/win/app_icon.h"
 #include "components/keep_alive_registry/scoped_keep_alive.h"
+#include "ui/base/win/shell.h"
 
 namespace {
 
@@ -132,10 +133,20 @@ views::NativeWidget* ChromeViewsDelegate::CreateNativeWidget(
     // TODO: This may no longer be needed if we get proper elevation-based
     // shadows on toplevel windows. See https://crbug.com/838667.
     native_widget_type = NativeWidgetType::NATIVE_WIDGET_AURA;
+  } else if (!ui::win::IsAeroGlassEnabled()) {
+    // If we don't have composition (either because Glass is not enabled or
+    // because it was disabled at the command line), anything that requires
+    // transparency will be broken with a toplevel window, so force the use of
+    // a non toplevel window.
+    if (params->opacity ==
+            views::Widget::InitParams::WindowOpacity::kTranslucent &&
+        !params->force_software_compositing)
+      native_widget_type = NativeWidgetType::NATIVE_WIDGET_AURA;
   } else {
-    // Otherwise, we can use a toplevel window (they get blended via
-    // WS_EX_COMPOSITED, which allows for animation effects, and for exceeding
-    // the bounds of the parent window).
+    // If we're on Vista+ with composition enabled, then we can use toplevel
+    // windows for most things (they get blended via WS_EX_COMPOSITED, which
+    // allows for animation effects, but also exceeding the bounds of the parent
+    // window).
     if (params->parent &&
         params->type != views::Widget::InitParams::TYPE_CONTROL &&
         params->type != views::Widget::InitParams::TYPE_WINDOW) {
diff --git a/chrome/browser/ui/views/create_application_shortcut_view.cc b/chrome/browser/ui/views/create_application_shortcut_view.cc
index cc577c0f0b0ba..991e8e18698d5 100644
--- a/chrome/browser/ui/views/create_application_shortcut_view.cc
+++ b/chrome/browser/ui/views/create_application_shortcut_view.cc
@@ -27,6 +27,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/installer/util/taskbar_util.h"
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -122,9 +123,14 @@ void CreateChromeApplicationShortcutView::InitControls() {
   std::unique_ptr<views::Checkbox> pin_to_taskbar_checkbox;
 
 #if BUILDFLAG(IS_WIN)
-  menu_check_box = AddCheckbox(
-      l10n_util::GetStringUTF16(IDS_CREATE_SHORTCUTS_START_MENU_CHKBOX),
-      prefs::kWebAppCreateInAppsMenu);
+  base::win::Version version = base::win::GetVersion();
+  // Do not allow creating shortcuts on the Start Screen for Windows 8.
+  if (version != base::win::Version::WIN8 &&
+      version != base::win::Version::WIN8_1) {
+    menu_check_box = AddCheckbox(
+        l10n_util::GetStringUTF16(IDS_CREATE_SHORTCUTS_START_MENU_CHKBOX),
+        prefs::kWebAppCreateInAppsMenu);
+  }
 
   // Only include the pin-to-taskbar option when running on versions of Windows
   // that support pinning.
diff --git a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
index 4f11e08495820..83fb6554536fb 100644
--- a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
+++ b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
@@ -264,6 +264,9 @@ bool BrowserDesktopWindowTreeHostWin::UsesNativeSystemMenu() const {
 void BrowserDesktopWindowTreeHostWin::Init(
     const views::Widget::InitParams& params) {
   DesktopWindowTreeHostWin::Init(params);
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;  // VirtualDesktopManager isn't supported pre Win-10.
+
   virtual_desktop_helper_ = new VirtualDesktopHelper(params.workspace);
   virtual_desktop_helper_->Init(GetHWND());
 }
@@ -363,12 +366,20 @@ bool BrowserDesktopWindowTreeHostWin::GetDwmFrameInsetsInPixels(
     *insets = gfx::Insets();
   } else {
     // The glass should extend to the bottom of the tabstrip.
+    HWND hwnd = GetHWND();
     gfx::Rect tabstrip_region_bounds(browser_frame_->GetBoundsForTabStripRegion(
         browser_view_->tab_strip_region_view()->GetMinimumSize()));
-    tabstrip_region_bounds = display::win::ScreenWin::DIPToClientRect(
-        GetHWND(), tabstrip_region_bounds);
-
-    *insets = gfx::Insets::TLBR(tabstrip_region_bounds.bottom(), 0, 0, 0);
+    tabstrip_region_bounds =
+        display::win::ScreenWin::DIPToClientRect(hwnd, tabstrip_region_bounds);
+
+    // The 2 px (not DIP) at the inner edges of Win 7 glass are a light and dark
+    // line, so we must inset further to account for those.
+    constexpr int kWin7GlassInset = 2;
+    const int inset = (base::win::GetVersion() < base::win::Version::WIN8)
+                          ? kWin7GlassInset
+                          : 0;
+    *insets = gfx::Insets::TLBR(tabstrip_region_bounds.bottom() + inset, inset,
+                                inset, inset);
   }
   return true;
 }
@@ -468,6 +479,9 @@ void BrowserDesktopWindowTreeHostWin::PostHandleMSG(UINT message,
 }
 
 views::FrameMode BrowserDesktopWindowTreeHostWin::GetFrameMode() const {
+  if (IsOpaqueHostedAppFrame())
+    return views::FrameMode::CUSTOM_DRAWN;
+
   const views::FrameMode system_frame_mode =
       ShouldCustomDrawSystemTitlebar()
           ? views::FrameMode::SYSTEM_DRAWN_NO_CONTROLS
@@ -497,6 +511,9 @@ bool BrowserDesktopWindowTreeHostWin::ShouldUseNativeFrame() const {
   if (!browser_view_->browser())
     return false;
 
+  if (IsOpaqueHostedAppFrame())
+    return false;
+
   // We don't theme popup or app windows, so regardless of whether or not a
   // theme is active for normal browser windows, we don't want to use the custom
   // frame for popups/apps.
@@ -561,6 +578,13 @@ void BrowserDesktopWindowTreeHostWin::UpdateWorkspace() {
                      weak_factory_.GetWeakPtr()));
 }
 
+bool BrowserDesktopWindowTreeHostWin::IsOpaqueHostedAppFrame() const {
+  // TODO(https://crbug.com/868239): Support Windows 7 Aero glass for web-app
+  // window titlebar controls.
+  return browser_view_->GetIsWebAppType() &&
+         base::win::GetVersion() < base::win::Version::WIN10;
+}
+
 SkBitmap GetBadgedIconBitmapForProfile(Profile* profile) {
   std::unique_ptr<gfx::ImageFamily> family = GetAppIconImageFamily();
   if (!family)
diff --git a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.h b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.h
index a3bd2e0cae1d3..e52ca6cb5dd3f 100644
--- a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.h
+++ b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.h
@@ -88,6 +88,8 @@ class BrowserDesktopWindowTreeHostWin
   // WindowTreeHost of its value.
   void UpdateWorkspace();
 
+  bool IsOpaqueHostedAppFrame() const;
+
   void SetWindowIcon(bool badged);
 
   raw_ptr<BrowserView> browser_view_;
diff --git a/chrome/browser/ui/views/frame/browser_non_client_frame_view_unittest.cc b/chrome/browser/ui/views/frame/browser_non_client_frame_view_unittest.cc
index 9c0399a7819a2..395176bc73161 100644
--- a/chrome/browser/ui/views/frame/browser_non_client_frame_view_unittest.cc
+++ b/chrome/browser/ui/views/frame/browser_non_client_frame_view_unittest.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/frame/browser_non_client_frame_view.h"
 
+#include "base/command_line.h"
 #include "base/functional/bind.h"
 #include "base/memory/raw_ptr.h"
 #include "build/build_config.h"
@@ -23,7 +24,7 @@
 class BrowserNonClientFrameViewTest : public TestWithBrowserView {
  public:
   explicit BrowserNonClientFrameViewTest(Browser::Type type)
-      : TestWithBrowserView(type) {}
+      : TestWithBrowserView(type), frame_view_(nullptr) {}
 
   BrowserNonClientFrameViewTest(const BrowserNonClientFrameViewTest&) = delete;
   BrowserNonClientFrameViewTest& operator=(
@@ -31,6 +32,11 @@ class BrowserNonClientFrameViewTest : public TestWithBrowserView {
 
   // TestWithBrowserView override:
   void SetUp() override {
+#if BUILDFLAG(IS_WIN)
+    // Use opaque frame.
+    base::CommandLine::ForCurrentProcess()->AppendSwitch(
+        switches::kDisableDwmComposition);
+#endif
     TestWithBrowserView::SetUp();
     views::Widget* widget = browser_view()->GetWidget();
     frame_view_ = static_cast<BrowserNonClientFrameView*>(
@@ -39,7 +45,7 @@ class BrowserNonClientFrameViewTest : public TestWithBrowserView {
 
  protected:
   // Owned by the browser view.
-  raw_ptr<BrowserNonClientFrameView> frame_view_ = nullptr;
+  raw_ptr<BrowserNonClientFrameView> frame_view_;
 };
 
 class BrowserNonClientFrameViewPopupTest
diff --git a/chrome/browser/ui/views/frame/browser_view.cc b/chrome/browser/ui/views/frame/browser_view.cc
index 8d1be7ef7470a..d96f5a2d061a4 100644
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -286,6 +286,7 @@
 #endif
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "chrome/browser/taskbar/taskbar_decorator_win.h"
 #include "chrome/browser/win/jumplist.h"
 #include "chrome/browser/win/jumplist_factory.h"
@@ -1351,6 +1352,8 @@ bool BrowserView::IsOnCurrentWorkspace() const {
   return chromeos::DesksHelper::Get(native_win)
       ->BelongsToActiveDesk(native_win);
 #elif BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return true;
   absl::optional<bool> on_current_workspace =
       native_win->GetHost()->on_current_workspace();
   base::UmaHistogramBoolean("Windows.OnCurrentWorkspaceCached",
diff --git a/chrome/browser/ui/views/frame/glass_browser_frame_view.cc b/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
index c8a6f00b17917..52204988d010a 100644
--- a/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
+++ b/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
@@ -12,6 +12,7 @@
 
 #include "base/trace_event/common/trace_event_common.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/app/chrome_dll_resource.h"
 #include "chrome/browser/themes/theme_properties.h"
@@ -155,6 +156,10 @@ bool GlassBrowserFrameView::HasVisibleBackgroundTabShapes(
     BrowserFrameActiveState active_state) const {
   DCHECK(GetWidget());
 
+  // Pre-Win 8, tabs never match the glass frame appearance.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return true;
+
   // Enabling high contrast mode disables the custom-drawn titlebar (so the
   // system-drawn frame will respect the native frame colors) and enables the
   // IncreasedContrastThemeSupplier (which does not respect the native frame
@@ -167,6 +172,15 @@ bool GlassBrowserFrameView::HasVisibleBackgroundTabShapes(
   return BrowserNonClientFrameView::HasVisibleBackgroundTabShapes(active_state);
 }
 
+bool GlassBrowserFrameView::CanDrawStrokes() const {
+  // On Win 7, the tabs are drawn as flat shapes against the glass frame, so
+  // the active tab always has a visible shape and strokes are unnecessary.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return false;
+
+  return BrowserNonClientFrameView::CanDrawStrokes();
+}
+
 SkColor GlassBrowserFrameView::GetCaptionColor(
     BrowserFrameActiveState active_state) const {
   return GetColorProvider()->GetColor(ShouldPaintAsActive(active_state)
@@ -287,39 +301,41 @@ int GlassBrowserFrameView::NonClientHitTest(const gfx::Point& point) {
     }
   }
 
-  // On Windows, the caption buttons are almost butted up to the top right
+  // On Windows 8+, the caption buttons are almost butted up to the top right
   // corner of the window. This code ensures the mouse isn't set to a size
   // cursor while hovering over the caption buttons, thus giving the incorrect
   // impression that the user can resize the window.
-  RECT button_bounds = {0};
-  if (SUCCEEDED(DwmGetWindowAttribute(views::HWNDForWidget(frame()),
-                                      DWMWA_CAPTION_BUTTON_BOUNDS,
-                                      &button_bounds, sizeof(button_bounds)))) {
-    gfx::RectF button_bounds_in_dips = gfx::ConvertRectToDips(
-        gfx::Rect(button_bounds), display::win::GetDPIScale());
-    // TODO(crbug.com/1131681): GetMirroredRect() requires an integer rect,
-    // but the size in DIPs may not be an integer with a fractional device
-    // scale factor. If we want to keep using integers, the choice to use
-    // ToFlooredRectDeprecated() seems to be doing the wrong thing given the
-    // comment below about insetting 1 DIP instead of 1 physical pixel. We
-    // should probably use ToEnclosedRect() and then we could have inset 1
-    // physical pixel here.
-    gfx::Rect buttons =
-        GetMirroredRect(gfx::ToFlooredRectDeprecated(button_bounds_in_dips));
-
-    // There is a small one-pixel strip right above the caption buttons in
-    // which the resize border "peeks" through.
-    constexpr int kCaptionButtonTopInset = 1;
-    // The sizing region at the window edge above the caption buttons is
-    // 1 px regardless of scale factor. If we inset by 1 before converting
-    // to DIPs, the precision loss might eliminate this region entirely. The
-    // best we can do is to inset after conversion. This guarantees we'll
-    // show the resize cursor when resizing is possible. The cost of which
-    // is also maybe showing it over the portion of the DIP that isn't the
-    // outermost pixel.
-    buttons.Inset(gfx::Insets::TLBR(kCaptionButtonTopInset, 0, 0, 0));
-    if (buttons.Contains(point)) {
-      return HTNOWHERE;
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    RECT button_bounds = {0};
+    if (SUCCEEDED(DwmGetWindowAttribute(views::HWNDForWidget(frame()),
+                                        DWMWA_CAPTION_BUTTON_BOUNDS,
+                                        &button_bounds,
+                                        sizeof(button_bounds)))) {
+      gfx::RectF button_bounds_in_dips = gfx::ConvertRectToDips(
+          gfx::Rect(button_bounds), display::win::GetDPIScale());
+      // TODO(crbug.com/1131681): GetMirroredRect() requires an integer rect,
+      // but the size in DIPs may not be an integer with a fractional device
+      // scale factor. If we want to keep using integers, the choice to use
+      // ToFlooredRectDeprecated() seems to be doing the wrong thing given the
+      // comment below about insetting 1 DIP instead of 1 physical pixel. We
+      // should probably use ToEnclosedRect() and then we could have inset 1
+      // physical pixel here.
+      gfx::Rect buttons =
+          GetMirroredRect(gfx::ToFlooredRectDeprecated(button_bounds_in_dips));
+
+      // There is a small one-pixel strip right above the caption buttons in
+      // which the resize border "peeks" through.
+      constexpr int kCaptionButtonTopInset = 1;
+      // The sizing region at the window edge above the caption buttons is
+      // 1 px regardless of scale factor. If we inset by 1 before converting
+      // to DIPs, the precision loss might eliminate this region entirely. The
+      // best we can do is to inset after conversion. This guarantees we'll
+      // show the resize cursor when resizing is possible. The cost of which
+      // is also maybe showing it over the portion of the DIP that isn't the
+      // outermost pixel.
+      buttons.Inset(gfx::Insets::TLBR(kCaptionButtonTopInset, 0, 0, 0));
+      if (buttons.Contains(point))
+        return HTNOWHERE;
     }
   }
 
diff --git a/chrome/browser/ui/views/frame/glass_browser_frame_view.h b/chrome/browser/ui/views/frame/glass_browser_frame_view.h
index a2e91b75d3665..abe8e6d103b8a 100644
--- a/chrome/browser/ui/views/frame/glass_browser_frame_view.h
+++ b/chrome/browser/ui/views/frame/glass_browser_frame_view.h
@@ -37,6 +37,7 @@ class GlassBrowserFrameView : public BrowserNonClientFrameView,
   int GetThemeBackgroundXInset() const override;
   bool HasVisibleBackgroundTabShapes(
       BrowserFrameActiveState active_state) const override;
+  bool CanDrawStrokes() const override;
   SkColor GetCaptionColor(BrowserFrameActiveState active_state) const override;
   void UpdateThrobber(bool running) override;
   gfx::Size GetMinimumSize() const override;
diff --git a/chrome/browser/ui/views/frame/minimize_button_metrics_win.cc b/chrome/browser/ui/views/frame/minimize_button_metrics_win.cc
index 7dc587a1ddbcf..0a7154017bbb5 100644
--- a/chrome/browser/ui/views/frame/minimize_button_metrics_win.cc
+++ b/chrome/browser/ui/views/frame/minimize_button_metrics_win.cc
@@ -4,20 +4,36 @@
 
 #include "chrome/browser/ui/views/frame/minimize_button_metrics_win.h"
 
-#include <dwmapi.h>
-
 #include "base/check.h"
 #include "base/i18n/rtl.h"
+#include "base/win/windows_version.h"
+#include "dwmapi.h"
+#include "ui/base/win/shell.h"
 #include "ui/display/win/screen_win.h"
 #include "ui/gfx/geometry/point.h"
 
 namespace {
 
-const int kButtonBoundsPositionOffset = 6;
+// These constants were determined by manually adding various offsets
+// until the identity switcher was placed at the same location as before.
+// When a new or updated OS version is released, a new constant may need
+// to be added to this list and GetDefaultButtonBoundsOffset() is updated.
+const int kWin7ButtonBoundsPositionOffset = 1;
+const int kWin8ButtonBoundsPositionOffset = 10;
+const int kWin10ButtonBoundsPositionOffset = 6;
 const int kInvalidOffset = static_cast<int>(0x80000000);
 
+using base::win::GetVersion;
 using display::win::ScreenWin;
 
+int GetDefaultButtonBoundsOffset() {
+  if (GetVersion() >= base::win::Version::WIN10)
+    return kWin10ButtonBoundsPositionOffset;
+  if (GetVersion() >= base::win::Version::WIN8)
+    return kWin8ButtonBoundsPositionOffset;
+  return kWin7ButtonBoundsPositionOffset;
+}
+
 }  // namespace
 
 // static
@@ -26,9 +42,14 @@ int MinimizeButtonMetrics::last_cached_minimize_button_x_delta_ = 0;
 // static
 int MinimizeButtonMetrics::button_bounds_position_offset_ = kInvalidOffset;
 
-MinimizeButtonMetrics::MinimizeButtonMetrics() = default;
+MinimizeButtonMetrics::MinimizeButtonMetrics()
+    : hwnd_(nullptr),
+      cached_minimize_button_x_delta_(last_cached_minimize_button_x_delta_),
+      was_activated_(false) {
+}
 
-MinimizeButtonMetrics::~MinimizeButtonMetrics() = default;
+MinimizeButtonMetrics::~MinimizeButtonMetrics() {
+}
 
 void MinimizeButtonMetrics::Init(HWND hwnd) {
   DCHECK(!hwnd_);
@@ -57,18 +78,16 @@ int MinimizeButtonMetrics::GetButtonBoundsPositionOffset(
     const RECT& button_bounds,
     const RECT& window_bounds) const {
   if (button_bounds_position_offset_ == kInvalidOffset) {
-    if (!was_activated_ || !IsWindowVisible(hwnd_)) {
-      return kButtonBoundsPositionOffset;
-    }
+    if (!was_activated_ || !IsWindowVisible(hwnd_))
+      return GetDefaultButtonBoundsOffset();
     TITLEBARINFOEX info = {0};
     info.cbSize = sizeof(info);
     SendMessage(hwnd_, WM_GETTITLEBARINFOEX, 0,
                 reinterpret_cast<LPARAM>(&info));
     if (info.rgrect[2].right == info.rgrect[2].left ||
         (info.rgstate[2] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN |
-                            STATE_SYSTEM_UNAVAILABLE))) {
-      return kButtonBoundsPositionOffset;
-    }
+                            STATE_SYSTEM_UNAVAILABLE)))
+      return GetDefaultButtonBoundsOffset();
     button_bounds_position_offset_ =
         info.rgrect[2].left - (button_bounds.left + window_bounds.left);
   }
@@ -138,11 +157,11 @@ int MinimizeButtonMetrics::GetMinimizeButtonOffsetX() const {
   // WM_NCACTIVATE (maybe it returns classic values?). In an attempt to return a
   // consistant value we cache the last value across instances and use it until
   // we get the activate.
-  if (was_activated_ || cached_minimize_button_x_delta_ == 0) {
+  if (was_activated_ || !ui::win::IsAeroGlassEnabled() ||
+      cached_minimize_button_x_delta_ == 0) {
     const int minimize_button_offset = GetAndCacheMinimizeButtonOffsetX();
-    if (minimize_button_offset > 0) {
+    if (minimize_button_offset > 0)
       return minimize_button_offset;
-    }
   }
 
   // If we fail to get the minimize button offset via the WM_GETTITLEBARINFOEX
diff --git a/chrome/browser/ui/views/frame/minimize_button_metrics_win.h b/chrome/browser/ui/views/frame/minimize_button_metrics_win.h
index 651b7bf6099e1..c378b7e510fe2 100644
--- a/chrome/browser/ui/views/frame/minimize_button_metrics_win.h
+++ b/chrome/browser/ui/views/frame/minimize_button_metrics_win.h
@@ -43,15 +43,14 @@ class MinimizeButtonMetrics {
 
   int GetMinimizeButtonOffsetForWindow() const;
 
-  HWND hwnd_ = nullptr;
+  HWND hwnd_;
 
   // Cached offset of the minimize button. If RTL this is the location of the
   // minimize button, if LTR this is the offset from the right edge of the
   // client area to the minimize button.
-  mutable int cached_minimize_button_x_delta_ =
-      last_cached_minimize_button_x_delta_;
+  mutable int cached_minimize_button_x_delta_;
 
-  // Static cache of `cached_minimize_button_x_delta_`.
+  // Static cache of |cached_minimize_button_x_delta_|.
   static int last_cached_minimize_button_x_delta_;
 
   // Static cache of offset value representing the difference between
@@ -59,7 +58,7 @@ class MinimizeButtonMetrics {
   static int button_bounds_position_offset_;
 
   // Has OnHWNDActivated() been invoked?
-  bool was_activated_ = false;
+  bool was_activated_;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_FRAME_MINIMIZE_BUTTON_METRICS_WIN_H_
diff --git a/chrome/browser/ui/views/infobars/confirm_infobar.cc b/chrome/browser/ui/views/infobars/confirm_infobar.cc
index f9aad327ec896..cabef56e58f2d 100644
--- a/chrome/browser/ui/views/infobars/confirm_infobar.cc
+++ b/chrome/browser/ui/views/infobars/confirm_infobar.cc
@@ -10,6 +10,7 @@
 #include "base/functional/bind.h"
 #include "build/build_config.h"
 #include "chrome/browser/ui/views/chrome_layout_provider.h"
+#include "chrome/browser/ui/views/elevation_icon_setter.h"
 #include "ui/base/window_open_disposition.h"
 #include "ui/views/controls/button/label_button.h"
 #include "ui/views/controls/button/md_text_button.h"
@@ -41,6 +42,11 @@ ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     ok_button_ = create_button(ConfirmInfoBarDelegate::BUTTON_OK,
                                &ConfirmInfoBar::OkButtonPressed);
     ok_button_->SetProminent(true);
+    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
+      elevation_icon_setter_ = std::make_unique<ElevationIconSetter>(
+          ok_button_,
+          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this)));
+    }
     ok_button_->SetImageModel(
         views::Button::STATE_NORMAL,
         delegate_ptr->GetButtonImage(ConfirmInfoBarDelegate::BUTTON_OK));
@@ -83,7 +89,10 @@ ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
   link_ = AddChildView(CreateLink(delegate_ptr->GetLinkText()));
 }
 
-ConfirmInfoBar::~ConfirmInfoBar() = default;
+ConfirmInfoBar::~ConfirmInfoBar() {
+  // Ensure |elevation_icon_setter_| is destroyed before |ok_button_|.
+  elevation_icon_setter_.reset();
+}
 
 void ConfirmInfoBar::Layout() {
   InfoBarView::Layout();
diff --git a/chrome/browser/ui/views/infobars/confirm_infobar.h b/chrome/browser/ui/views/infobars/confirm_infobar.h
index bceaa6485737e..bec67e3750519 100644
--- a/chrome/browser/ui/views/infobars/confirm_infobar.h
+++ b/chrome/browser/ui/views/infobars/confirm_infobar.h
@@ -9,6 +9,8 @@
 #include "chrome/browser/ui/views/infobars/infobar_view.h"
 #include "components/infobars/core/confirm_infobar_delegate.h"
 
+class ElevationIconSetter;
+
 namespace views {
 class Label;
 class MdTextButton;
@@ -51,6 +53,7 @@ class ConfirmInfoBar : public InfoBarView {
   raw_ptr<views::MdTextButton> cancel_button_ = nullptr;
   raw_ptr<views::MdTextButton> extra_button_ = nullptr;
   raw_ptr<views::Link> link_ = nullptr;
+  std::unique_ptr<ElevationIconSetter> elevation_icon_setter_;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_INFOBARS_CONFIRM_INFOBAR_H_
diff --git a/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.cc b/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.cc
index 3830ae2313909..46bb0e5536eea 100644
--- a/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.cc
+++ b/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.cc
@@ -8,7 +8,6 @@
 #include <cctype>
 #include <cwctype>
 #include <ios>
-#include <limits>
 #include <memory>
 #include <string>
 
@@ -26,6 +25,7 @@
 #include "chrome/browser/ui/tabs/tab_style.h"
 #include "chrome/browser/ui/thumbnails/thumbnail_image.h"
 #include "chrome/browser/ui/ui_features.h"
+#include "chrome/browser/ui/views/chrome_layout_provider.h"
 #include "chrome/browser/ui/views/chrome_typography.h"
 #include "chrome/browser/ui/views/tabs/tab.h"
 #include "chrome/browser/ui/views/tabs/tab_hover_card_controller.h"
@@ -64,6 +64,10 @@
 #include "ui/views/view_class_properties.h"
 #include "ui/views/widget/widget.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
+#endif
+
 namespace {
 
 // Maximum number of lines that a title label occupies.
@@ -77,6 +81,14 @@ constexpr auto kTitleMargins =
 constexpr auto kAlertMargins =
     gfx::Insets::VH(kFootnoteVerticalMargin, kHorizontalMargin);
 
+bool CustomShadowsSupported() {
+#if BUILDFLAG(IS_WIN)
+  return ui::win::IsAeroGlassEnabled();
+#else
+  return true;
+#endif
+}
+
 std::unique_ptr<views::Label> CreateAlertView(const TabAlertState& state) {
   auto alert_state_label = std::make_unique<views::Label>(
       std::u16string(), views::style::CONTEXT_DIALOG_BODY_TEXT,
@@ -734,6 +746,10 @@ TabHoverCardBubbleView::TabHoverCardBubbleView(Tab* tab)
     : BubbleDialogDelegateView(tab,
                                views::BubbleBorder::TOP_LEFT,
                                views::BubbleBorder::STANDARD_SHADOW) {
+  if (CustomShadowsSupported()) {
+    corner_radius_ = ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
+        views::Emphasis::kHigh);
+  }
   SetButtons(ui::DIALOG_BUTTON_NONE);
 
   // Remove the accessible role so that hover cards are not read when they
@@ -766,11 +782,13 @@ TabHoverCardBubbleView::TabHoverCardBubbleView(Tab* tab)
       thumbnail_view_ =
           AddChildViewAt(std::make_unique<ThumbnailView>(this), 0);
       thumbnail_view_->SetRoundedCorners(
-          ThumbnailView::RoundedCorners::kTopCorners, corner_radius_);
+          ThumbnailView::RoundedCorners::kTopCorners,
+          corner_radius_.value_or(0));
     } else {
       thumbnail_view_ = AddChildView(std::make_unique<ThumbnailView>(this));
       thumbnail_view_->SetRoundedCorners(
-          ThumbnailView::RoundedCorners::kBottomCorners, corner_radius_);
+          ThumbnailView::RoundedCorners::kBottomCorners,
+          corner_radius_.value_or(0));
     }
   }
 
@@ -822,7 +840,8 @@ TabHoverCardBubbleView::TabHoverCardBubbleView(Tab* tab)
       views::BubbleFrameView::PreferredArrowAdjustment::kOffset);
   GetBubbleFrameView()->set_hit_test_transparent(true);
 
-  GetBubbleFrameView()->SetCornerRadius(corner_radius_);
+  if (using_rounded_corners())
+    GetBubbleFrameView()->SetCornerRadius(corner_radius_.value());
 
   // Placeholder image should be used when there is no image data for the
   // given tab. Otherwise don't flash the placeholder while we wait for the
@@ -941,7 +960,7 @@ void TabHoverCardBubbleView::UpdateCardContent(const Tab* tab) {
                       ? ThumbnailView::RoundedCorners::kTopCorners
                       : ThumbnailView::RoundedCorners::kBottomCorners;
       }
-      thumbnail_view_->SetRoundedCorners(corners, corner_radius_);
+      thumbnail_view_->SetRoundedCorners(corners, corner_radius_.value_or(0));
     }
   }
 }
@@ -993,5 +1012,16 @@ gfx::Size TabHoverCardBubbleView::CalculatePreferredSize() const {
   return preferred_size;
 }
 
+void TabHoverCardBubbleView::OnThemeChanged() {
+  BubbleDialogDelegateView::OnThemeChanged();
+
+  // Bubble closes if the theme changes to the point where the border has to be
+  // regenerated. See crbug.com/1140256
+  if (using_rounded_corners() != CustomShadowsSupported()) {
+    GetWidget()->Close();
+    return;
+  }
+}
+
 BEGIN_METADATA(TabHoverCardBubbleView, views::BubbleDialogDelegateView)
 END_METADATA
diff --git a/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.h b/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.h
index c8c69f1236653..e2297c2305872 100644
--- a/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.h
+++ b/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.h
@@ -16,7 +16,6 @@
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/ui/tabs/tab_enums.h"
 #include "chrome/browser/ui/tabs/tab_utils.h"
-#include "chrome/browser/ui/views/chrome_layout_provider.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "ui/base/metadata/metadata_header_macros.h"
 #include "ui/gfx/animation/linear_animation.h"
@@ -143,16 +142,18 @@ class TabHoverCardBubbleView : public views::BubbleDialogDelegateView {
   class FadeLabel;
   class ThumbnailView;
 
+  bool using_rounded_corners() const { return corner_radius_.has_value(); }
+
   // views::BubbleDialogDelegateView:
   gfx::Size CalculatePreferredSize() const override;
+  void OnThemeChanged() override;
 
   raw_ptr<FadeLabel> title_label_ = nullptr;
   raw_ptr<FadeLabel> domain_label_ = nullptr;
   raw_ptr<ThumbnailView> thumbnail_view_ = nullptr;
   absl::optional<TabAlertState> alert_state_;
 
-  int corner_radius_ = ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
-      views::Emphasis::kHigh);
+  absl::optional<int> corner_radius_;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_TABS_TAB_HOVER_CARD_BUBBLE_VIEW_H_
diff --git a/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view_unittest.cc b/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view_unittest.cc
index c48261f31cb34..cbd4bd5b181ae 100644
--- a/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view_unittest.cc
+++ b/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view_unittest.cc
@@ -14,7 +14,9 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/render_text.h"
 
-#if BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#elif BUILDFLAG(IS_MAC)
 #include "base/mac/mac_util.h"
 #endif
 
@@ -26,8 +28,8 @@ namespace {
 //
 // Whether a single grapheme composed of multiple glyphs/codepoints correctly
 // displays on a system is dependent on the OS version and font. Some older OSes
-// do not support some of the more complex test graphemes we are using to test
-// elision at grapheme boundaries.
+// (specifically Win7) do not support some of the more complex test graphemes we
+// are using to test elision at grapheme boundaries.
 //
 // On systems which do not support a glyph or grapheme, a multi-codepoint
 // grapheme may appear as multiple glyphs. It's therefore possible for a test
@@ -37,6 +39,7 @@ namespace {
 // cases on systems we know do not support them.
 enum OmitOnPlatforms {
   kRunOnAllPlatforms = 0,
+  kOmitOnWin7 = 1 << 0,
 
   // TODO(crbug/1267013): Remove once emoji (including modified/joined emoji)
   // are supported on Fuchsia.
@@ -44,7 +47,12 @@ enum OmitOnPlatforms {
 };
 
 bool ShouldOmitOnPlatform(int omit_on) {
-#if BUILDFLAG(IS_FUCHSIA)
+#if BUILDFLAG(IS_WIN)
+  if (omit_on & kOmitOnWin7) {
+    return base::win::OSInfo::GetInstance()->version() <=
+           base::win::Version::WIN7;
+  }
+#elif BUILDFLAG(IS_FUCHSIA)
   if (omit_on & kOmitOnFuchsia)
     return true;
 #endif
@@ -284,28 +292,28 @@ const ElideTestParams kElideTestParams[]{
      "Two-character emoji fully elided between lines."},
     {u"abc" MAN_EMOJI MEDIUM_SKIN_TONE_MODIFIER u"efg", 4, 7, 3,
      u"abc" MAN_EMOJI MEDIUM_SKIN_TONE_MODIFIER u"\nefg",
-     "First line ends with modified emoji.", kOmitOnFuchsia},
+     "First line ends with modified emoji.", kOmitOnWin7 | kOmitOnFuchsia},
     {u"abc" MAN_EMOJI MEDIUM_SKIN_TONE_MODIFIER u"efg", 3, 3, 2,
      ELLIPSIZE(u"abc", u"fg"), "Modified emoji fully elided between lines."},
     {u"abc" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"efg", 4, 10, 3,
      u"abc" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"\nefg",
      "First line ends with joined emoji, full string returned.",
-     kOmitOnFuchsia},
+     kOmitOnWin7 | kOmitOnFuchsia},
     {u"abc" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"efgh", 4, 10, 3,
      ELLIPSIZE(u"abc" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE, u"fgh"),
      "First line ends with joined emoji, string cut in middle (1).",
-     kOmitOnFuchsia},
+     kOmitOnWin7 | kOmitOnFuchsia},
     {u"abc" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"defghi", 5, 11, 4,
      ELLIPSIZE(u"abc" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"d", u"fghi"),
      "First line ends with joined emoji, string cut in middle (2).",
-     kOmitOnFuchsia},
+     kOmitOnWin7 | kOmitOnFuchsia},
     {u"abc" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"efg", 3, 3, 2,
      ELLIPSIZE(u"abc", u"fg"), "Joined emoji fully elided between lines."},
     {u"abcde" MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE
          MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"fg",
      4, 4, 9, ELLIPSIZE(u"abcd", MALE_HEALTH_WORKER_MEDIUM_SKIN_TONE u"fg"),
      "Joined emoji in sequence; first emoji is elided but not second.",
-     kOmitOnFuchsia},
+     kOmitOnWin7 | kOmitOnFuchsia},
     // These test the combined function of the Elide() method, including the
     // intelligent overlapping and positioning of lines and extensions.
     {u"abcdef", 5, 5, 4, u"abcde\nf", "Wrap at last possible location."},
diff --git a/chrome/browser/ui/views/tabs/tab_strip.cc b/chrome/browser/ui/views/tabs/tab_strip.cc
index 5aed267573ab4..75f7d32d8e9ed 100644
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -6,7 +6,6 @@
 
 #include <stddef.h>
 
-#include <algorithm>
 #include <iterator>
 #include <limits>
 #include <memory>
@@ -108,6 +107,7 @@
 #include "ui/views/window/non_client_view.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "ui/display/win/screen_win.h"
 #include "ui/gfx/win/hwnd_util.h"
 #include "ui/views/win/hwnd_util.h"
@@ -1915,10 +1915,12 @@ bool TabStrip::ShouldHighlightCloseButtonAfterRemove() {
 
 bool TabStrip::TitlebarBackgroundIsTransparent() const {
 #if BUILDFLAG(IS_WIN)
-  return false;
-#else
+  // Windows 8+ uses transparent window contents (because the titlebar area is
+  // drawn by the system and not Chrome), but the actual titlebar is opaque.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    return false;
+#endif
   return GetWidget()->ShouldWindowContentsBeTransparent();
-#endif  // BUILDFLAG(IS_WIN)
 }
 
 int TabStrip::GetActiveTabWidth() const {
diff --git a/chrome/browser/ui/views/toolbar/toolbar_action_hover_card_bubble_view.cc b/chrome/browser/ui/views/toolbar/toolbar_action_hover_card_bubble_view.cc
index 8740c85f95d28..f6e4c45656aa1 100644
--- a/chrome/browser/ui/views/toolbar/toolbar_action_hover_card_bubble_view.cc
+++ b/chrome/browser/ui/views/toolbar/toolbar_action_hover_card_bubble_view.cc
@@ -25,6 +25,10 @@
 #include "ui/views/layout/fill_layout.h"
 #include "ui/views/layout/flex_layout.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
+#endif
+
 namespace {
 
 using HoverCardState = ToolbarActionViewController::HoverCardState;
@@ -39,6 +43,14 @@ constexpr int kHoverCardWidth = 240;
 constexpr int kHorizontalMargin = 18;
 constexpr int kVerticalMargin = 10;
 
+bool CustomShadowsSupported() {
+#if BUILDFLAG(IS_WIN)
+  return ui::win::IsAeroGlassEnabled();
+#else
+  return true;
+#endif
+}
+
 std::u16string GetSiteAccessTitle(
     ToolbarActionViewController::HoverCardState::SiteAccess state) {
   int title_id = -1;
@@ -269,8 +281,10 @@ ToolbarActionHoverCardBubbleView::ToolbarActionHoverCardBubbleView(
   layout->SetCrossAxisAlignment(views::LayoutAlignment::kStretch);
   layout->SetCollapseMargins(true);
 
-  corner_radius_ = ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
-      views::Emphasis::kHigh);
+  if (CustomShadowsSupported()) {
+    corner_radius_ = ChromeLayoutProvider::Get()->GetCornerRadiusMetric(
+        views::Emphasis::kHigh);
+  }
 
   // Set up content.
   auto create_label = [](int context, gfx::Insets insets) {
@@ -388,7 +402,7 @@ void ToolbarActionHoverCardBubbleView::OnThemeChanged() {
 
   // Bubble closes if the theme changes to the point where the border has to be
   // regenerated. See crbug.com/1140256
-  if (!using_rounded_corners()) {
+  if (using_rounded_corners() != CustomShadowsSupported()) {
     GetWidget()->Close();
     return;
   }
diff --git a/chrome/browser/ui/views/tooltip/tooltip_browsertest.cc b/chrome/browser/ui/views/tooltip/tooltip_browsertest.cc
index 5c6e896b6792f..dadea94aedd8c 100644
--- a/chrome/browser/ui/views/tooltip/tooltip_browsertest.cc
+++ b/chrome/browser/ui/views/tooltip/tooltip_browsertest.cc
@@ -6,6 +6,8 @@
 #include "base/run_loop.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/test_simple_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_window.h"
@@ -190,6 +192,28 @@ class TooltipBrowserTest : public InProcessBrowserTest {
     return ChildFrameAt(web_contents_->GetPrimaryMainFrame(), index);
   }
 
+  bool SkipTestForOldWinVersion() const {
+#if BUILDFLAG(IS_WIN)
+    // On older Windows version, tooltips are displayed with TooltipWin instead
+    // of TooltipAura. For TooltipAura, a tooltip is displayed using a Widget
+    // and a Label and for TooltipWin, it is displayed using a native win32
+    // control. Since the observer we use in this class is the
+    // AnyWidgetObserver, we don't receive any update from non-Widget tooltips.
+    // This doesn't mean that no tooltip is displayed on older platforms, but
+    // that we are unable to execute the browser test successfully because the
+    // tooltip displayed is not displayed using a Widget.
+    //
+    // For now, we can simply skip the tests on older platforms, but it might be
+    // a good idea to eventually implement a custom observer (e.g.,
+    // TooltipStateObserver) that would work for both TooltipAura and
+    // TooltipWin, or remove once and for all TooltipWin. For more information
+    // on why we still need TooltipWin on Win7, see https://crbug.com/1201440.
+    if (base::win::GetVersion() <= base::win::Version::WIN7)
+      return true;
+#endif  // BUILDFLAG(IS_WIN)
+    return false;
+  }
+
   gfx::Point WebContentPositionToScreenCoordinate(int x, int y) {
     return gfx::Point(x, y) + rwhv_->GetViewBounds().OffsetFromOrigin();
   }
@@ -218,6 +242,9 @@ class TooltipBrowserTest : public InProcessBrowserTest {
 
 IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
                        ShowTooltipFromWebContentWithCursor) {
+  if (SkipTestForOldWinVersion())
+    return;
+
   NavigateToURL("/tooltip.html");
   std::u16string expected_text = u"my tooltip";
 
@@ -252,6 +279,9 @@ IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
                        MAYBE_ShowTooltipFromWebContentWithKeyboard) {
+  if (SkipTestForOldWinVersion())
+    return;
+
   NavigateToURL("/tooltip.html");
   std::u16string expected_text = u"my tooltip";
 
@@ -278,6 +308,9 @@ IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
                        MAYBE_ShowTooltipFromIFrameWithKeyboard) {
+  if (SkipTestForOldWinVersion())
+    return;
+
   // There are two tooltips in this file: one above the iframe and one inside
   // the iframe.
   NavigateToURL("/tooltip_in_iframe.html");
@@ -328,6 +361,9 @@ IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
                        MAYBE_HideTooltipOnKeyPressTriggeredByCursor) {
+  if (SkipTestForOldWinVersion())
+    return;
+
   NavigateToURL("/tooltip.html");
   std::u16string expected_text = u"my tooltip";
 
@@ -364,6 +400,10 @@ IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
                        MAYBE_HideTooltipOnKeyPressTriggeredByKeyboard) {
+  if (SkipTestForOldWinVersion()) {
+    return;
+  }
+
   NavigateToURL("/tooltip.html");
   std::u16string expected_text = u"my tooltip";
 
@@ -394,6 +434,9 @@ IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(TooltipBrowserTest,
                        MAYBE_ScriptFocusHidesKeyboardTriggeredTooltip) {
+  if (SkipTestForOldWinVersion())
+    return;
+
   NavigateToURL("/tooltip_two_buttons.html");
   std::u16string expected_text_1 = u"my tooltip 1";
   std::u16string expected_text_2 = u"my tooltip 2";
diff --git a/chrome/browser/ui/views/touch_events_interactive_uitest_win.cc b/chrome/browser/ui/views/touch_events_interactive_uitest_win.cc
index 3f51e7f32d193..3eae80d50857e 100644
--- a/chrome/browser/ui/views/touch_events_interactive_uitest_win.cc
+++ b/chrome/browser/ui/views/touch_events_interactive_uitest_win.cc
@@ -4,6 +4,7 @@
 
 #include "base/memory/raw_ptr.h"
 #include "base/run_loop.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "chrome/browser/ui/views/test/view_event_test_base.h"
 #include "chrome/test/base/testing_profile.h"
@@ -161,6 +162,13 @@ class TouchEventsViewTest : public ViewEventTestBase {
   }
 
   void DoTestOnMessageLoop() override {
+    // ui_controls::SendTouchEvents which uses InjectTouchInput API only works
+    // on Windows 8 and up.
+    if (base::win::GetVersion() <= base::win::Version::WIN7) {
+      Done();
+      return;
+    }
+
     const int touch_pointer_count = 3;
     TouchEventHandler touch_event_handler;
     window()->GetNativeWindow()->GetHost()->window()->AddPreTargetHandler(
@@ -211,6 +219,13 @@ class TouchEventsRecursiveViewTest : public TouchEventsViewTest {
       delete;
 
   void DoTestOnMessageLoop() override {
+    // ui_controls::SendTouchEvents which uses InjectTouchInput API only works
+    // on Windows 8 and up.
+    if (base::win::GetVersion() <= base::win::Version::WIN7) {
+      Done();
+      return;
+    }
+
     const int touch_pointer_count = 1;
     TouchEventHandler touch_event_handler;
     window()->GetNativeWindow()->GetHost()->window()->AddPreTargetHandler(
diff --git a/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_navigation_button_container.cc b/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_navigation_button_container.cc
index 9dd6c23fa5915..aa5650fe51a44 100644
--- a/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_navigation_button_container.cc
+++ b/chrome/browser/ui/views/web_apps/frame_toolbar/web_app_navigation_button_container.cc
@@ -4,9 +4,6 @@
 
 #include "chrome/browser/ui/views/web_apps/frame_toolbar/web_app_navigation_button_container.h"
 
-#include <memory>
-#include <utility>
-
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/app/chrome_command_ids.h"
@@ -29,6 +26,10 @@
 #include "ui/views/layout/box_layout.h"
 #include "ui/views/window/hit_test_utils.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace {
 
 constexpr int kPaddingBetweenNavigationButtons = 5;
@@ -47,6 +48,12 @@ class WebAppToolbarButton : public BaseClass {
   WebAppToolbarButton& operator=(const WebAppToolbarButton&) = delete;
   ~WebAppToolbarButton() override = default;
 
+#if BUILDFLAG(IS_WIN)
+  bool ShouldUseWindowsIconsForMinimalUI() const {
+    return base::win::GetVersion() >= base::win::Version::WIN10;
+  }
+#endif
+
   void SetIconColor(SkColor icon_color) {
     if (icon_color_ == icon_color)
       return;
@@ -101,11 +108,13 @@ WebAppToolbarBackButton::WebAppToolbarBackButton(PressedCallback callback,
 
 const gfx::VectorIcon* WebAppToolbarBackButton::GetAlternativeIcon() const {
 #if BUILDFLAG(IS_WIN)
-  return ui::TouchUiController::Get()->touch_ui() ? &kBackArrowWindowsTouchIcon
-                                                  : &kBackArrowWindowsIcon;
-#else
+  if (ShouldUseWindowsIconsForMinimalUI()) {
+    return ui::TouchUiController::Get()->touch_ui()
+               ? &kBackArrowWindowsTouchIcon
+               : &kBackArrowWindowsIcon;
+  }
+#endif
   return nullptr;
-#endif  // BUILDFLAG(IS_WIN)
 }
 
 BEGIN_METADATA(WebAppToolbarBackButton, BackForwardButton)
@@ -126,15 +135,16 @@ class WebAppToolbarReloadButton : public WebAppToolbarButton<ReloadButton> {
 
 const gfx::VectorIcon* WebAppToolbarReloadButton::GetAlternativeIcon() const {
 #if BUILDFLAG(IS_WIN)
-  const bool is_reload = visible_mode() == ReloadButton::Mode::kReload;
-  if (ui::TouchUiController::Get()->touch_ui()) {
-    return is_reload ? &kReloadWindowsTouchIcon
-                     : &kNavigateStopWindowsTouchIcon;
+  if (ShouldUseWindowsIconsForMinimalUI()) {
+    const bool is_reload = visible_mode() == ReloadButton::Mode::kReload;
+    if (ui::TouchUiController::Get()->touch_ui()) {
+      return is_reload ? &kReloadWindowsTouchIcon
+                       : &kNavigateStopWindowsTouchIcon;
+    }
+    return is_reload ? &kReloadWindowsIcon : &kNavigateStopWindowsIcon;
   }
-  return is_reload ? &kReloadWindowsIcon : &kNavigateStopWindowsIcon;
-#else
+#endif
   return nullptr;
-#endif  // BUILDFLAG(IS_WIN)
 }
 
 BEGIN_METADATA(WebAppToolbarReloadButton, ReloadButton)
diff --git a/chrome/browser/ui/webui/app_management/app_management_page_handler.cc b/chrome/browser/ui/webui/app_management/app_management_page_handler.cc
index 24b1e565022e0..e76d5673451d9 100644
--- a/chrome/browser/ui/webui/app_management/app_management_page_handler.cc
+++ b/chrome/browser/ui/webui/app_management/app_management_page_handler.cc
@@ -4,9 +4,6 @@
 
 #include "chrome/browser/ui/webui/app_management/app_management_page_handler.h"
 
-#include <memory>
-#include <set>
-#include <string>
 #include <utility>
 #include <vector>
 
@@ -114,7 +111,7 @@ bool ShouldHideStoragePermission(const std::string app_id) {
 // will be shown instead.
 bool CanShowDefaultAppAssociationsUi() {
 #if BUILDFLAG(IS_WIN)
-  return true;
+  return base::win::CanLaunchDefaultAppsSettingsModernDialog();
 #else
   return false;
 #endif
diff --git a/chrome/browser/ui/webui/conflicts/conflicts_data_fetcher.cc b/chrome/browser/ui/webui/conflicts/conflicts_data_fetcher.cc
index df34ffb57fcde..0c42663044803 100644
--- a/chrome/browser/ui/webui/conflicts/conflicts_data_fetcher.cc
+++ b/chrome/browser/ui/webui/conflicts/conflicts_data_fetcher.cc
@@ -8,6 +8,7 @@
 #include <utility>
 
 #include "base/strings/string_util.h"
+#include "base/win/windows_version.h"
 #include "build/branding_buildflags.h"
 #include "chrome/browser/win/conflicts/module_database.h"
 #include "content/public/browser/browser_task_traits.h"
@@ -264,6 +265,10 @@ ThirdPartyFeaturesStatus GetThirdPartyFeaturesStatus(
     }
   }
 
+  // Figure out why the manager instance doesn't exist.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return kNotAvailableWin7;
+
   if (!ModuleDatabase::IsThirdPartyBlockingPolicyEnabled())
     return kPolicyDisabled;
 
@@ -294,6 +299,9 @@ std::string GetThirdPartyFeaturesStatusString(ThirdPartyFeaturesStatus status) {
     case ThirdPartyFeaturesStatus::kPolicyDisabled:
       return "The ThirdPartyBlockingEnabled group policy is disabled.";
     case ThirdPartyFeaturesStatus::kFeatureDisabled:
+      if (base::win::GetVersion() < base::win::Version::WIN10)
+        return "The ThirdPartyModulesBlocking feature is disabled.";
+
       return "Both the IncompatibleApplicationsWarning and "
              "ThirdPartyModulesBlocking features are disabled.";
     case ThirdPartyFeaturesStatus::kModuleListInvalid:
@@ -301,12 +309,17 @@ std::string GetThirdPartyFeaturesStatusString(ThirdPartyFeaturesStatus status) {
     case ThirdPartyFeaturesStatus::kNoModuleListAvailable:
       return "Disabled - There is no Module List version available.";
     case ThirdPartyFeaturesStatus::kWarningInitialized:
+      DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
       return "The IncompatibleApplicationsWarning feature is enabled, while "
              "the ThirdPartyModulesBlocking feature is disabled.";
     case ThirdPartyFeaturesStatus::kBlockingInitialized:
+      if (base::win::GetVersion() < base::win::Version::WIN10)
+        return "The ThirdPartyModulesBlocking feature is enabled.";
+
       return "The ThirdPartyModulesBlocking feature is enabled, while the "
              "IncompatibleApplicationsWarning feature is disabled.";
     case ThirdPartyFeaturesStatus::kWarningAndBlockingInitialized:
+      DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
       return "Both the IncompatibleApplicationsWarning and "
              "ThirdPartyModulesBlocking features are enabled";
   }
@@ -464,7 +477,7 @@ void ConflictsDataFetcher::OnModuleDatabaseIdle() {
   ModuleDatabase::GetInstance()->RemoveObserver(this);
 
   base::Value::Dict results;
-  results.Set("moduleCount", static_cast<int>(module_list_->size()));
+  results.Set("moduleCount", int(module_list_->size()));
   results.Set("moduleList", std::move(*module_list_));
   module_list_ = absl::nullopt;
 
diff --git a/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc b/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
index 9530d18582823..3906296839f4d 100644
--- a/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
+++ b/chrome/browser/ui/webui/settings/settings_localized_strings_provider.cc
@@ -130,6 +130,7 @@
 #endif
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "chrome/browser/safe_browsing/chrome_cleaner/srt_field_trial_win.h"
 #include "device/fido/win/webauthn_api.h"
 
@@ -268,7 +269,8 @@ void AddA11yStrings(content::WebUIDataSource* html_source) {
   html_source->AddLocalizedStrings(kLocalizedStrings);
 
 #if BUILDFLAG(IS_WIN)
-  html_source->AddBoolean("isWindows10OrNewer", true);
+  html_source->AddBoolean("isWindows10OrNewer",
+                          base::win::GetVersion() >= base::win::Version::WIN10);
 #endif
 
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
diff --git a/chrome/browser/ui/webui/settings/settings_utils_win.cc b/chrome/browser/ui/webui/settings/settings_utils_win.cc
index c39f0509e7d3d..9a662c5006cd8 100644
--- a/chrome/browser/ui/webui/settings/settings_utils_win.cc
+++ b/chrome/browser/ui/webui/settings/settings_utils_win.cc
@@ -14,6 +14,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/thread_pool.h"
 #include "base/threading/thread.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/platform_util.h"
 #include "chrome/browser/profiles/profile.h"
@@ -30,7 +31,7 @@ namespace {
 // Shows a Windows certificate management dialog on the dialog thread.
 class ManageCertificatesDialog : public ui::BaseShellDialogImpl {
  public:
-  ManageCertificatesDialog() = default;
+  ManageCertificatesDialog() {}
 
   ManageCertificatesDialog(const ManageCertificatesDialog&) = delete;
   ManageCertificatesDialog& operator=(const ManageCertificatesDialog&) = delete;
@@ -102,9 +103,15 @@ void OpenConnectionDialogCallback() {
 }
 
 void ShowNetworkProxySettings(content::WebContents* /*web_contents*/) {
-  // See
-  // https://docs.microsoft.com/en-us/windows/uwp/launch-resume/launch-settings-app#network--internet
-  platform_util::OpenExternal(GURL("ms-settings:network-proxy"));
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    // See
+    // https://docs.microsoft.com/en-us/windows/uwp/launch-resume/launch-settings-app#network--internet
+    platform_util::OpenExternal(GURL("ms-settings:network-proxy"));
+  } else {
+    base::ThreadPool::PostTask(
+        FROM_HERE, {base::TaskPriority::USER_VISIBLE, base::MayBlock()},
+        base::BindOnce(&OpenConnectionDialogCallback));
+  }
 }
 
 void ShowManageSSLCertificates(content::WebContents* web_contents) {
diff --git a/chrome/browser/ui/webui/welcome/welcome_ui.cc b/chrome/browser/ui/webui/welcome/welcome_ui.cc
index 127ebef173671..2df0eb9cd5be0 100644
--- a/chrome/browser/ui/webui/welcome/welcome_ui.cc
+++ b/chrome/browser/ui/webui/welcome/welcome_ui.cc
@@ -30,6 +30,10 @@
 #include "net/base/url_util.h"
 #include "ui/base/webui/web_ui_util.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace {
 
 const char kPreviewBackgroundPath[] = "preview-background.jpg";
@@ -141,7 +145,8 @@ WelcomeUI::WelcomeUI(content::WebUI* web_ui, const GURL& url)
 #endif
 
 #if BUILDFLAG(IS_WIN)
-  html_source->AddBoolean("is_win10", true);
+  html_source->AddBoolean("is_win10",
+                          base::win::GetVersion() >= base::win::Version::WIN10);
 #endif
 
   // Add the shared bookmark handler for welcome modules.
diff --git a/chrome/browser/vr/test/gl_test_environment_unittest.cc b/chrome/browser/vr/test/gl_test_environment_unittest.cc
index cc6b29d1407e4..c3a7e7b9430d9 100644
--- a/chrome/browser/vr/test/gl_test_environment_unittest.cc
+++ b/chrome/browser/vr/test/gl_test_environment_unittest.cc
@@ -7,6 +7,10 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/geometry/size.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace vr {
 
 // TODO(crbug.com/1394319): Re-enable this test on MSAN if not removed.
@@ -19,6 +23,11 @@ namespace vr {
 #define MAYBE_InitializeAndCleanup InitializeAndCleanup
 #endif
 TEST(GlTestEnvironmentTest, MAYBE_InitializeAndCleanup) {
+#if BUILDFLAG(IS_WIN)
+  // VR is not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+#endif
   GlTestEnvironment gl_test_environment(gfx::Size(100, 100));
   EXPECT_NE(gl_test_environment.GetFrameBufferForTesting(), 0u);
   EXPECT_EQ(glGetError(), (GLenum)GL_NO_ERROR);
diff --git a/chrome/browser/web_applications/os_integration/os_integration_manager.cc b/chrome/browser/web_applications/os_integration/os_integration_manager.cc
index d3f953f8b3935..a297453eb948c 100644
--- a/chrome/browser/web_applications/os_integration/os_integration_manager.cc
+++ b/chrome/browser/web_applications/os_integration/os_integration_manager.cc
@@ -48,6 +48,10 @@
 #include "chrome/browser/web_applications/app_shim_registry_mac.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace {
 bool g_suppress_os_hooks_for_testing_ = false;
 }  // namespace
@@ -529,6 +533,16 @@ void OsIntegrationManager::RegisterFileHandlers(const AppId& app_id,
 
 void OsIntegrationManager::RegisterProtocolHandlers(const AppId& app_id,
                                                     ResultCallback callback) {
+  // Disable protocol handler unregistration on Win7 due to bad interactions
+  // between preinstalled app scenarios and the need for elevation to unregister
+  // protocol handlers on that platform. See crbug.com/1224327 for context.
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    std::move(callback).Run(Result::kOk);
+    return;
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   if (!protocol_handler_manager_) {
     std::move(callback).Run(Result::kOk);
     return;
@@ -680,6 +694,16 @@ void OsIntegrationManager::UnregisterFileHandlers(const AppId& app_id,
 
 void OsIntegrationManager::UnregisterProtocolHandlers(const AppId& app_id,
                                                       ResultCallback callback) {
+  // Disable protocol handler unregistration on Win7 due to bad interactions
+  // between preinstalled app scenarios and the need for elevation to unregister
+  // protocol handlers on that platform. See crbug.com/1224327 for context.
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    std::move(callback).Run(Result::kOk);
+    return;
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   if (!protocol_handler_manager_) {
     std::move(callback).Run(Result::kOk);
     return;
@@ -825,6 +849,16 @@ void OsIntegrationManager::UpdateProtocolHandlers(
     return;
   }
 
+  // Disable protocol handler unregistration on Win7 due to bad interactions
+  // between preinstalled app scenarios and the need for elevation to unregister
+  // protocol handlers on that platform. See crbug.com/1224327 for context.
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    std::move(callback).Run();
+    return;
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   auto shortcuts_callback = base::BindOnce(
       &OsIntegrationManager::OnShortcutsUpdatedForProtocolHandlers,
       weak_ptr_factory_.GetWeakPtr(), app_id, std::move(callback));
diff --git a/chrome/browser/web_applications/os_integration/os_integration_manager_unittest.cc b/chrome/browser/web_applications/os_integration/os_integration_manager_unittest.cc
index d22ef2cd1fe2f..f7e53f615c29b 100644
--- a/chrome/browser/web_applications/os_integration/os_integration_manager_unittest.cc
+++ b/chrome/browser/web_applications/os_integration/os_integration_manager_unittest.cc
@@ -24,6 +24,10 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/common/features.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace web_app {
 namespace {
 
@@ -189,6 +193,12 @@ TEST_F(OsIntegrationManagerTest, UninstallOsHooksEverything) {
 }
 
 TEST_F(OsIntegrationManagerTest, UpdateProtocolHandlers) {
+#if BUILDFLAG(IS_WIN)
+  // UpdateProtocolHandlers is a no-op on Win7
+  if (base::win::GetVersion() == base::win::Version::WIN7)
+    return;
+#endif
+
   const AppId app_id = "test";
   testing::StrictMock<MockOsIntegrationManager> manager(
       std::make_unique<WebAppProtocolHandlerManager>(nullptr));
diff --git a/chrome/browser/web_applications/os_integration/protocol_handling_sub_manager.cc b/chrome/browser/web_applications/os_integration/protocol_handling_sub_manager.cc
index 80e6166874393..ff16c5c80435f 100644
--- a/chrome/browser/web_applications/os_integration/protocol_handling_sub_manager.cc
+++ b/chrome/browser/web_applications/os_integration/protocol_handling_sub_manager.cc
@@ -5,7 +5,6 @@
 #include "chrome/browser/web_applications/os_integration/protocol_handling_sub_manager.h"
 
 #include <memory>
-#include <string>
 #include <utility>
 #include <vector>
 
@@ -23,6 +22,10 @@
 #include "components/services/app_service/public/cpp/protocol_handler_info.h"
 #include "url/gurl.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace web_app {
 
 namespace {
@@ -57,7 +60,18 @@ void ProtocolHandlingSubManager::Configure(
     const AppId& app_id,
     proto::WebAppOsIntegrationState& desired_state,
     base::OnceClosure configure_done) {
+  // Disable protocol handler unregistration on Win7 due to bad interactions
+  // between preinstalled app scenarios and the need for elevation to unregister
+  // protocol handlers on that platform. See crbug.com/1224327 for context.
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    std::move(configure_done).Run();
+    return;
+  }
+#endif
+
   DCHECK(!desired_state.has_protocols_handled());
+
   if (!registrar_->IsLocallyInstalled(app_id)) {
     std::move(configure_done).Run();
     return;
diff --git a/chrome/browser/web_applications/os_integration/web_app_file_handler_registration_win_unittest.cc b/chrome/browser/web_applications/os_integration/web_app_file_handler_registration_win_unittest.cc
index 514143ce2a6ed..5d2bfdfd00fd5 100644
--- a/chrome/browser/web_applications/os_integration/web_app_file_handler_registration_win_unittest.cc
+++ b/chrome/browser/web_applications/os_integration/web_app_file_handler_registration_win_unittest.cc
@@ -18,6 +18,7 @@
 #include "base/test/bind.h"
 #include "base/test/test_reg_util_win.h"
 #include "base/test/test_timeouts.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_attributes_storage.h"
 #include "chrome/browser/profiles/profile_manager.h"
@@ -151,8 +152,10 @@ class WebAppFileHandlerRegistrationWinTest : public testing::Test {
       const std::string& sanitized_app_name) {
     base::FilePath app_specific_launcher_filepath(
         base::ASCIIToWide(sanitized_app_name));
-    app_specific_launcher_filepath =
-        app_specific_launcher_filepath.AddExtension(L"exe");
+    if (base::win::GetVersion() > base::win::Version::WIN7) {
+      app_specific_launcher_filepath =
+          app_specific_launcher_filepath.AddExtension(L"exe");
+    }
     return app_specific_launcher_filepath;
   }
 
diff --git a/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win.cc b/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win.cc
index b8e8b6a036b1a..d9396784c9b9b 100644
--- a/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win.cc
+++ b/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win.cc
@@ -4,9 +4,6 @@
 
 #include "chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win.h"
 
-#include <utility>
-#include <vector>
-
 #include "base/command_line.h"
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
@@ -15,6 +12,7 @@
 #include "base/strings/string_util.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/task/thread_pool.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_attributes_entry.h"
@@ -156,10 +154,10 @@ std::wstring GetProgId(const base::FilePath& profile_path,
     // Provided file extensions must have a leading period. This is enforced
     // to ensure that calls to this function have consistent syntax (and
     // therefore get the same prog_id for a given set of inputs).
-    DCHECK_EQ(iter->at(0), '.');
+    DCHECK(iter->at(0) == '.');
     string_to_hash += *iter;
     while (++iter != file_extensions->end()) {
-      DCHECK_EQ(iter->at(0), '.');
+      DCHECK(iter->at(0) == '.');
       string_to_hash += ";";
       string_to_hash += *iter;
     }
@@ -201,6 +199,15 @@ base::FilePath GetAppSpecificLauncherFilename(const std::wstring& app_name) {
   base::FilePath::StringType sanitized_app_name =
       internals::GetSanitizedFileName(base::AsString16(app_name)).value();
 
+  // On Windows 7, where the launcher has no file extension, replace any '.'
+  // characters with '_' to prevent a portion of the filename from being
+  // interpreted as its extension.
+  const bool is_win_7 = base::win::GetVersion() == base::win::Version::WIN7;
+  if (is_win_7) {
+    base::ReplaceChars(sanitized_app_name, FILE_PATH_LITERAL("."),
+                       FILE_PATH_LITERAL("_"), &sanitized_app_name);
+  }
+
   // If |sanitized_app_name| is a reserved filename, prepend '_' to allow its
   // use as the launcher filename (e.g. "nul" => "_nul"). Prepending is
   // preferred over appending in order to handle filenames containing '.', as
@@ -210,9 +217,14 @@ base::FilePath GetAppSpecificLauncherFilename(const std::wstring& app_name) {
   if (net::IsReservedNameOnWindows(sanitized_app_name))
     sanitized_app_name.insert(0, 1, FILE_PATH_LITERAL('_'));
 
-  // Add .exe extension.
-  return base::FilePath(sanitized_app_name)
-      .AddExtension(FILE_PATH_LITERAL("exe"));
+  // On Windows 8+, add .exe extension. On Windows 7, where an app's display
+  // name in the Open With menu can't be set programmatically, omit the
+  // extension to use the launcher filename as the app's display name.
+  if (!is_win_7) {
+    return base::FilePath(sanitized_app_name)
+        .AddExtension(FILE_PATH_LITERAL("exe"));
+  }
+  return base::FilePath(sanitized_app_name);
 }
 
 // See https://docs.microsoft.com/en-us/windows/win32/com/-progid--key for
diff --git a/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win_unittest.cc b/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win_unittest.cc
index 775338394fc20..75324da9ca2ab 100644
--- a/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win_unittest.cc
+++ b/chrome/browser/web_applications/os_integration/web_app_handler_registration_utils_win_unittest.cc
@@ -6,6 +6,7 @@
 
 #include <memory>
 
+#include "base/callback_helpers.h"
 #include "base/files/file_util.h"
 #include "base/functional/callback_helpers.h"
 #include "base/memory/raw_ptr.h"
@@ -13,6 +14,7 @@
 #include "base/test/bind.h"
 #include "base/test/test_reg_util_win.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/profiles/profile_attributes_entry.h"
 #include "chrome/browser/profiles/profile_attributes_storage.h"
 #include "chrome/browser/profiles/profile_manager.h"
@@ -112,11 +114,15 @@ class WebAppHandlerRegistrationUtilsWinTest : public testing::Test {
                   "Web Applications\\_crx_app_id\\app_name.ico"))));
 
     // Ensure that the launcher file contains the expected app name.
+    // On Windows 7 the extension is omitted.
+    base::FilePath expected_launcher_filename =
+        base::win::GetVersion() > base::win::Version::WIN7
+            ? base::FilePath(expected_user_visible_app_name.append(L".exe"))
+            : base::FilePath(expected_user_visible_app_name);
     base::FilePath registered_launcher_path =
         ShellUtil::GetApplicationPathForProgId(app_progid);
     ASSERT_TRUE(base::PathExists(registered_launcher_path));
-    EXPECT_EQ(registered_launcher_path.BaseName(),
-              base::FilePath(expected_user_visible_app_name.append(L".exe")));
+    EXPECT_EQ(expected_launcher_filename, registered_launcher_path.BaseName());
   }
 
  private:
@@ -287,26 +293,54 @@ TEST_F(WebAppHandlerRegistrationUtilsWinTest, CreateAppLauncherFile) {
   EXPECT_TRUE(launcher_path.has_value());
   EXPECT_TRUE(base::PathExists(launcher_path.value()));
 
+  // On Windows 7 the extension is omitted.
   std::wstring expected_user_visible_app_name(app_name());
   expected_user_visible_app_name.append(app_name_extension);
-  EXPECT_EQ(launcher_path.value().BaseName(),
-            base::FilePath(expected_user_visible_app_name.append(L".exe")));
+  base::FilePath expected_launcher_filename =
+      base::win::GetVersion() > base::win::Version::WIN7
+          ? base::FilePath(expected_user_visible_app_name.append(L".exe"))
+          : base::FilePath(expected_user_visible_app_name);
+  EXPECT_EQ(launcher_path.value().BaseName(), expected_launcher_filename);
 }
 
 // Test that invalid file name characters in app_name are replaced with ' '.
 TEST_F(WebAppHandlerRegistrationUtilsWinTest, AppNameWithInvalidChars) {
   // '*' is an invalid char in Windows file names, so it should be replaced
   // with ' '.
-  EXPECT_EQ(GetAppSpecificLauncherFilename(L"app*name"),
-            base::FilePath(L"app name.exe"));
+  std::wstring app_name = L"app*name";
+  // On Windows 7 the extension is omitted.
+  base::FilePath expected_launcher_name =
+      base::win::GetVersion() > base::win::Version::WIN7
+          ? base::FilePath(L"app name.exe")
+          : base::FilePath(L"app name");
+  EXPECT_EQ(GetAppSpecificLauncherFilename(app_name), expected_launcher_name);
 }
 
 // Test that an app name that is a reserved filename on Windows has '_'
 // prepended to it when used as a filename for its launcher.
 TEST_F(WebAppHandlerRegistrationUtilsWinTest, AppNameIsReservedFilename) {
   // "con" is a reserved filename on Windows, so it should have '_' prepended.
-  EXPECT_EQ(GetAppSpecificLauncherFilename(L"con"),
-            base::FilePath(L"_con.exe"));
+  std::wstring app_name = L"con";
+  // On Windows 7 the extension is omitted.
+  base::FilePath expected_launcher_name =
+      base::win::GetVersion() > base::win::Version::WIN7
+          ? base::FilePath(L"_con.exe")
+          : base::FilePath(L"_con");
+  EXPECT_EQ(GetAppSpecificLauncherFilename(app_name), expected_launcher_name);
+}
+
+// Test that an app name containing '.' characters has them replaced with '_' on
+// Windows 7 when used as a filename for its launcher.
+TEST_F(WebAppHandlerRegistrationUtilsWinTest, AppNameContainsDot) {
+  std::wstring app_name = L"some.app.name";
+
+  // "some.app.name" should become "some_app_name" on Windows 7 and the
+  // extension is also omitted.
+  base::FilePath expected_launcher_name =
+      base::win::GetVersion() > base::win::Version::WIN7
+          ? base::FilePath(L"some.app.name.exe")
+          : base::FilePath(L"some_app_name");
+  EXPECT_EQ(GetAppSpecificLauncherFilename(app_name), expected_launcher_name);
 }
 
 }  // namespace web_app
diff --git a/chrome/browser/web_applications/os_integration/web_app_protocol_handler_registration_win_unittest.cc b/chrome/browser/web_applications/os_integration/web_app_protocol_handler_registration_win_unittest.cc
index 7db2a5e541669..c1fd90c900224 100644
--- a/chrome/browser/web_applications/os_integration/web_app_protocol_handler_registration_win_unittest.cc
+++ b/chrome/browser/web_applications/os_integration/web_app_protocol_handler_registration_win_unittest.cc
@@ -15,6 +15,7 @@
 #include "base/test/bind.h"
 #include "base/test/test_reg_util_win.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_attributes_storage.h"
 #include "chrome/browser/profiles/profile_manager.h"
@@ -168,12 +169,19 @@ class WebAppProtocolHandlerRegistrationWinTest : public testing::Test {
 
 TEST_F(WebAppProtocolHandlerRegistrationWinTest,
        AddAndVerifyProtocolAssociations) {
+  // App protocol handlers are not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
   AddAndVerifyProtocolAssociations(kApp1Id, kApp1Name, kApp1Url, GetProfile(),
                                    "");
 }
 
 TEST_F(WebAppProtocolHandlerRegistrationWinTest,
        RegisterMultipleHandlersWithSameScheme) {
+  // App protocol handlers are not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   AddAndVerifyProtocolAssociations(kApp1Id, kApp1Name, kApp1Url, GetProfile(),
                                    "");
   AddAndVerifyProtocolAssociations(kApp2Id, kApp2Name, kApp2Url, GetProfile(),
@@ -185,6 +193,10 @@ TEST_F(WebAppProtocolHandlerRegistrationWinTest,
 // the profile name, e.g., "app name (Default)" and "app name (Profile 2)".
 TEST_F(WebAppProtocolHandlerRegistrationWinTest,
        RegisterProtocolHandlersForWebAppIn2Profiles) {
+  // App protocol handlers are not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   AddAndVerifyProtocolAssociations(kApp1Id, kApp1Name, kApp1Url, GetProfile(),
                                    "");
 
@@ -225,6 +237,10 @@ TEST_F(WebAppProtocolHandlerRegistrationWinTest,
 // registered app name.
 TEST_F(WebAppProtocolHandlerRegistrationWinTest,
        UnRegisterProtocolHandlersForWebAppIn2Profiles) {
+  // App protocol handlers are not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   AddAndVerifyProtocolAssociations(kApp1Id, kApp1Name, kApp1Url, GetProfile(),
                                    "");
   base::FilePath app_specific_launcher_path =
@@ -277,6 +293,10 @@ TEST_F(WebAppProtocolHandlerRegistrationWinTest,
 // registry settings and the app-specific launcher.
 TEST_F(WebAppProtocolHandlerRegistrationWinTest,
        UnregisterProtocolHandlersForWebApp) {
+  // App protocol handlers are not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   AddAndVerifyProtocolAssociations(kApp1Id, kApp1Name, kApp1Url, GetProfile(),
                                    "");
   base::FilePath app_specific_launcher_path =
diff --git a/chrome/browser/web_applications/os_integration/web_app_shortcut_win_unittest.cc b/chrome/browser/web_applications/os_integration/web_app_shortcut_win_unittest.cc
index 840f9f6c15296..f55dad178204f 100644
--- a/chrome/browser/web_applications/os_integration/web_app_shortcut_win_unittest.cc
+++ b/chrome/browser/web_applications/os_integration/web_app_shortcut_win_unittest.cc
@@ -17,6 +17,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/test/scoped_path_override.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/web_applications/os_integration/web_app_shortcut.h"
 #include "chrome/browser/web_applications/test/web_app_test.h"
 #include "chrome/common/chrome_switches.h"
@@ -106,6 +107,8 @@ TEST_F(WebAppShortcutWinTest, GetShortcutPaths) {
       ShellUtil::SHORTCUT_LOCATION_DESKTOP,
       ShellUtil::SHORTCUT_LOCATION_START_MENU_CHROME_APPS_DIR,
       ShellUtil::SHORTCUT_LOCATION_STARTUP};
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    expected_locations.push_back(ShellUtil::SHORTCUT_LOCATION_QUICK_LAUNCH);
 
   base::FilePath expected_result;
   for (const auto& location : expected_locations) {
diff --git a/chrome/browser/webshare/share_service_browsertest.cc b/chrome/browser/webshare/share_service_browsertest.cc
index 56526b35a49cf..80d84bd2908ce 100644
--- a/chrome/browser/webshare/share_service_browsertest.cc
+++ b/chrome/browser/webshare/share_service_browsertest.cc
@@ -40,6 +40,14 @@ class ShareServiceBrowserTest : public InProcessBrowserTest {
     feature_list_.InitAndEnableFeature(features::kWebShare);
   }
 
+  void SetUp() override {
+#if BUILDFLAG(IS_WIN)
+    if (!webshare::ScopedShareOperationFakeComponents::IsSupportedEnvironment())
+      GTEST_SKIP();
+#endif
+    InProcessBrowserTest::SetUp();
+  }
+
   void SetUpOnMainThread() override {
     InProcessBrowserTest::SetUpOnMainThread();
 #if BUILDFLAG(IS_CHROMEOS)
diff --git a/chrome/browser/webshare/share_service_unittest.cc b/chrome/browser/webshare/share_service_unittest.cc
index 62702376175f7..d7a16687704c7 100644
--- a/chrome/browser/webshare/share_service_unittest.cc
+++ b/chrome/browser/webshare/share_service_unittest.cc
@@ -62,6 +62,9 @@ class ShareServiceUnitTest : public ChromeRenderViewHostTestHarness {
         base::BindRepeating(&ShareServiceUnitTest::AcceptShareRequest));
 #endif
 #if BUILDFLAG(IS_WIN)
+    if (!webshare::ScopedShareOperationFakeComponents::IsSupportedEnvironment())
+      GTEST_SKIP();
+
     ASSERT_NO_FATAL_FAILURE(scoped_fake_components_.SetUp());
 #endif
   }
diff --git a/chrome/browser/webshare/win/fake_data_transfer_manager.cc b/chrome/browser/webshare/win/fake_data_transfer_manager.cc
index c3a30311c0a34..3965fd998f11c 100644
--- a/chrome/browser/webshare/win/fake_data_transfer_manager.cc
+++ b/chrome/browser/webshare/win/fake_data_transfer_manager.cc
@@ -12,6 +12,7 @@
 #include "base/win/core_winrt_util.h"
 #include "base/win/scoped_hstring.h"
 #include "base/win/vector.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 using ABI::Windows::ApplicationModel::DataTransfer::DataPackage;
@@ -402,6 +403,10 @@ class FakeDataRequestedEventArgs final
 }  // namespace
 
 // static
+bool FakeDataTransferManager::IsSupportedEnvironment() {
+  return base::win::GetVersion() >= base::win::Version::WIN10;
+}
+
 FakeDataTransferManager::FakeDataTransferManager() {
   post_data_requested_callback_ = base::DoNothing();
 }
diff --git a/chrome/browser/webshare/win/fake_data_transfer_manager.h b/chrome/browser/webshare/win/fake_data_transfer_manager.h
index 02cc8804a7362..eb79a55d1e855 100644
--- a/chrome/browser/webshare/win/fake_data_transfer_manager.h
+++ b/chrome/browser/webshare/win/fake_data_transfer_manager.h
@@ -48,6 +48,8 @@ class __declspec(uuid("53CA4C00-6F19-40C1-A740-F66510E2DB40"))
   using PostDataRequestedCallback =
       base::RepeatingCallback<void(const DataRequestedContent&)>;
 
+  static bool IsSupportedEnvironment();
+
   FakeDataTransferManager();
   FakeDataTransferManager(const FakeDataTransferManager&) = delete;
   FakeDataTransferManager& operator=(const FakeDataTransferManager&) = delete;
diff --git a/chrome/browser/webshare/win/fake_data_transfer_manager_interop.cc b/chrome/browser/webshare/win/fake_data_transfer_manager_interop.cc
index 050d65f23d719..b567168ac1dac 100644
--- a/chrome/browser/webshare/win/fake_data_transfer_manager_interop.cc
+++ b/chrome/browser/webshare/win/fake_data_transfer_manager_interop.cc
@@ -13,6 +13,11 @@
 
 namespace webshare {
 
+// static
+bool FakeDataTransferManagerInterop::IsSupportedEnvironment() {
+  return FakeDataTransferManager::IsSupportedEnvironment();
+}
+
 FakeDataTransferManagerInterop::FakeDataTransferManagerInterop() = default;
 
 FakeDataTransferManagerInterop::~FakeDataTransferManagerInterop() {
diff --git a/chrome/browser/webshare/win/fake_data_transfer_manager_interop.h b/chrome/browser/webshare/win/fake_data_transfer_manager_interop.h
index a78f84c12e713..ec01e65c1c621 100644
--- a/chrome/browser/webshare/win/fake_data_transfer_manager_interop.h
+++ b/chrome/browser/webshare/win/fake_data_transfer_manager_interop.h
@@ -47,6 +47,8 @@ class FakeDataTransferManagerInterop final
     SucceedWithoutAction
   };
 
+  static bool IsSupportedEnvironment();
+
   FakeDataTransferManagerInterop();
   FakeDataTransferManagerInterop(const FakeDataTransferManagerInterop&) =
       delete;
diff --git a/chrome/browser/webshare/win/fake_data_transfer_manager_interop_unittest.cc b/chrome/browser/webshare/win/fake_data_transfer_manager_interop_unittest.cc
index 7046ad2c26e0c..6ee684f9b8b8e 100644
--- a/chrome/browser/webshare/win/fake_data_transfer_manager_interop_unittest.cc
+++ b/chrome/browser/webshare/win/fake_data_transfer_manager_interop_unittest.cc
@@ -55,6 +55,8 @@ class DataRequestedTestCallback {
 class FakeDataTransferManagerInteropTest : public ::testing::Test {
  protected:
   void SetUp() override {
+    if (!FakeDataTransferManagerInterop::IsSupportedEnvironment())
+      GTEST_SKIP();
     fake_data_transfer_manager_interop_ =
         Microsoft::WRL::Make<FakeDataTransferManagerInterop>();
   }
diff --git a/chrome/browser/webshare/win/fake_data_transfer_manager_unittest.cc b/chrome/browser/webshare/win/fake_data_transfer_manager_unittest.cc
index 2f6c5a6d6a726..219322a3b0ff2 100644
--- a/chrome/browser/webshare/win/fake_data_transfer_manager_unittest.cc
+++ b/chrome/browser/webshare/win/fake_data_transfer_manager_unittest.cc
@@ -93,6 +93,9 @@ class DataRequestedTestCallback {
 class FakeDataTransferManagerTest : public ::testing::Test {
  protected:
   void SetUp() override {
+    if (!FakeDataTransferManager::IsSupportedEnvironment())
+      GTEST_SKIP();
+
     winrt_initializer_.emplace();
     ASSERT_TRUE(winrt_initializer_->Succeeded());
     fake_data_transfer_manager_ =
diff --git a/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.cc b/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.cc
index b93004a0646b5..a55d6e1397e63 100644
--- a/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.cc
+++ b/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.cc
@@ -38,6 +38,11 @@ static HRESULT FakeRoGetActivationFactory(HSTRING class_id,
 
 }  // namespace
 
+// static
+bool ScopedFakeDataTransferManagerInterop::IsSupportedEnvironment() {
+  return FakeDataTransferManagerInterop::IsSupportedEnvironment();
+}
+
 ScopedFakeDataTransferManagerInterop::ScopedFakeDataTransferManagerInterop() =
     default;
 
@@ -51,6 +56,7 @@ ScopedFakeDataTransferManagerInterop::~ScopedFakeDataTransferManagerInterop() {
 
 void ScopedFakeDataTransferManagerInterop::SetUp() {
   ASSERT_FALSE(set_up_);
+  ASSERT_TRUE(IsSupportedEnvironment());
   base::win::AssertComInitialized();
 
   instance_ = Microsoft::WRL::Make<FakeDataTransferManagerInterop>();
diff --git a/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.h b/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.h
index 92429b1a4ea20..87b9785cc1550 100644
--- a/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.h
+++ b/chrome/browser/webshare/win/scoped_fake_data_transfer_manager_interop.h
@@ -16,6 +16,8 @@ class FakeDataTransferManagerInterop;
 // for the Share contract.
 class ScopedFakeDataTransferManagerInterop {
  public:
+  static bool IsSupportedEnvironment();
+
   ScopedFakeDataTransferManagerInterop();
   ScopedFakeDataTransferManagerInterop(
       const ScopedFakeDataTransferManagerInterop&) = delete;
diff --git a/chrome/browser/webshare/win/scoped_share_operation_fake_components.cc b/chrome/browser/webshare/win/scoped_share_operation_fake_components.cc
index 99c8156f292a3..b5d80978704f9 100644
--- a/chrome/browser/webshare/win/scoped_share_operation_fake_components.cc
+++ b/chrome/browser/webshare/win/scoped_share_operation_fake_components.cc
@@ -54,6 +54,11 @@ static HRESULT FakeRoGetActivationFactory(HSTRING class_id,
 
 }  // namespace
 
+// static
+bool ScopedShareOperationFakeComponents::IsSupportedEnvironment() {
+  return ScopedFakeDataTransferManagerInterop::IsSupportedEnvironment();
+}
+
 ScopedShareOperationFakeComponents::ScopedShareOperationFakeComponents() =
     default;
 
@@ -66,6 +71,7 @@ ScopedShareOperationFakeComponents::~ScopedShareOperationFakeComponents() {
 }
 
 void ScopedShareOperationFakeComponents::SetUp() {
+  ASSERT_TRUE(IsSupportedEnvironment());
   base::win::AssertComInitialized();
 
   ASSERT_NO_FATAL_FAILURE(scoped_fake_data_transfer_manager_interop_.SetUp());
diff --git a/chrome/browser/webshare/win/scoped_share_operation_fake_components.h b/chrome/browser/webshare/win/scoped_share_operation_fake_components.h
index 9d29fdd62f2d9..67eae3070357c 100644
--- a/chrome/browser/webshare/win/scoped_share_operation_fake_components.h
+++ b/chrome/browser/webshare/win/scoped_share_operation_fake_components.h
@@ -21,6 +21,8 @@ class FakeUriRuntimeClassFactory;
 // ShareOperation.
 class ScopedShareOperationFakeComponents final {
  public:
+  static bool IsSupportedEnvironment();
+
   ScopedShareOperationFakeComponents();
   ScopedShareOperationFakeComponents(
       const ScopedShareOperationFakeComponents&) = delete;
diff --git a/chrome/browser/webshare/win/share_operation_unittest.cc b/chrome/browser/webshare/win/share_operation_unittest.cc
index b4aaa46ebef32..0937bf890684a 100644
--- a/chrome/browser/webshare/win/share_operation_unittest.cc
+++ b/chrome/browser/webshare/win/share_operation_unittest.cc
@@ -66,6 +66,9 @@ class ShareOperationUnitTest : public ChromeRenderViewHostTestHarness {
   void SetUp() override {
     ChromeRenderViewHostTestHarness::SetUp();
 
+    if (!ScopedShareOperationFakeComponents::IsSupportedEnvironment())
+      GTEST_SKIP();
+
     ASSERT_NO_FATAL_FAILURE(scoped_fake_components_.SetUp());
     ShareOperation::SetMaxFileBytesForTesting(kMaxSharedFileBytesForTest);
   }
@@ -465,4 +468,29 @@ TEST_F(ShareOperationUnitTest, FilesTotallingLargerThanSizeLimit) {
             kMaxSharedFileBytesForTest + 1);
 }
 
+class ShareOperationInUnsupportedEnvironmentUnitTest
+    : public ShareOperationUnitTest {
+ public:
+  void SetUp() override {
+    ChromeRenderViewHostTestHarness::SetUp();
+
+    if (ScopedShareOperationFakeComponents::IsSupportedEnvironment())
+      GTEST_SKIP();
+  }
+};
+
+TEST_F(ShareOperationInUnsupportedEnvironmentUnitTest, GracefullyFails) {
+  base::RunLoop run_loop;
+  std::vector<blink::mojom::SharedFilePtr> files;
+  ShareOperation operation{"shared title", "shared text",
+                           GURL("https://www.contoso.com"), std::move(files),
+                           web_contents()};
+  operation.Run(
+      base::BindLambdaForTesting([&run_loop](blink::mojom::ShareError error) {
+        ASSERT_EQ(error, blink::mojom::ShareError::INTERNAL_ERROR);
+        run_loop.Quit();
+      }));
+  run_loop.Run();
+}
+
 }  // namespace webshare
diff --git a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
index a48308ac47576..e05b26b1a26ef 100644
--- a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
+++ b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
@@ -9,13 +9,10 @@
 #include <windows.applicationmodel.datatransfer.h>
 #include <wrl/event.h>
 
-#include <utility>
-
 #include "base/functional/callback.h"
-#include "base/strings/string_piece.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/win/core_winrt_util.h"
-#include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/browser_thread.h"
 
@@ -40,8 +37,12 @@ HRESULT GetDataTransferManagerHandles(
     HWND hwnd,
     IDataTransferManagerInterop** data_transfer_manager_interop,
     IDataTransferManager** data_transfer_manager) {
-  // If the required WinRT functionality is not available, fail the operation.
-  if (!base::win::ResolveCoreWinRTDelayload() ||
+  // If the required WinRT functionality is not available, fail the operation
+  // Note: Though the Share APIs are present starting in Windows 8, they are
+  // only fulfilled when invoked from within a UWP app container. Starting in
+  // Windows 10 they are fulfilled for all callers.
+  if ((base::win::GetVersion() < base::win::Version::WIN10) ||
+      !base::win::ResolveCoreWinRTDelayload() ||
       !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
     return E_FAIL;
   }
diff --git a/chrome/browser/webshare/win/show_share_ui_for_window_operation_unittest.cc b/chrome/browser/webshare/win/show_share_ui_for_window_operation_unittest.cc
index 942a39827d812..a63c520c70148 100644
--- a/chrome/browser/webshare/win/show_share_ui_for_window_operation_unittest.cc
+++ b/chrome/browser/webshare/win/show_share_ui_for_window_operation_unittest.cc
@@ -41,6 +41,8 @@ class ShowShareUIForWindowOperationTest : public ::testing::Test {
   enum TestCallbackState { NotRun = 0, RunWithoutValue, RunWithValue };
 
   void SetUp() override {
+    if (!ScopedFakeDataTransferManagerInterop::IsSupportedEnvironment())
+      GTEST_SKIP();
     ASSERT_NO_FATAL_FAILURE(scoped_interop_.SetUp());
     operation_ = std::make_unique<ShowShareUIForWindowOperation>(hwnd_);
     auto weak_ptr = weak_factory_.GetWeakPtr();
diff --git a/chrome/browser/win/conflicts/incompatible_applications_browsertest.cc b/chrome/browser/win/conflicts/incompatible_applications_browsertest.cc
index 38b8e78a0140f..523b5958b2e1c 100644
--- a/chrome/browser/win/conflicts/incompatible_applications_browsertest.cc
+++ b/chrome/browser/win/conflicts/incompatible_applications_browsertest.cc
@@ -17,6 +17,7 @@
 #include "base/test/test_reg_util_win.h"
 #include "base/threading/thread_restrictions.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/win/conflicts/incompatible_applications_updater.h"
 #include "chrome/browser/win/conflicts/module_database.h"
@@ -203,6 +204,9 @@ constexpr wchar_t IncompatibleApplicationsBrowserTest::kApplicationName[];
 // page is shown after a browser crash.
 IN_PROC_BROWSER_TEST_F(IncompatibleApplicationsBrowserTest,
                        InjectIncompatibleDLL) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   // Create the observer early so the change is guaranteed to be observed.
   auto incompatible_applications_observer =
       std::make_unique<IncompatibleApplicationsObserver>();
diff --git a/chrome/browser/win/conflicts/incompatible_applications_updater.cc b/chrome/browser/win/conflicts/incompatible_applications_updater.cc
index 873b80a905808..f84f8af5bc4cf 100644
--- a/chrome/browser/win/conflicts/incompatible_applications_updater.cc
+++ b/chrome/browser/win/conflicts/incompatible_applications_updater.cc
@@ -15,6 +15,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/values.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/win/conflicts/module_database.h"
 #include "chrome/browser/win/conflicts/module_info.h"
@@ -265,8 +266,9 @@ void IncompatibleApplicationsUpdater::RegisterLocalStatePrefs(
 
 // static
 bool IncompatibleApplicationsUpdater::IsWarningEnabled() {
-  return base::FeatureList::IsEnabled(
-      features::kIncompatibleApplicationsWarning);
+  return base::win::GetVersion() >= base::win::Version::WIN10 &&
+         base::FeatureList::IsEnabled(
+             features::kIncompatibleApplicationsWarning);
 }
 
 // static
diff --git a/chrome/browser/win/conflicts/incompatible_applications_updater_unittest.cc b/chrome/browser/win/conflicts/incompatible_applications_updater_unittest.cc
index 877fba60435bd..0cf0c90b9cc34 100644
--- a/chrome/browser/win/conflicts/incompatible_applications_updater_unittest.cc
+++ b/chrome/browser/win/conflicts/incompatible_applications_updater_unittest.cc
@@ -13,6 +13,7 @@
 #include "base/test/scoped_feature_list.h"
 #include "base/test/test_reg_util_win.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/win/conflicts/module_info.h"
 #include "chrome/browser/win/conflicts/module_list_filter.h"
 #include "chrome/common/chrome_features.h"
@@ -192,6 +193,9 @@ class IncompatibleApplicationsUpdaterTest : public testing::Test,
 // Tests that when the Local State cache is empty, no incompatible applications
 // are returned.
 TEST_F(IncompatibleApplicationsUpdaterTest, EmptyCache) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   EXPECT_FALSE(IncompatibleApplicationsUpdater::HasCachedApplications());
   EXPECT_TRUE(IncompatibleApplicationsUpdater::GetCachedApplications().empty());
 }
@@ -199,6 +203,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, EmptyCache) {
 // IncompatibleApplicationsUpdater doesn't do anything when there is no
 // registered installed applications.
 TEST_F(IncompatibleApplicationsUpdaterTest, NoIncompatibleApplications) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   auto incompatible_applications_updater =
       CreateIncompatibleApplicationsUpdater();
 
@@ -213,6 +220,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, NoIncompatibleApplications) {
 }
 
 TEST_F(IncompatibleApplicationsUpdaterTest, NoTiedApplications) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   auto incompatible_applications_updater =
       CreateIncompatibleApplicationsUpdater();
 
@@ -233,6 +243,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, NoTiedApplications) {
 }
 
 TEST_F(IncompatibleApplicationsUpdaterTest, OneIncompatibility) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
 
   auto incompatible_applications_updater =
@@ -256,6 +269,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, OneIncompatibility) {
 }
 
 TEST_F(IncompatibleApplicationsUpdaterTest, SameModuleMultipleApplications) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
   AddIncompatibleApplication(dll1_, L"Bar", Option::ADD_REGISTRY_ENTRY);
 
@@ -280,6 +296,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, SameModuleMultipleApplications) {
 
 TEST_F(IncompatibleApplicationsUpdaterTest,
        MultipleCallsToOnModuleDatabaseIdle) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
   AddIncompatibleApplication(dll2_, L"Bar", Option::ADD_REGISTRY_ENTRY);
 
@@ -319,6 +338,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest,
 // the list isn't tied to the lifetime of the IncompatibleApplicationsUpdater
 // instance. It is assumed that the Local State file works as intended.
 TEST_F(IncompatibleApplicationsUpdaterTest, PersistsThroughRestarts) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
 
   auto incompatible_applications_updater =
@@ -340,6 +362,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, PersistsThroughRestarts) {
 
 // Tests that applications that do not have a registry entry are removed.
 TEST_F(IncompatibleApplicationsUpdaterTest, StaleEntriesRemoved) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
   AddIncompatibleApplication(dll2_, L"Bar", Option::NO_REGISTRY_ENTRY);
 
@@ -362,6 +387,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, StaleEntriesRemoved) {
 }
 
 TEST_F(IncompatibleApplicationsUpdaterTest, IgnoreNotLoadedModules) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
 
   auto incompatible_applications_updater =
@@ -387,6 +415,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, IgnoreNotLoadedModules) {
 // Tests that modules with a matching certificate subject are allowlisted.
 TEST_F(IncompatibleApplicationsUpdaterTest,
        allowlistMatchingCertificateSubject) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
 
   auto incompatible_applications_updater =
@@ -411,6 +442,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest,
 
 // Registered modules are defined as either a shell extension or an IME.
 TEST_F(IncompatibleApplicationsUpdaterTest, IgnoreRegisteredModules) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Shell Extension",
                              Option::ADD_REGISTRY_ENTRY);
   AddIncompatibleApplication(dll2_, L"Input Method Editor",
@@ -450,6 +484,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, IgnoreRegisteredModules) {
 }
 
 TEST_F(IncompatibleApplicationsUpdaterTest, IgnoreModulesAddedToTheBlocklist) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Blocklisted Application",
                              Option::ADD_REGISTRY_ENTRY);
 
@@ -473,6 +510,9 @@ TEST_F(IncompatibleApplicationsUpdaterTest, IgnoreModulesAddedToTheBlocklist) {
 }
 
 TEST_F(IncompatibleApplicationsUpdaterTest, DisableModuleAnalysis) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   AddIncompatibleApplication(dll1_, L"Foo", Option::ADD_REGISTRY_ENTRY);
 
   auto incompatible_applications_updater =
diff --git a/chrome/browser/win/conflicts/module_blocklist_cache_updater.cc b/chrome/browser/win/conflicts/module_blocklist_cache_updater.cc
index ba0f8871a47f8..9af7a4081b213 100644
--- a/chrome/browser/win/conflicts/module_blocklist_cache_updater.cc
+++ b/chrome/browser/win/conflicts/module_blocklist_cache_updater.cc
@@ -21,6 +21,7 @@
 #include "base/task/thread_pool.h"
 #include "base/time/time.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/win/conflicts/module_blocklist_cache_util.h"
 #include "chrome/browser/win/conflicts/module_database.h"
 #include "chrome/browser/win/conflicts/module_info_util.h"
@@ -205,7 +206,8 @@ ModuleBlocklistCacheUpdater::~ModuleBlocklistCacheUpdater() {
 
 // static
 bool ModuleBlocklistCacheUpdater::IsBlockingEnabled() {
-  return base::FeatureList::IsEnabled(features::kThirdPartyModulesBlocking);
+  return base::win::GetVersion() >= base::win::Version::WIN8 &&
+         base::FeatureList::IsEnabled(features::kThirdPartyModulesBlocking);
 }
 
 // static
diff --git a/chrome/browser/win/conflicts/third_party_blocking_browsertest.cc b/chrome/browser/win/conflicts/third_party_blocking_browsertest.cc
index 7fc3939695341..841b0f421223f 100644
--- a/chrome/browser/win/conflicts/third_party_blocking_browsertest.cc
+++ b/chrome/browser/win/conflicts/third_party_blocking_browsertest.cc
@@ -14,6 +14,7 @@
 #include "base/test/scoped_feature_list.h"
 #include "base/test/test_reg_util_win.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/win/conflicts/module_blocklist_cache_updater.h"
 #include "chrome/browser/win/conflicts/module_blocklist_cache_util.h"
 #include "chrome/browser/win/conflicts/module_database.h"
@@ -160,6 +161,9 @@ class ThirdPartyBlockingBrowserTest : public InProcessBrowserTest {
 //       browser launch.
 IN_PROC_BROWSER_TEST_F(ThirdPartyBlockingBrowserTest,
                        CreateModuleBlocklistCache) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   // Create the observer early so the change is guaranteed to be observed.
   ThirdPartyRegistryKeyObserver third_party_registry_key_observer;
   ASSERT_TRUE(third_party_registry_key_observer.StartWatching());
diff --git a/chrome/browser/win/conflicts/third_party_conflicts_manager_unittest.cc b/chrome/browser/win/conflicts/third_party_conflicts_manager_unittest.cc
index 0ad24f8644ace..f1cc08bfcc135 100644
--- a/chrome/browser/win/conflicts/third_party_conflicts_manager_unittest.cc
+++ b/chrome/browser/win/conflicts/third_party_conflicts_manager_unittest.cc
@@ -14,6 +14,8 @@
 #include "base/path_service.h"
 #include "base/run_loop.h"
 #include "base/test/scoped_feature_list.h"
+#include "base/threading/sequenced_task_runner_handle.h"
+#include "base/win/windows_version.h"
 #include "chrome/browser/win/conflicts/module_info.h"
 #include "chrome/browser/win/conflicts/proto/module_list.pb.h"
 #include "chrome/common/chrome_features.h"
@@ -128,8 +130,11 @@ TEST_F(ThirdPartyConflictsManagerTest, InitializeUpdaters) {
 
   ASSERT_TRUE(final_state().has_value());
 
-  EXPECT_EQ(final_state().value(),
-            ThirdPartyConflictsManager::State::kWarningAndBlockingInitialized);
+  const auto kExpectedFinalState =
+      base::win::GetVersion() >= base::win::Version::WIN10
+          ? ThirdPartyConflictsManager::State::kWarningAndBlockingInitialized
+          : ThirdPartyConflictsManager::State::kBlockingInitialized;
+  EXPECT_EQ(final_state().value(), kExpectedFinalState);
 }
 
 TEST_F(ThirdPartyConflictsManagerTest, InvalidModuleList) {
diff --git a/chrome/browser/win/parental_controls.cc b/chrome/browser/win/parental_controls.cc
index 052c89c9473de..a320b3966ba8d 100644
--- a/chrome/browser/win/parental_controls.cc
+++ b/chrome/browser/win/parental_controls.cc
@@ -23,6 +23,7 @@
 #include "base/win/registry.h"
 #include "base/win/win_util.h"
 #include "base/win/windows_types.h"
+#include "base/win/windows_version.h"
 
 namespace {
 
@@ -123,7 +124,8 @@ class WinParentalControlsValue {
 
     // Parental controls APIs are not fully supported in Win10 and beyond, so
     // check registry properties for restictions.
-    UpdateParentalControlsFromRegistry(&controls);
+    if (base::win::GetVersion() >= base::win::Version::WIN10)
+      UpdateParentalControlsFromRegistry(&controls);
 
     return controls;
   }
diff --git a/chrome/browser/win/titlebar_config.cc b/chrome/browser/win/titlebar_config.cc
index ea0ec0bcdf667..43678e39b310a 100644
--- a/chrome/browser/win/titlebar_config.cc
+++ b/chrome/browser/win/titlebar_config.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/win/titlebar_config.h"
 
 #include "base/command_line.h"
+#include "base/win/windows_version.h"
 #include "chrome/common/chrome_switches.h"
 
 bool ShouldCustomDrawSystemTitlebar() {
@@ -13,5 +14,6 @@ bool ShouldCustomDrawSystemTitlebar() {
       base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kDisableWindows10CustomTitlebar);
 
-  return !custom_titlebar_disabled;
+  return !custom_titlebar_disabled &&
+         base::win::GetVersion() >= base::win::Version::WIN10;
 }
diff --git a/chrome/chrome_cleaner/components/system_restore_point_component.cc b/chrome/chrome_cleaner/components/system_restore_point_component.cc
index 2626a157368d1..ec3ee9ffe1f59 100644
--- a/chrome/chrome_cleaner/components/system_restore_point_component.cc
+++ b/chrome/chrome_cleaner/components/system_restore_point_component.cc
@@ -10,6 +10,7 @@
 #include "base/files/file_path.h"
 #include "base/logging.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 
 namespace {
 
@@ -70,16 +71,19 @@ void SystemRestorePointComponent::PreCleanup() {
   if (!set_restore_point_info_fn_)
     return;
 
-  // A registry value needs to be created in order for restore points to be
-  // deterministically created. Attempt to create this value, but continue with
-  // the restore point anyway even if doing so fails. For more info, see
-  // http://msdn.microsoft.com/en-us/library/windows/desktop/aa378941.aspx.
-  base::win::RegKey system_restore_key(HKEY_LOCAL_MACHINE, kSystemRestoreKey,
-                                       KEY_SET_VALUE | KEY_QUERY_VALUE);
-  if (system_restore_key.Valid() &&
-      !system_restore_key.HasValue(kSystemRestoreFrequencyWin8)) {
-    system_restore_key.WriteValue(kSystemRestoreFrequencyWin8,
-                                  static_cast<DWORD>(0));
+  // On Windows8, a registry value needs to be created in order for restore
+  // points to be deterministically created. Attempt to create this value, but
+  // continue with the restore point anyway even if doing so fails. See
+  // http://msdn.microsoft.com/en-us/library/windows/desktop/aa378941.aspx for
+  // more information.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    base::win::RegKey system_restore_key(HKEY_LOCAL_MACHINE, kSystemRestoreKey,
+                                         KEY_SET_VALUE | KEY_QUERY_VALUE);
+    if (system_restore_key.Valid() &&
+        !system_restore_key.HasValue(kSystemRestoreFrequencyWin8)) {
+      system_restore_key.WriteValue(kSystemRestoreFrequencyWin8,
+                                    static_cast<DWORD>(0));
+    }
   }
 
   // Take a system restore point before doing anything else.
diff --git a/chrome/chrome_cleaner/ipc/sandbox.cc b/chrome/chrome_cleaner/ipc/sandbox.cc
index 618ee1c7acd68..4482c5cfc8d37 100644
--- a/chrome/chrome_cleaner/ipc/sandbox.cc
+++ b/chrome/chrome_cleaner/ipc/sandbox.cc
@@ -268,14 +268,16 @@ ResultCode StartSandboxTarget(const base::CommandLine& sandbox_command_line,
   // Spawn the sandbox target process.
   PROCESS_INFORMATION temp_process_info = {0};
   DWORD last_win_error = 0;
+  sandbox::ResultCode last_sbox_warning = sandbox::SBOX_ALL_OK;
   LOG(INFO) << "Starting sandbox process with command line arguments: "
             << command_line.GetArgumentsString();
   sandbox::ResultCode sandbox_result = sandbox_broker_services->SpawnTarget(
       command_line.GetProgram().value().c_str(),
       command_line.GetCommandLineString().c_str(), std::move(policy),
-      &last_win_error, &temp_process_info);
+      &last_sbox_warning, &last_win_error, &temp_process_info);
   if (sandbox_result != sandbox::SBOX_ALL_OK) {
     LOG(DFATAL) << "Failed to spawn sandbox target: " << sandbox_result
+                << ", last sandbox warning: " << last_sbox_warning
                 << ", last windows error: "
                 << logging::SystemErrorCodeToString(last_win_error);
     return RESULT_CODE_FAILED_TO_START_SANDBOX_PROCESS;
diff --git a/chrome/chrome_cleaner/os/task_scheduler_unittest.cc b/chrome/chrome_cleaner/os/task_scheduler_unittest.cc
index fc0b1eb87427f..1fc8445c26673 100644
--- a/chrome/chrome_cleaner/os/task_scheduler_unittest.cc
+++ b/chrome/chrome_cleaner/os/task_scheduler_unittest.cc
@@ -27,6 +27,10 @@
 #include "chrome/chrome_cleaner/test/test_strings.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace chrome_cleaner {
 
 namespace {
@@ -94,6 +98,13 @@ TEST_F(TaskSchedulerTests, DeleteAndIsRegistered) {
 }
 
 TEST_F(TaskSchedulerTests, RunAProgramNow) {
+#if BUILDFLAG(IS_WIN)
+    // TODO(crbug.com/1307401): Failing on Windows7.
+    if (base::win::GetVersion() <= base::win::Version::WIN7) {
+      return;
+    }
+#endif
+
   base::FilePath executable_path;
   ASSERT_TRUE(base::PathService::Get(base::DIR_EXE, &executable_path));
   base::CommandLine command_line(
diff --git a/chrome/chrome_cleaner/test/cleaner_test.cc b/chrome/chrome_cleaner/test/cleaner_test.cc
index 6326ce89a3368..b19f30dea6ffa 100644
--- a/chrome/chrome_cleaner/test/cleaner_test.cc
+++ b/chrome/chrome_cleaner/test/cleaner_test.cc
@@ -22,6 +22,7 @@
 #include "base/task/thread_pool.h"
 #include "base/test/task_environment.h"
 #include "base/test/test_timeouts.h"
+#include "base/win/windows_version.h"
 #include "chrome/chrome_cleaner/buildflags.h"
 #include "chrome/chrome_cleaner/constants/chrome_cleaner_switches.h"
 #include "chrome/chrome_cleaner/ipc/chrome_prompt_test_util.h"
@@ -549,6 +550,11 @@ TEST_P(CleanerTest, NoPotentialFalsePositivesOnCleanMachine) {
 }
 
 TEST_P(CleanerTest, NoUnsanitizedPaths) {
+  // Fails on Windows7
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return;
+  }
+
   CreateRemovableUwS();
 
   base::CommandLine command_line = BuildCommandLine(kCleanerExecutable);
diff --git a/chrome/chrome_cleaner/test/test_util.cc b/chrome/chrome_cleaner/test/test_util.cc
index f893817aa14a5..7ae31390cfc19 100644
--- a/chrome/chrome_cleaner/test/test_util.cc
+++ b/chrome/chrome_cleaner/test/test_util.cc
@@ -154,6 +154,11 @@ int RunChromeCleanerTestSuite(int argc,
         chrome_cleaner::SandboxType::kNonSandboxed);
   }
 
+  // Some tests spawn sandbox targets using job objects. Windows 7 doesn't
+  // support nested job objects, so don't use them in the test suite. Otherwise
+  // all sandbox tests will fail as they try to create a second job object.
+  bool use_job_objects = base::win::GetVersion() >= base::win::Version::WIN8;
+
   // Some tests will fail if two tests try to launch test_process.exe
   // simultaneously, so run the tests serially. This will still shard them and
   // distribute the shards to different swarming bots, but tests will run
@@ -162,7 +167,7 @@ int RunChromeCleanerTestSuite(int argc,
       argc, argv,
       /*parallel_jobs=*/1U,        // Like LaunchUnitTestsSerially
       /*default_batch_limit=*/10,  // Like LaunchUnitTestsSerially
-      /*use_job_objects=*/true, base::DoNothing(),
+      use_job_objects, base::DoNothing(),
       base::BindOnce(&base::TestSuite::Run, base::Unretained(&test_suite)));
 
   if (!IsSandboxedProcess())
diff --git a/chrome/chrome_elf/chrome_elf_security.cc b/chrome/chrome_elf/chrome_elf_security.cc
index ea44babfb52ea..2cebeeff34f7e 100644
--- a/chrome/chrome_elf/chrome_elf_security.cc
+++ b/chrome/chrome_elf/chrome_elf_security.cc
@@ -82,6 +82,8 @@ class ExtensionPointDisableSet {
 }  // namespace
 
 void EarlyBrowserSecurity() {
+  typedef decltype(SetProcessMitigationPolicy)* SetProcessMitigationPolicyFunc;
+
   // This function is called from within DllMain.
   // Don't do anything naughty while we have the loader lock.
   NTSTATUS ret_val = STATUS_SUCCESS;
@@ -105,13 +107,20 @@ void EarlyBrowserSecurity() {
 
   nt::CloseRegKey(handle);
 
-  // Disable extension points (legacy hooking) in this process.
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  policy.DisableExtensionPoints = true;
-  SetProcessMitigationPolicy(ProcessExtensionPointDisablePolicy, &policy,
-                             sizeof(policy));
-  ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
-
+  if (::IsWindows8OrGreater()) {
+    SetProcessMitigationPolicyFunc set_process_mitigation_policy =
+        reinterpret_cast<SetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "SetProcessMitigationPolicy"));
+    if (set_process_mitigation_policy) {
+      // Disable extension points in this process.
+      // (Legacy hooking.)
+      PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+      policy.DisableExtensionPoints = true;
+      set_process_mitigation_policy(ProcessExtensionPointDisablePolicy, &policy,
+                                    sizeof(policy));
+      ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+    }
+  }
   return;
 }
 
diff --git a/chrome/chrome_elf/hook_util/hook_util.cc b/chrome/chrome_elf/hook_util/hook_util.cc
index 565221af237b1..e9e2ccb1268e3 100644
--- a/chrome/chrome_elf/hook_util/hook_util.cc
+++ b/chrome/chrome_elf/hook_util/hook_util.cc
@@ -10,6 +10,7 @@
 #include "chrome/chrome_elf/nt_registry/nt_registry.h"  // utils
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/internal_types.h"
+#include "sandbox/win/src/service_resolver.h"
 
 namespace {
 
@@ -196,6 +197,43 @@ DWORD RemoveIATHook(void* intercept_function,
 
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed) {
+  // Create a thunk via the appropriate ServiceResolver instance.
+  sandbox::ServiceResolverThunk* thunk = nullptr;
+
+  // No hooking on unsupported OS versions.
+  if (!::IsWindows7OrGreater())
+    return thunk;
+
+  // Pseudo-handle, no need to close.
+  HANDLE current_process = ::GetCurrentProcess();
+
+#if defined(_WIN64)
+  // ServiceResolverThunk can handle all the formats in 64-bit (instead only
+  // handling one like it does in 32-bit versions).
+  thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+#else
+  if (nt::IsCurrentProcWow64()) {
+    if (::IsWindows10OrGreater())
+      thunk = new sandbox::Wow64W10ResolverThunk(current_process, relaxed);
+    else if (::IsWindows8OrGreater())
+      thunk = new sandbox::Wow64W8ResolverThunk(current_process, relaxed);
+    else
+      thunk = new sandbox::Wow64ResolverThunk(current_process, relaxed);
+  } else if (::IsWindows8OrGreater()) {
+    thunk = new sandbox::Win8ResolverThunk(current_process, relaxed);
+  } else {
+    thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+  }
+#endif
+
+  return thunk;
+}
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/chrome_elf/hook_util/hook_util.h b/chrome/chrome_elf/hook_util/hook_util.h
index 9070b9d93a6f0..687042ec330c7 100644
--- a/chrome/chrome_elf/hook_util/hook_util.h
+++ b/chrome/chrome_elf/hook_util/hook_util.h
@@ -7,8 +7,20 @@
 
 #include <windows.h>
 
+namespace sandbox {
+class ServiceResolverThunk;
+}
+
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+// Creates a |ServiceResolverThunk| based on the OS version. Ownership of the
+// resulting thunk is passed to the caller.
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed);
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/chrome_elf/nt_registry/nt_registry.cc b/chrome/chrome_elf/nt_registry/nt_registry.cc
index d0c71f9a0cc91..cde3d6d254bae 100644
--- a/chrome/chrome_elf/nt_registry/nt_registry.cc
+++ b/chrome/chrome_elf/nt_registry/nt_registry.cc
@@ -21,6 +21,7 @@ bool g_system_install = false;
 bool g_wow64_proc = false;
 wchar_t g_kRegPathHKLM[] = L"\\Registry\\Machine\\";
 wchar_t g_kRegPathHKCU[nt::g_kRegMaxPathLen + 1] = L"";
+wchar_t g_current_user_sid_string[nt::g_kRegMaxPathLen + 1] = L"";
 
 // Max number of tries for system API calls when STATUS_BUFFER_OVERFLOW or
 // STATUS_BUFFER_TOO_SMALL can be returned.
@@ -78,6 +79,10 @@ bool InitNativeRegApi() {
   ::wcsncat(g_kRegPathHKCU, current_user_reg_path.Buffer, nt::g_kRegMaxPathLen);
   ::wcsncat(g_kRegPathHKCU, L"\\",
             (nt::g_kRegMaxPathLen - ::wcslen(g_kRegPathHKCU)));
+  // Keep the sid string as well.
+  wchar_t* ptr = ::wcsrchr(current_user_reg_path.Buffer, L'\\');
+  ptr++;
+  ::wcsncpy(g_current_user_sid_string, ptr, nt::g_kRegMaxPathLen);
   ::RtlFreeUnicodeString(&current_user_reg_path);
 
   // Figure out if this is a system or user install.
@@ -1044,10 +1049,100 @@ bool SetRegValueMULTISZ(ROOT_KEY root,
   return true;
 }
 
+//------------------------------------------------------------------------------
+// Enumeration Support
+//------------------------------------------------------------------------------
+
+bool QueryRegEnumerationInfo(HANDLE key, ULONG* out_subkey_count) {
+  if (!g_initialized && !InitNativeRegApi())
+    return false;
+
+  // Use a loop here, to be a little more tolerant of concurrent registry
+  // changes.
+  NTSTATUS ntstatus = STATUS_UNSUCCESSFUL;
+  int tries = 0;
+  // Start with sizeof the structure.  It's very common for the variable sized
+  // "Class" element to be of length 0.
+  KEY_FULL_INFORMATION* key_info = nullptr;
+  DWORD size_needed = sizeof(*key_info);
+  std::vector<BYTE> buffer(size_needed);
+  do {
+    buffer.resize(size_needed);
+    key_info = reinterpret_cast<KEY_FULL_INFORMATION*>(buffer.data());
+
+    ntstatus = ::NtQueryKey(key, KeyFullInformation, key_info, size_needed,
+                            &size_needed);
+  } while ((ntstatus == STATUS_BUFFER_OVERFLOW ||
+            ntstatus == STATUS_BUFFER_TOO_SMALL) &&
+           ++tries < kMaxTries);
+
+  if (!NT_SUCCESS(ntstatus))
+    return false;
+
+  // Move desired information to out variables.
+  *out_subkey_count = key_info->SubKeys;
+
+  return true;
+}
+
+bool QueryRegSubkey(HANDLE key,
+                    ULONG subkey_index,
+                    std::wstring* out_subkey_name) {
+  if (!g_initialized && !InitNativeRegApi())
+    return false;
+
+  // Use a loop here, to be a little more tolerant of concurrent registry
+  // changes.
+  NTSTATUS ntstatus = STATUS_UNSUCCESSFUL;
+  int tries = 0;
+  // Start with sizeof the structure, plus 12 characters.  It's very common for
+  // key names to be < 12 characters (without being inefficient as an initial
+  // allocation).
+  KEY_BASIC_INFORMATION* subkey_info = nullptr;
+  DWORD size_needed = sizeof(*subkey_info) + (12 * sizeof(wchar_t));
+  std::vector<BYTE> buffer(size_needed);
+  do {
+    buffer.resize(size_needed);
+    subkey_info = reinterpret_cast<KEY_BASIC_INFORMATION*>(buffer.data());
+
+    ntstatus = ::NtEnumerateKey(key, subkey_index, KeyBasicInformation,
+                                subkey_info, size_needed, &size_needed);
+  } while ((ntstatus == STATUS_BUFFER_OVERFLOW ||
+            ntstatus == STATUS_BUFFER_TOO_SMALL) &&
+           ++tries < kMaxTries);
+
+  if (!NT_SUCCESS(ntstatus))
+    return false;
+
+  // Move desired information to out variables.
+  // NOTE: NameLength is size of Name array in bytes.  Name array is also
+  //       NOT null terminated!
+  BYTE* name = reinterpret_cast<BYTE*>(subkey_info->Name);
+  std::vector<BYTE> content(name, name + subkey_info->NameLength);
+  EnsureTerminatedSZ(&content, false);
+  out_subkey_name->assign(reinterpret_cast<wchar_t*>(content.data()));
+
+  return true;
+}
+
 //------------------------------------------------------------------------------
 // Utils
 //------------------------------------------------------------------------------
 
+const wchar_t* GetCurrentUserSidString() {
+  if (!g_initialized && !InitNativeRegApi())
+    return nullptr;
+
+  return g_current_user_sid_string;
+}
+
+bool IsCurrentProcWow64() {
+  if (!g_initialized && !InitNativeRegApi())
+    return false;
+
+  return g_wow64_proc;
+}
+
 bool SetTestingOverride(ROOT_KEY root, const std::wstring& new_path) {
   if (!g_initialized && !InitNativeRegApi())
     return false;
diff --git a/chrome/chrome_elf/nt_registry/nt_registry.h b/chrome/chrome_elf/nt_registry/nt_registry.h
index 200175d942be3..a38d75f984608 100644
--- a/chrome/chrome_elf/nt_registry/nt_registry.h
+++ b/chrome/chrome_elf/nt_registry/nt_registry.h
@@ -33,7 +33,7 @@
 namespace nt {
 
 // Windows registry maximum lengths (in chars).  Not including null char.
-// https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits
+// https://msdn.microsoft.com/en-us/library/windows/desktop/ms724872(v=vs.85).aspx
 constexpr size_t g_kRegMaxPathLen = 255;
 constexpr size_t g_kRegMaxValueName = 16383;
 
@@ -228,10 +228,35 @@ bool SetRegValueMULTISZ(ROOT_KEY root,
                         const wchar_t* value_name,
                         const std::vector<std::wstring>& values);
 
+//------------------------------------------------------------------------------
+// Enumeration Support
+//------------------------------------------------------------------------------
+
+// Query key information for subkey enumeration.
+// - Key handle should have been opened with OpenRegKey (with at least
+//   KEY_ENUMERATE_SUB_KEYS access rights).
+// - Currently only returns the number of subkeys.  Use |subkey_count|
+//   in a loop for calling QueryRegSubkey.
+bool QueryRegEnumerationInfo(HANDLE key, ULONG* out_subkey_count);
+
+// Enumerate subkeys by index.
+// - Key handle should have been opened with OpenRegKey (with at least
+//   KEY_ENUMERATE_SUB_KEYS access rights).
+// - Get subkey count by calling QueryRegEnumerationInfo.
+bool QueryRegSubkey(HANDLE key,
+                    ULONG subkey_index,
+                    std::wstring* out_subkey_name);
+
 //------------------------------------------------------------------------------
 // Utils
 //------------------------------------------------------------------------------
 
+// Returns the current user SID in string form.
+const wchar_t* GetCurrentUserSidString();
+
+// Returns true if this process is WOW64.
+bool IsCurrentProcWow64();
+
 // Setter function for test suites that use reg redirection.
 bool SetTestingOverride(ROOT_KEY root, const std::wstring& new_path);
 
diff --git a/chrome/chrome_elf/nt_registry/nt_registry_functions.h b/chrome/chrome_elf/nt_registry/nt_registry_functions.h
index 6dfb149d9ef89..bbbd737a7006e 100644
--- a/chrome/chrome_elf/nt_registry/nt_registry_functions.h
+++ b/chrome/chrome_elf/nt_registry/nt_registry_functions.h
@@ -8,6 +8,12 @@
 #include <windows.h>
 #include <winternl.h>
 
+typedef enum _KEY_INFORMATION_CLASS {
+  KeyBasicInformation = 0,
+  KeyFullInformation = 2
+} KEY_INFORMATION_CLASS,
+    *PKEY_INFORMATION_CLASS;
+
 typedef enum _KEY_VALUE_INFORMATION_CLASS {
   KeyValueFullInformation = 1
 } KEY_VALUE_INFORMATION_CLASS,
@@ -22,6 +28,27 @@ typedef struct _KEY_VALUE_FULL_INFORMATION {
   WCHAR Name[1];
 } KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;
 
+typedef struct _KEY_BASIC_INFORMATION {
+  LARGE_INTEGER LastWriteTime;
+  ULONG TitleIndex;
+  ULONG NameLength;
+  WCHAR Name[1];
+} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;
+
+typedef struct _KEY_FULL_INFORMATION {
+  LARGE_INTEGER LastWriteTime;
+  ULONG TitleIndex;
+  ULONG ClassOffset;
+  ULONG ClassLength;
+  ULONG SubKeys;
+  ULONG MaxNameLen;
+  ULONG MaxClassLen;
+  ULONG Values;
+  ULONG MaxValueNameLen;
+  ULONG MaxValueDataLen;
+  WCHAR Class[1];
+} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;
+
 extern "C" {
 // wdm.h.
 NTSTATUS WINAPI NtCreateKey(OUT PHANDLE KeyHandle,
@@ -41,6 +68,21 @@ NTSTATUS WINAPI NtOpenKeyEx(OUT PHANDLE KeyHandle,
 // wdm.h.
 NTSTATUS WINAPI NtDeleteKey(IN HANDLE KeyHandle);
 
+// wdm.h.
+NTSTATUS WINAPI NtQueryKey(IN HANDLE KeyHandle,
+                           IN KEY_INFORMATION_CLASS KeyInformationClass,
+                           OUT PVOID KeyInformation,
+                           IN ULONG Length,
+                           OUT PULONG ResultLength);
+
+// wdm.h.
+NTSTATUS WINAPI NtEnumerateKey(IN HANDLE KeyHandle,
+                               IN ULONG Index,
+                               IN KEY_INFORMATION_CLASS KeyInformationClass,
+                               OUT PVOID KeyInformation,
+                               IN ULONG Length,
+                               OUT PULONG ResultLength);
+
 // wdm.h.
 NTSTATUS WINAPI
 NtQueryValueKey(IN HANDLE KeyHandle,
diff --git a/chrome/chrome_elf/nt_registry/nt_registry_unittest.cc b/chrome/chrome_elf/nt_registry/nt_registry_unittest.cc
index 43cf56ec6a6f0..344b20dffbd91 100644
--- a/chrome/chrome_elf/nt_registry/nt_registry_unittest.cc
+++ b/chrome/chrome_elf/nt_registry/nt_registry_unittest.cc
@@ -567,4 +567,88 @@ TEST_F(NtRegistryTest, CreateRegKeyRecursion) {
   // Clean up done by NtRegistryTest.
 }
 
+TEST_F(NtRegistryTest, ApiEnumeration) {
+  HANDLE key_handle;
+  HANDLE subkey_handle;
+  static constexpr wchar_t key[] = L"NTRegistry\\enum";
+  static constexpr wchar_t subkey1[] = L"NTRegistry\\enum\\subkey1";
+  static constexpr wchar_t subkey2[] = L"NTRegistry\\enum\\subkey2";
+  static constexpr wchar_t subkey3[] = L"NTRegistry\\enum\\subkey3";
+  static constexpr const wchar_t* check_names[] = {
+      L"subkey1",
+      L"subkey2",
+      L"subkey3",
+  };
+  // Test out the "(Default)" value name in this suite.
+  static constexpr wchar_t subkey_val_name[] = L"";
+  DWORD subkey_val = 1234;
+
+  // Create a subkey to play under.
+  // ------------------------------
+  ASSERT_TRUE(nt::CreateRegKey(nt::HKCU, key, KEY_ALL_ACCESS, &key_handle));
+  ASSERT_NE(key_handle, INVALID_HANDLE_VALUE);
+  ASSERT_NE(key_handle, nullptr);
+  base::ScopedClosureRunner key_closer(
+      base::BindOnce(&nt::CloseRegKey, key_handle));
+
+  // Set
+  // ------------------------------
+  // Sub-subkey with a default value.
+  ASSERT_TRUE(
+      nt::CreateRegKey(nt::HKCU, subkey1, KEY_ALL_ACCESS, &subkey_handle));
+  ASSERT_NE(subkey_handle, INVALID_HANDLE_VALUE);
+  ASSERT_NE(subkey_handle, nullptr);
+  EXPECT_TRUE(nt::SetRegValueDWORD(subkey_handle, subkey_val_name, subkey_val));
+  nt::CloseRegKey(subkey_handle);
+
+  // Sub-subkey with a default value.
+  ASSERT_TRUE(
+      nt::CreateRegKey(nt::HKCU, subkey2, KEY_ALL_ACCESS, &subkey_handle));
+  ASSERT_NE(subkey_handle, INVALID_HANDLE_VALUE);
+  ASSERT_NE(subkey_handle, nullptr);
+  EXPECT_TRUE(nt::SetRegValueDWORD(subkey_handle, subkey_val_name, subkey_val));
+  nt::CloseRegKey(subkey_handle);
+
+  // Sub-subkey with a default value.
+  ASSERT_TRUE(
+      nt::CreateRegKey(nt::HKCU, subkey3, KEY_ALL_ACCESS, &subkey_handle));
+  ASSERT_NE(subkey_handle, INVALID_HANDLE_VALUE);
+  ASSERT_NE(subkey_handle, nullptr);
+  EXPECT_TRUE(nt::SetRegValueDWORD(subkey_handle, subkey_val_name, subkey_val));
+  nt::CloseRegKey(subkey_handle);
+
+  // Get (via enumeration)
+  // ------------------------------
+  ULONG subkey_count = 0;
+  EXPECT_TRUE(nt::QueryRegEnumerationInfo(key_handle, &subkey_count));
+  ASSERT_EQ(subkey_count, ULONG{3});
+
+  std::wstring subkey_name;
+  for (ULONG i = 0; i < subkey_count; i++) {
+    ASSERT_TRUE(nt::QueryRegSubkey(key_handle, i, &subkey_name));
+
+    bool found = false;
+    for (size_t index = 0; index < std::size(check_names); index++) {
+      if (0 == subkey_name.compare(check_names[index])) {
+        found = true;
+        break;
+      }
+    }
+    ASSERT_TRUE(found);
+
+    // Grab the default DWORD value out of this subkey.
+    DWORD value = 0;
+    std::wstring temp(key);
+    temp.append(L"\\");
+    temp.append(subkey_name);
+    EXPECT_TRUE(nt::QueryRegValueDWORD(nt::HKCU, nt::NONE, temp.c_str(),
+                                       subkey_val_name, &value));
+    EXPECT_EQ(value, subkey_val);
+  }
+  // Also test a known bad index.
+  EXPECT_FALSE(nt::QueryRegSubkey(key_handle, subkey_count, &subkey_name));
+
+  // Clean up done by NtRegistryTest.
+}
+
 }  // namespace
diff --git a/chrome/chrome_elf/third_party_dlls/hook.cc b/chrome/chrome_elf/third_party_dlls/hook.cc
index a7657dc96ed53..5424d7c66aed5 100644
--- a/chrome/chrome_elf/third_party_dlls/hook.cc
+++ b/chrome/chrome_elf/third_party_dlls/hook.cc
@@ -6,6 +6,7 @@
 
 #include <atomic>
 #include <limits>
+#include <memory>
 
 #include <assert.h>
 #include <ntstatus.h>
@@ -416,10 +417,13 @@ ThirdPartyStatus ApplyHook() {
     return ThirdPartyStatus::kHookInitImportsFailure;
 
   // Prep system-service thunk via the appropriate ServiceResolver instance.
-  sandbox::ServiceResolverThunk thunk(::GetCurrentProcess(), /*relaxed=*/false);
+  std::unique_ptr<sandbox::ServiceResolverThunk> thunk(
+      elf_hook::HookSystemService(false));
+  if (!thunk)
+    return ThirdPartyStatus::kHookUnsupportedOs;
 
   // Set target process to self.
-  thunk.AllowLocalPatches();
+  thunk->AllowLocalPatches();
 
   // Mark the thunk storage as readable and writeable, since we
   // are ready to write to it now.
@@ -437,10 +441,10 @@ ThirdPartyStatus ApplyHook() {
   // Setup() applies the system-service patch, and stores a copy of the original
   // system service coded in |thunk_storage|.
   ntstatus =
-      thunk.Setup(::GetModuleHandle(sandbox::kNtdllName),
-                  reinterpret_cast<void*>(&__ImageBase), "NtMapViewOfSection",
-                  nullptr, reinterpret_cast<void*>(&NewNtMapViewOfSection64),
-                  thunk_storage, sizeof(sandbox::ThunkData), nullptr);
+      thunk->Setup(::GetModuleHandle(sandbox::kNtdllName),
+                   reinterpret_cast<void*>(&__ImageBase), "NtMapViewOfSection",
+                   nullptr, reinterpret_cast<void*>(&NewNtMapViewOfSection64),
+                   thunk_storage, sizeof(sandbox::ThunkData), nullptr);
 
   // Keep a pointer to the original system-service code, which is now in
   // |thunk_storage|.  Use this pointer for passing off execution from new shim.
@@ -457,10 +461,10 @@ ThirdPartyStatus ApplyHook() {
   }
 #else   // x86
   ntstatus =
-      thunk.Setup(::GetModuleHandle(sandbox::kNtdllName),
-                  reinterpret_cast<void*>(&__ImageBase), "NtMapViewOfSection",
-                  nullptr, reinterpret_cast<void*>(&NewNtMapViewOfSection),
-                  thunk_storage, sizeof(sandbox::ThunkData), nullptr);
+      thunk->Setup(::GetModuleHandle(sandbox::kNtdllName),
+                   reinterpret_cast<void*>(&__ImageBase), "NtMapViewOfSection",
+                   nullptr, reinterpret_cast<void*>(&NewNtMapViewOfSection),
+                   thunk_storage, sizeof(sandbox::ThunkData), nullptr);
 #endif  // defined(_WIN64)
 
   if (!NT_SUCCESS(ntstatus)) {
diff --git a/chrome/credential_provider/gaiacp/scoped_user_profile.cc b/chrome/credential_provider/gaiacp/scoped_user_profile.cc
index 88f9a3e349a80..570f67ee8624b 100644
--- a/chrome/credential_provider/gaiacp/scoped_user_profile.cc
+++ b/chrome/credential_provider/gaiacp/scoped_user_profile.cc
@@ -14,8 +14,6 @@
 #include <shlobj.h>
 #include <userenv.h>
 
-#include <memory>
-#include <utility>
 #include <vector>
 
 #include "base/files/file_util.h"
@@ -28,6 +26,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/registry.h"
 #include "base/win/shlwapi.h"
+#include "base/win/windows_version.h"
 #include "chrome/credential_provider/common/gcp_strings.h"
 #include "chrome/credential_provider/gaiacp/gcp_utils.h"
 #include "chrome/credential_provider/gaiacp/gcpw_strings.h"
@@ -259,11 +258,13 @@ HRESULT CreateDirectoryWithRestrictedAccess(const base::FilePath& path) {
   return hr;
 }
 
-HRESULT UpdateProfilePictures(const std::wstring& sid,
-                              const std::wstring& picture_url,
-                              bool force_update) {
+HRESULT UpdateProfilePicturesForWindows8AndNewer(
+    const std::wstring& sid,
+    const std::wstring& picture_url,
+    bool force_update) {
   DCHECK(!sid.empty());
   DCHECK(!picture_url.empty());
+  DCHECK(base::win::GetVersion() >= base::win::Version::WIN8);
 
   // Try to download profile pictures of all required sizes for windows.
   // Needed profile picture sizes are in |kProfilePictureSizes|.
@@ -589,20 +590,24 @@ HRESULT ScopedUserProfile::SaveAccountInfo(const base::Value& properties) {
     }
   }
 
-  std::wstring picture_url = GetDictString(properties, kKeyPicture);
-  if (!picture_url.empty() && !sid.empty()) {
-    wchar_t old_picture_url[512];
-    ULONG url_size = std::size(old_picture_url);
-    hr = GetUserProperty(sid, kUserPictureUrl, old_picture_url, &url_size);
-
-    UpdateProfilePictures(sid, picture_url,
-                          FAILED(hr) || old_picture_url != picture_url);
-    hr = SetUserProperty(sid.c_str(), kUserPictureUrl, picture_url.c_str());
-    if (FAILED(hr)) {
-      LOGFN(ERROR) << "SetUserProperty(pic) hr=" << putHR(hr);
-      return hr;
+  // This code for setting profile pictures is specific for windows 8+.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    std::wstring picture_url = GetDictString(properties, kKeyPicture);
+    if (!picture_url.empty() && !sid.empty()) {
+      wchar_t old_picture_url[512];
+      ULONG url_size = std::size(old_picture_url);
+      hr = GetUserProperty(sid, kUserPictureUrl, old_picture_url, &url_size);
+
+      UpdateProfilePicturesForWindows8AndNewer(
+          sid, picture_url, FAILED(hr) || old_picture_url != picture_url);
+      hr = SetUserProperty(sid.c_str(), kUserPictureUrl, picture_url.c_str());
+      if (FAILED(hr)) {
+        LOGFN(ERROR) << "SetUserProperty(pic) hr=" << putHR(hr);
+        return hr;
+      }
     }
   }
+
   return S_OK;
 }
 
diff --git a/chrome/credential_provider/test/gcp_gls_output_unittest.cc b/chrome/credential_provider/test/gcp_gls_output_unittest.cc
index 2699f1b1634e1..fcf4402fa60d2 100644
--- a/chrome/credential_provider/test/gcp_gls_output_unittest.cc
+++ b/chrome/credential_provider/test/gcp_gls_output_unittest.cc
@@ -72,6 +72,16 @@ class GcpUsingChromeTest : public ::testing::Test {
   std::string RunProcessAndExtractOutput(
       const base::CommandLine& command_line) const;
 
+  bool ShouldRunTestOnThisOS() const {
+    // TODO(crbug.com/909722) Enable tests again once they are all passing. Currently, all tests are
+    // flaky on all bots except win-asan.
+    return false;
+    // TODO(crbug.com/906793). For some reason handle inheritance does not work
+    // correctly on Windows7 and causes all the tests to stall indefinetely.
+    // Since GCPW is only targeted for Windows 10 currently, disable these
+    // unit tests for now until the problem can be resolved.
+    // return base::win::GetVersion() >= base::win::Version::WIN10;
+  }
   std::unique_ptr<net::test_server::HttpResponse> GaiaHtmlResponseHandler(
       const net::test_server::HttpRequest& request);
   std::unique_ptr<net::test_server::HttpResponse> GoogleApisHtmlResponseHandler(
@@ -92,6 +102,9 @@ GcpUsingChromeTest::GcpUsingChromeTest()
     : proxy_server_(net::SpawnedTestServer::TYPE_PROXY, base::FilePath()) {}
 
 void GcpUsingChromeTest::SetUp() {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   // Redirect connections to signin related pages to a handler that will
   // generate the needed headers and content to move the signin flow
   // forward automatically.
@@ -111,6 +124,9 @@ void GcpUsingChromeTest::SetUp() {
 }
 
 void GcpUsingChromeTest::TearDown() {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   EXPECT_TRUE(gaia_server_.ShutdownAndWaitUntilComplete());
   EXPECT_TRUE(google_apis_server_.ShutdownAndWaitUntilComplete());
   EXPECT_TRUE(proxy_server_.Stop());
@@ -328,9 +344,10 @@ GcpUsingChromeTest::GoogleApisHtmlResponseHandler(
   return std::move(http_response);
 }
 
-// TODO(crbug.com/909722): Enable tests again once they are all passing.
-// Currently, all tests are flaky on all bots except win-asan.
-TEST_F(GcpUsingChromeTest, DISABLED_VerifyMissingSigninInfoOutput) {
+TEST_F(GcpUsingChromeTest, VerifyMissingSigninInfoOutput) {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   SetPasswordForSignin(std::string());
   SetTokenInfoResponse(
       {net::HTTP_OK, test_data_storage_.GetSuccessfulTokenInfoFetchResult()});
@@ -350,7 +367,10 @@ TEST_F(GcpUsingChromeTest, DISABLED_VerifyMissingSigninInfoOutput) {
   EXPECT_FALSE(mdm_token_response_.response_given_);
 }
 
-TEST_F(GcpUsingChromeTest, DISABLED_VerifySigninFailureOutput) {
+TEST_F(GcpUsingChromeTest, VerifySigninFailureOutput) {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   SetTokenInfoResponse(
       {net::HTTP_OK, test_data_storage_.GetSuccessfulTokenInfoFetchResult()});
   SetUserInfoResponse(
@@ -370,7 +390,10 @@ TEST_F(GcpUsingChromeTest, DISABLED_VerifySigninFailureOutput) {
   EXPECT_FALSE(mdm_token_response_.response_given_);
 }
 
-TEST_F(GcpUsingChromeTest, DISABLED_VerifyTokenInfoFailureOutput) {
+TEST_F(GcpUsingChromeTest, VerifyTokenInfoFailureOutput) {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   SetTokenInfoResponse({net::HTTP_OK,
                         CredentialProviderSigninDialogTestDataStorage::
                             kInvalidTokenInfoResponse});
@@ -388,7 +411,10 @@ TEST_F(GcpUsingChromeTest, DISABLED_VerifyTokenInfoFailureOutput) {
   EXPECT_TRUE(token_info_response_.response_given_);
 }
 
-TEST_F(GcpUsingChromeTest, DISABLED_VerifyUserInfoFailureOutput) {
+TEST_F(GcpUsingChromeTest, VerifyUserInfoFailureOutput) {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   SetTokenInfoResponse(
       {net::HTTP_OK, test_data_storage_.GetSuccessfulTokenInfoFetchResult()});
   SetUserInfoResponse({net::HTTP_OK,
@@ -407,7 +433,10 @@ TEST_F(GcpUsingChromeTest, DISABLED_VerifyUserInfoFailureOutput) {
   EXPECT_TRUE(mdm_token_response_.response_given_);
 }
 
-TEST_F(GcpUsingChromeTest, DISABLED_VerifyMdmFailureOutput) {
+TEST_F(GcpUsingChromeTest, VerifyMdmFailureOutput) {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   SetTokenInfoResponse(
       {net::HTTP_OK, test_data_storage_.GetSuccessfulTokenInfoFetchResult()});
   SetUserInfoResponse(
@@ -425,7 +454,10 @@ TEST_F(GcpUsingChromeTest, DISABLED_VerifyMdmFailureOutput) {
   EXPECT_FALSE(user_info_response_.response_given_);
 }
 
-TEST_F(GcpUsingChromeTest, DISABLED_VerifySuccessOutput) {
+TEST_F(GcpUsingChromeTest, VerifySuccessOutput) {
+  if (!ShouldRunTestOnThisOS())
+    return;
+
   SetTokenInfoResponse(
       {net::HTTP_OK, test_data_storage_.GetSuccessfulTokenInfoFetchResult()});
   SetUserInfoResponse(
diff --git a/chrome/installer/setup/install.cc b/chrome/installer/setup/install.cc
index fa6c6071b866f..a43259c867538 100644
--- a/chrome/installer/setup/install.cc
+++ b/chrome/installer/setup/install.cc
@@ -27,6 +27,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/setup/install_params.h"
@@ -134,6 +135,7 @@ void ExecuteAndLogShortcutOperation(
   // For Start Menu shortcut creation on versions of Win10 that support
   // pinning, record whether or not the installer pinned Chrome.
   if (location == ShellUtil::SHORTCUT_LOCATION_START_MENU_ROOT &&
+      base::win::GetVersion() >= base::win::Version::WIN10 &&
       CanPinShortcutToTaskbar()) {
     SetInstallerPinnedChromeToTaskbar(properties.pin_to_taskbar && pinned);
   }
diff --git a/chrome/installer/setup/setup_main.cc b/chrome/installer/setup/setup_main.cc
index bb3de1c5d19c2..03978429a66d3 100644
--- a/chrome/installer/setup/setup_main.cc
+++ b/chrome/installer/setup/setup_main.cc
@@ -1571,10 +1571,10 @@ int WINAPI wWinMain(HINSTANCE instance,
   if (is_uninstall)
     persistent_histogram_storage.Disable();
 
-  // Check to make sure current system is Win10 or later. If not, log
+  // Check to make sure current system is Win7 or later. If not, log
   // error message and get out.
   if (!InstallUtil::IsOSSupported()) {
-    LOG(ERROR) << "Chrome only supports Windows 10 or later.";
+    LOG(ERROR) << "Chrome only supports Windows 7 or later.";
     installer_state.WriteInstallerResult(installer::OS_NOT_SUPPORTED,
                                          IDS_INSTALL_OS_NOT_SUPPORTED_BASE,
                                          nullptr);
diff --git a/chrome/installer/setup/user_experiment.cc b/chrome/installer/setup/user_experiment.cc
index 175c4d5ba6953..397088ee363e5 100644
--- a/chrome/installer/setup/user_experiment.cc
+++ b/chrome/installer/setup/user_experiment.cc
@@ -24,6 +24,7 @@
 #include "base/win/scoped_handle.h"
 #include "base/win/scoped_process_information.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "chrome/common/chrome_switches.h"
 #include "chrome/common/chrome_version.h"
@@ -224,6 +225,10 @@ bool ShouldRunUserExperiment(const InstallerState& installer_state) {
   if (!install_static::SupportsRetentionExperiments())
     return false;
 
+  // The current experiment only applies to Windows 10 and newer.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return false;
+
   // Installs originating from the MSI and domain joined machines are excluded.
   if (IsEnterpriseInstall(installer_state))
     return false;
diff --git a/chrome/installer/util/install_util.cc b/chrome/installer/util/install_util.cc
index 8013329229151..02d5b2c80d104 100644
--- a/chrome/installer/util/install_util.cc
+++ b/chrome/installer/util/install_util.cc
@@ -242,10 +242,10 @@ base::Version InstallUtil::GetCriticalUpdateVersion() {
 }
 
 bool InstallUtil::IsOSSupported() {
-  // We do not support anything prior to Windows 10.
+  // We do not support anything prior to Windows 7.
   VLOG(1) << base::SysInfo::OperatingSystemName() << ' '
           << base::SysInfo::OperatingSystemVersion();
-  return base::win::GetVersion() >= base::win::Version::WIN10;
+  return base::win::GetVersion() >= base::win::Version::WIN7;
 }
 
 void InstallUtil::AddInstallerResultItems(bool system_install,
diff --git a/chrome/installer/util/shell_util.cc b/chrome/installer/util/shell_util.cc
index 2c43e6bd401cb..ade7770d1ca69 100644
--- a/chrome/installer/util/shell_util.cc
+++ b/chrome/installer/util/shell_util.cc
@@ -12,6 +12,7 @@
 #include <objbase.h>
 #include <shlobj.h>
 #include <shobjidl.h>
+#include <windows.h>
 #include <wrl/client.h>
 
 #include <algorithm>
@@ -67,6 +68,7 @@
 #include "chrome/installer/util/l10n_string_util.h"
 #include "chrome/installer/util/registry_entry.h"
 #include "chrome/installer/util/registry_util.h"
+#include "chrome/installer/util/scoped_user_protocol_entry.h"
 #include "chrome/installer/util/taskbar_util.h"
 #include "chrome/installer/util/util_constants.h"
 #include "chrome/installer/util/work_item.h"
@@ -298,11 +300,13 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
     entries->back()->set_removal_flag(RegistryEntry::RemovalFlag::VALUE);
   }
 
-  // The following entries are required but do not depend on the DelegateExecute
-  // verb handler being set.
-  if (!app_info.app_id.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+  // The following entries are required as of Windows 8, but do not
+  // depend on the DelegateExecute verb handler being set.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    if (!app_info.app_id.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+    }
   }
 
   // Add \Software\Classes\<prog_id>\Application entries
@@ -713,6 +717,26 @@ bool ElevateAndRegisterChrome(
   return false;
 }
 
+// Launches the Windows 7 and Windows 8 dialog for picking the application to
+// handle the given protocol. Most importantly, this is used to set the default
+// handler for http (and, implicitly with it, https). In that case it is also
+// known as the 'how do you want to open webpages' dialog.
+// It is required that Chrome be already *registered* for the given protocol.
+bool LaunchSelectDefaultProtocolHandlerDialog(const wchar_t* protocol) {
+  DCHECK(protocol);
+  OPENASINFO open_as_info = {};
+  open_as_info.pcszFile = protocol;
+  open_as_info.oaifInFlags =
+      OAIF_URL_PROTOCOL | OAIF_FORCE_REGISTRATION | OAIF_REGISTER_EXT;
+  HRESULT hr = SHOpenWithDialog(nullptr, &open_as_info);
+  DLOG_IF(WARNING, FAILED(hr)) << "Failed to set as default " << protocol
+                               << " handler; hr=0x" << std::hex << hr;
+  if (FAILED(hr))
+    return false;
+  SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, nullptr, nullptr);
+  return true;
+}
+
 // Returns true if |chrome_exe| has been registered with |suffix| for |mode|.
 // |confirmation_level| is the level of verification desired as described in
 // the RegistrationConfirmationLevel enum above.
@@ -747,11 +771,12 @@ bool QuickIsChromeRegisteredForMode(
   }
   reg_key += ShellUtil::kRegShellOpen;
 
-  // ProgId and shell integration registrations are allowed to reside in HKCU
-  // for user-level installs, and values there have priority over values in
-  // HKLM.
+  // ProgId registrations are allowed to reside in HKCU for user-level installs
+  // (and values there have priority over values in HKLM). The same is true for
+  // shell integration entries as of Windows 8.
   if (confirmation_level == CONFIRM_PROGID_REGISTRATION ||
-      confirmation_level == CONFIRM_SHELL_REGISTRATION) {
+      (confirmation_level == CONFIRM_SHELL_REGISTRATION &&
+       base::win::GetVersion() >= base::win::Version::WIN8)) {
     const RegKey key_hkcu(HKEY_CURRENT_USER, reg_key.c_str(), KEY_QUERY_VALUE);
     std::wstring hkcu_value;
     // If |reg_key| is present in HKCU, assert that it points to |chrome_exe|.
@@ -768,6 +793,49 @@ bool QuickIsChromeRegisteredForMode(
   return false;
 }
 
+// Returns the installation suffix for |mode| at the system or user level based
+// on |system_install|.
+std::wstring GetInstallationSuffixForModeAtLevel(
+    const install_static::InstallConstants& mode,
+    bool system_install) {
+  // Search based on the existing install location. If no existing install
+  // found, uses the default install location for the mode.
+  const base::FilePath chrome_exe =
+      installer::GetChromeInstallPath(system_install)
+          .Append(installer::kChromeExe);
+
+  // See the comment in ShellUtil::GetCurrentInstallationSuffix for details on
+  // what's going on here.
+  std::wstring tested_suffix;
+  if (!system_install &&
+      (!ShellUtil::GetUserSpecificRegistrySuffix(&tested_suffix) ||
+       !QuickIsChromeRegisteredForMode(chrome_exe, tested_suffix, mode,
+                                       CONFIRM_PROGID_REGISTRATION)) &&
+      (!ShellUtil::GetOldUserSpecificRegistrySuffix(&tested_suffix) ||
+       !QuickIsChromeRegisteredForMode(chrome_exe, tested_suffix, mode,
+                                       CONFIRM_PROGID_REGISTRATION)) &&
+      !QuickIsChromeRegisteredForMode(chrome_exe, tested_suffix.erase(), mode,
+                                      CONFIRM_PROGID_REGISTRATION)) {
+    // If Chrome is not registered under any of the possible suffixes (e.g.
+    // tests, Canary, etc.): use the new-style suffix at run-time.
+    if (!ShellUtil::GetUserSpecificRegistrySuffix(&tested_suffix))
+      NOTREACHED();
+  }
+  return tested_suffix;
+}
+
+// Returns |mode|'s application name at the system or user level based on
+// |system_install|. This application name will be suffixed as is appropriate
+// for the install. This is the name that is registered with Default Programs on
+// Windows and that should thus be used to "make chrome default" and such.
+std::wstring GetApplicationNameForModeAtLevel(
+    const install_static::InstallConstants& mode,
+    bool system_install) {
+  return base::StrCat(
+      {std::wstring(mode.base_app_name),
+       GetInstallationSuffixForModeAtLevel(mode, system_install)});
+}
+
 // Returns true if the current install's |chrome_exe| has been registered with
 // |suffix|.
 // |confirmation_level| is the level of verification desired as described in
@@ -826,7 +894,9 @@ bool GetInstallationSpecificSuffix(const base::FilePath& chrome_exe,
 // be placed for this install. As of Windows 8 everything can go in HKCU for
 // per-user installs.
 HKEY DetermineRegistrationRoot(bool is_per_user) {
-  return is_per_user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
+  return is_per_user && base::win::GetVersion() >= base::win::Version::WIN8
+             ? HKEY_CURRENT_USER
+             : HKEY_LOCAL_MACHINE;
 }
 
 // Associates Chrome with supported protocols and file associations. This should
@@ -950,16 +1020,19 @@ base::win::ShortcutProperties TranslateShortcutProperties(
 // Cleans up an old verb (run) we used to register in
 // <root>\Software\Classes\Chrome<.suffix>\.exe\shell\run on Windows 8.
 void RemoveRunVerbOnWindows8() {
-  bool is_per_user_install = InstallUtil::IsPerUserInstall();
-  HKEY root_key = DetermineRegistrationRoot(is_per_user_install);
-  // There's no need to rollback, so forgo the usual work item lists and just
-  // remove the key from the registry.
-  std::wstring run_verb_key =
-      base::StrCat({ShellUtil::kRegClasses, kFilePathSeparator,
-                    ShellUtil::GetBrowserModelId(is_per_user_install),
-                    ShellUtil::kRegExePath, ShellUtil::kRegShellPath,
-                    kFilePathSeparator, ShellUtil::kRegVerbRun});
-  installer::DeleteRegistryKey(root_key, run_verb_key, WorkItem::kWow64Default);
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    bool is_per_user_install = InstallUtil::IsPerUserInstall();
+    HKEY root_key = DetermineRegistrationRoot(is_per_user_install);
+    // There's no need to rollback, so forgo the usual work item lists and just
+    // remove the key from the registry.
+    std::wstring run_verb_key =
+        base::StrCat({ShellUtil::kRegClasses, kFilePathSeparator,
+                      ShellUtil::GetBrowserModelId(is_per_user_install),
+                      ShellUtil::kRegExePath, ShellUtil::kRegShellPath,
+                      kFilePathSeparator, ShellUtil::kRegVerbRun});
+    installer::DeleteRegistryKey(root_key, run_verb_key,
+                                 WorkItem::kWow64Default);
+  }
 }
 
 // Probe using IApplicationAssociationRegistration::QueryCurrentDefault
@@ -1026,6 +1099,70 @@ ShellUtil::DefaultState ProbeCurrentDefaultHandlers(
                                : ShellUtil::IS_DEFAULT;
 }
 
+// Probe using IApplicationAssociationRegistration::QueryAppIsDefault (Vista and
+// Windows 7); see ProbeProtocolHandlers.
+ShellUtil::DefaultState ProbeAppIsDefaultHandlers(
+    const base::FilePath& chrome_exe,
+    const wchar_t* const* protocols,
+    size_t num_protocols) {
+  Microsoft::WRL::ComPtr<IApplicationAssociationRegistration> registration;
+  HRESULT hr =
+      ::CoCreateInstance(CLSID_ApplicationAssociationRegistration, nullptr,
+                         CLSCTX_INPROC, IID_PPV_ARGS(&registration));
+  if (FAILED(hr))
+    return ShellUtil::UNKNOWN_DEFAULT;
+
+  std::wstring app_name(GetApplicationName(chrome_exe));
+
+  // Generate the app names for this brand's other install modes at both user
+  // and system levels.
+  const int current_install_mode_index =
+      install_static::InstallDetails::Get().install_mode_index();
+  std::wstring other_app_names[install_static::NUM_INSTALL_MODES * 2];
+  for (int mode_index = 0; mode_index < install_static::NUM_INSTALL_MODES;
+       ++mode_index) {
+    if (mode_index == current_install_mode_index)
+      continue;  // Leave the entry for the current mode empty.
+    other_app_names[mode_index * 2] = GetApplicationNameForModeAtLevel(
+        install_static::kInstallModes[mode_index], false);
+    other_app_names[mode_index * 2 + 1] = GetApplicationNameForModeAtLevel(
+        install_static::kInstallModes[mode_index], true);
+  }
+
+  // Now check each protocol to see if this brand is default for all. This loop
+  // terminates when this brand is the default handler for the protocols.
+  bool other_mode_is_default = false;
+  for (size_t i = 0; i < num_protocols; ++i) {
+    const wchar_t* protocol = protocols[i];
+    BOOL result = TRUE;
+    // Check the current app name. This will fail (e.g., ERROR_FILE_NOT_FOUND)
+    // if |app_name| isn't registered.
+    hr = registration->QueryAppIsDefault(protocol, AT_URLPROTOCOL, AL_EFFECTIVE,
+                                         app_name.c_str(), &result);
+    if (SUCCEEDED(hr) && result)
+      continue;
+
+    // Search for a different install mode that is the default handler.
+    if (base::ranges::none_of(
+            other_app_names,
+            [&registration, protocol](const std::wstring& app_name) {
+              if (app_name.empty())
+                return false;
+              BOOL result = TRUE;
+              HRESULT hr = registration->QueryAppIsDefault(
+                  protocol, AT_URLPROTOCOL, AL_EFFECTIVE, app_name.c_str(),
+                  &result);
+              return SUCCEEDED(hr) && result;
+            })) {
+      return ShellUtil::NOT_DEFAULT;
+    }
+    other_mode_is_default = true;
+  }
+
+  return other_mode_is_default ? ShellUtil::OTHER_MODE_IS_DEFAULT
+                               : ShellUtil::IS_DEFAULT;
+}
+
 // A helper function that probes default protocol handler registration (in a
 // manner appropriate for the current version of Windows) to determine if
 // Chrome is the default handler for |protocols|.  Returns IS_DEFAULT
@@ -1038,13 +1175,20 @@ ShellUtil::DefaultState ProbeProtocolHandlers(const base::FilePath& chrome_exe,
   for (size_t i = 0; i < num_protocols; ++i)
     DCHECK(protocols[i] && *protocols[i]);
 #endif
-  return ProbeCurrentDefaultHandlers(chrome_exe, protocols, num_protocols);
+
+  const base::win::Version windows_version = base::win::GetVersion();
+
+  if (windows_version >= base::win::Version::WIN8)
+    return ProbeCurrentDefaultHandlers(chrome_exe, protocols, num_protocols);
+
+  return ProbeAppIsDefaultHandlers(chrome_exe, protocols, num_protocols);
 }
 
-// Finds and stores an app shortcuts folder path in *`path`.
+// (Windows 8+) Finds and stores an app shortcuts folder path in *|path|.
 // Returns true on success.
 bool GetAppShortcutsFolder(ShellUtil::ShellChange level, base::FilePath* path) {
   DCHECK(path);
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN8);
 
   base::FilePath folder;
   if (!base::PathService::Get(base::DIR_APP_SHORTCUTS, &folder)) {
@@ -1426,6 +1570,8 @@ bool RegisterChromeBrowserImpl(const base::FilePath& chrome_exe,
 bool RegisterApplicationForProtocols(const std::vector<std::wstring>& protocols,
                                      const std::wstring& prog_id,
                                      const base::FilePath& chrome_exe) {
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
+
   std::vector<std::unique_ptr<RegistryEntry>> entries;
   ShellUtil::ApplicationInfo app_info =
       ShellUtil::GetApplicationInfoForProgId(prog_id);
@@ -1787,10 +1933,12 @@ bool ShellUtil::ShortcutLocationIsSupported(ShortcutLocation location) {
     case SHORTCUT_LOCATION_START_MENU_ROOT:                   // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_DIR_DEPRECATED:  // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_APPS_DIR:        // Falls through.
-    case SHORTCUT_LOCATION_STARTUP:                           // Falls through.
-    case SHORTCUT_LOCATION_TASKBAR_PINS:                      // Falls through.
-    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+    case SHORTCUT_LOCATION_STARTUP:
       return true;
+    case SHORTCUT_LOCATION_TASKBAR_PINS:
+      return base::win::GetVersion() >= base::win::Version::WIN7;
+    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+      return base::win::GetVersion() >= base::win::Version::WIN8;
     default:
       NOTREACHED();
       return false;
@@ -2202,6 +2350,16 @@ bool ShellUtil::CanMakeChromeDefaultUnattended() {
   return base::win::GetVersion() < base::win::Version::WIN8;
 }
 
+// static
+ShellUtil::InteractiveSetDefaultMode ShellUtil::GetInteractiveSetDefaultMode() {
+  DCHECK(!CanMakeChromeDefaultUnattended());
+
+  if (base::win::GetVersion() >= base::win::Version::WIN10)
+    return InteractiveSetDefaultMode::SYSTEM_SETTINGS;
+
+  return InteractiveSetDefaultMode::INTENT_PICKER;
+}
+
 bool ShellUtil::MakeChromeDefault(int shell_change,
                                   const base::FilePath& chrome_exe,
                                   bool elevate_if_not_admin) {
@@ -2269,6 +2427,9 @@ bool ShellUtil::MakeChromeDefaultDirectly(int shell_change,
                                           bool elevate_if_not_admin) {
   DCHECK(!(shell_change & SYSTEM_LEVEL) || IsUserAnAdmin());
 
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return false;
+
   if (!install_static::SupportsSetAsDefaultBrowser())
     return false;
 
@@ -2339,6 +2500,8 @@ bool ShellUtil::MakeChromeDefaultDirectly(int shell_change,
 
 // static
 bool ShellUtil::LaunchUninstallAppsSettings() {
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
+
   static constexpr wchar_t kControlPanelAppModelId[] =
       L"windows.immersivecontrolpanel_cw5n1h2txyewy"
       L"!microsoft.windows.immersivecontrolpanel";
@@ -2369,8 +2532,26 @@ bool ShellUtil::ShowMakeChromeDefaultSystemUI(
   bool succeeded = true;
   bool is_default = (GetChromeDefaultState() == IS_DEFAULT);
   if (!is_default) {
-    // Launch the Windows Apps Settings dialog.
-    succeeded = base::win::LaunchDefaultAppsSettingsModernDialog(L"http");
+    switch (GetInteractiveSetDefaultMode()) {
+      case INTENT_PICKER: {
+        // On Windows 8, you can't set yourself as the default handler
+        // programmatically. In other words IApplicationAssociationRegistration
+        // has been rendered useless. What you can do is to launch
+        // "Set Program Associations" section of the "Default Programs"
+        // control panel, which is a mess, or pop the concise "How you want to
+        // open webpages?" dialog.  We choose the latter.
+        ScopedUserProtocolEntry user_protocol_entry(L"http");
+        succeeded = LaunchSelectDefaultProtocolHandlerDialog(L"http");
+      } break;
+      case SYSTEM_SETTINGS:
+        // On Windows 10, you can't even launch the associations dialog.
+        // So we launch the settings dialog. Quoting from MSDN: "The Open With
+        // dialog box can no longer be used to change the default program used
+        // to open a file extension. You can only use SHOpenWithDialog to open
+        // a single file."
+        succeeded = base::win::LaunchDefaultAppsSettingsModernDialog(L"http");
+        break;
+    }
     is_default = (succeeded && GetChromeDefaultState() == IS_DEFAULT);
   }
   if (succeeded && is_default)
@@ -2442,9 +2623,25 @@ bool ShellUtil::ShowMakeChromeDefaultProtocolClientSystemUI(
   bool is_default =
       (GetChromeDefaultProtocolClientState(protocol) == IS_DEFAULT);
   if (!is_default) {
-    // Launch the Windows settings dialog.
-    succeeded =
-        base::win::LaunchDefaultAppsSettingsModernDialog(protocol.c_str());
+    switch (GetInteractiveSetDefaultMode()) {
+      case INTENT_PICKER: {
+        // On Windows 8, you can't set yourself as the default handler
+        // programmatically. In other words IApplicationAssociationRegistration
+        // has been rendered useless. What you can do is to launch
+        // "Set Program Associations" section of the "Default Programs"
+        // control panel, which is a mess, or pop the concise "How you want to
+        // open
+        // links of this type (protocol)?" dialog.  We choose the latter.
+        ScopedUserProtocolEntry user_protocol_entry(protocol.c_str());
+        succeeded = LaunchSelectDefaultProtocolHandlerDialog(protocol.c_str());
+      } break;
+      case SYSTEM_SETTINGS:
+        // On Windows 10, you can't even launch the associations dialog.
+        // So we launch the settings dialog.
+        succeeded =
+            base::win::LaunchDefaultAppsSettingsModernDialog(protocol.c_str());
+        break;
+    }
     is_default = (succeeded &&
                   GetChromeDefaultProtocolClientState(protocol) == IS_DEFAULT);
   }
@@ -2787,6 +2984,8 @@ bool ShellUtil::AddAppProtocolAssociations(
     const std::vector<std::wstring>& protocols,
     const std::wstring& prog_id) {
   base::FilePath chrome_exe;
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
+
   if (!base::PathService::Get(base::FILE_EXE, &chrome_exe)) {
     NOTREACHED();
     return false;
@@ -2809,13 +3008,17 @@ bool ShellUtil::AddAppProtocolAssociations(
     if (!AddRegistryEntries(HKEY_CURRENT_USER, entries))
       success = false;
 
-    // Removing the existing user choice for a given protocol forces Windows to
-    // present a disambiguation dialog the next time this protocol is invoked
-    // from the OS.
-    std::unique_ptr<RegistryEntry> entry = GetProtocolUserChoiceEntry(protocol);
-    if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
-                                        WorkItem::kWow64Default, kRegProgId)) {
-      success = false;
+    // On Windows 10, removing the existing user choice for a given protocol
+    // forces Windows to present a disambiguation dialog the next time this
+    // protocol is invoked from the OS.
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      std::unique_ptr<RegistryEntry> entry =
+          GetProtocolUserChoiceEntry(protocol);
+      if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
+                                          WorkItem::kWow64Default,
+                                          kRegProgId)) {
+        success = false;
+      }
     }
   }
 
@@ -2824,6 +3027,8 @@ bool ShellUtil::AddAppProtocolAssociations(
 
 // static
 bool ShellUtil::RemoveAppProtocolAssociations(const std::wstring& prog_id) {
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
+
   // Delete the |prog_id| value from HKEY_CURRENT_USER\RegisteredApplications.
   installer::DeleteRegistryValue(HKEY_CURRENT_USER,
                                  ShellUtil::kRegRegisteredApplications,
diff --git a/chrome/installer/util/shell_util.h b/chrome/installer/util/shell_util.h
index 46fb4516fa7be..91532504dc6b5 100644
--- a/chrome/installer/util/shell_util.h
+++ b/chrome/installer/util/shell_util.h
@@ -495,6 +495,19 @@ class ShellUtil {
   // Windows prior to Windows 8.
   static bool CanMakeChromeDefaultUnattended();
 
+  enum InteractiveSetDefaultMode {
+    // The intent picker is opened with the different choices available to the
+    // user.
+    INTENT_PICKER,
+    // The Windows default apps settings page is opened with the current default
+    // app focused.
+    SYSTEM_SETTINGS,
+  };
+
+  // Returns the interactive mode that should be used to set the default browser
+  // or default protocol client on Windows 8+.
+  static InteractiveSetDefaultMode GetInteractiveSetDefaultMode();
+
   // Returns the DefaultState of Chrome for HTTP and HTTPS and updates the
   // default browser beacons as appropriate.
   static DefaultState GetChromeDefaultState();
diff --git a/chrome/installer/util/shell_util_interactive_uitest.cc b/chrome/installer/util/shell_util_interactive_uitest.cc
index d4537b479ee79..16e533dd4cf3d 100644
--- a/chrome/installer/util/shell_util_interactive_uitest.cc
+++ b/chrome/installer/util/shell_util_interactive_uitest.cc
@@ -21,6 +21,7 @@
 #include "base/win/registry.h"
 #include "base/win/scoped_co_mem.h"
 #include "chrome/browser/chrome_for_testing/buildflags.h"
+#include "base/win/windows_version.h"
 #include "chrome/installer/util/util_constants.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
@@ -120,6 +121,10 @@ class ScopedCopyRegKey {
 }  // namespace
 
 TEST(ShellUtilInteractiveTest, MakeChromeDefaultDirectly) {
+  // Direct default setting is only supported on Win10 or above.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    GTEST_SKIP();
+
   base::win::AssertComInitialized();
 
   base::ScopedTempDir temp_dir;
diff --git a/chrome/installer/util/shell_util_unittest.cc b/chrome/installer/util/shell_util_unittest.cc
index 8bfedde6c86c6..1de0e2b6f2c1a 100644
--- a/chrome/installer/util/shell_util_unittest.cc
+++ b/chrome/installer/util/shell_util_unittest.cc
@@ -25,6 +25,7 @@
 #include "base/test/test_shortcut_win.h"
 #include "base/win/registry.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/util/install_util.h"
 #include "chrome/installer/util/util_constants.h"
@@ -1152,13 +1153,16 @@ TEST_F(ShellUtilRegistryTest, AddFileAssociations) {
   EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"", &value));
   EXPECT_EQ(L"\"C:\\test.exe\" --single-argument %1", value);
 
-  ASSERT_EQ(ERROR_SUCCESS,
-            key.Open(HKEY_CURRENT_USER,
-                     L"Software\\Classes\\TestApp\\Application", KEY_READ));
-  EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationName", &value));
-  EXPECT_EQ(L"Test Application", value);
-  EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationIcon", &value));
-  EXPECT_EQ(L"D:\\test.ico,0", value);
+  // The Application subkey and values are only required by Windows 8 and later.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    ASSERT_EQ(ERROR_SUCCESS,
+              key.Open(HKEY_CURRENT_USER,
+                       L"Software\\Classes\\TestApp\\Application", KEY_READ));
+    EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationName", &value));
+    EXPECT_EQ(L"Test Application", value);
+    EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationIcon", &value));
+    EXPECT_EQ(L"D:\\test.ico,0", value);
+  }
 
   // .test1 should not be default-associated with our test app. Programmatically
   // becoming the default handler can be surprising to users, and risks
@@ -1257,13 +1261,16 @@ TEST_F(ShellUtilRegistryTest, AddApplicationClass) {
   EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"", &value));
   EXPECT_EQ(L"\"C:\\test.exe\" --single-argument %1", value);
 
-  ASSERT_EQ(ERROR_SUCCESS,
-            key.Open(HKEY_CURRENT_USER,
-                     L"Software\\Classes\\TestApp\\Application", KEY_READ));
-  EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationName", &value));
-  EXPECT_EQ(L"Test Application", value);
-  EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationIcon", &value));
-  EXPECT_EQ(L"D:\\test.ico,0", value);
+  // The Application subkey and values are only required by Windows 8 and later.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    ASSERT_EQ(ERROR_SUCCESS,
+              key.Open(HKEY_CURRENT_USER,
+                       L"Software\\Classes\\TestApp\\Application", KEY_READ));
+    EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationName", &value));
+    EXPECT_EQ(L"Test Application", value);
+    EXPECT_EQ(ERROR_SUCCESS, key.ReadValue(L"ApplicationIcon", &value));
+    EXPECT_EQ(L"D:\\test.ico,0", value);
+  }
 }
 
 TEST_F(ShellUtilRegistryTest, DeleteApplicationClass) {
@@ -1317,7 +1324,8 @@ TEST_F(ShellUtilRegistryTest, GetApplicationInfoForProgId) {
 
   EXPECT_EQ(L"\"C:\\test.exe\" --single-argument %1", app_info.command_line);
 
-  EXPECT_EQ(L"", app_info.app_id);
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    EXPECT_EQ(L"", app_info.app_id);
 
   EXPECT_EQ(kTestApplicationName, app_info.application_name);
   EXPECT_EQ(kTestApplicationDescription, app_info.application_description);
@@ -1328,6 +1336,10 @@ TEST_F(ShellUtilRegistryTest, GetApplicationInfoForProgId) {
 }
 
 TEST_F(ShellUtilRegistryTest, AddAppProtocolAssociations) {
+  // App protocol handlers are not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   // Create test protocol associations.
   const std::wstring app_progid = L"app_progid1";
   const std::vector<std::wstring> app_protocols = {L"web+test", L"mailto"};
@@ -1403,6 +1415,10 @@ TEST_F(ShellUtilRegistryTest, ToAndFromCommandLineArgument) {
 }
 
 TEST_F(ShellUtilRegistryTest, RemoveAppProtocolAssociations) {
+  // App protocol handlers are not supported on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   // Create test protocol associations.
   const std::wstring app_progid = L"app_progid1";
   const std::vector<std::wstring> app_protocols = {L"web+test"};
@@ -1596,6 +1612,10 @@ TEST(ShellUtilTest, HashComputationTest) {
 }
 
 TEST(ShellUtilTest, UserChoiceHashComputationTest) {
+  // User Choice hashing is only available on Win10 or above.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    GTEST_SKIP();
+
   // If these tests fail, investigate if the salt changed or if the hash
   // function changed.
   EXPECT_EQ(
diff --git a/chrome/installer/util/taskbar_util.cc b/chrome/installer/util/taskbar_util.cc
index c1464a4901f76..da12e179db40f 100644
--- a/chrome/installer/util/taskbar_util.cc
+++ b/chrome/installer/util/taskbar_util.cc
@@ -110,9 +110,11 @@ bool UnpinShortcutWithIPinnedList3(const base::FilePath& shortcut) {
 }  // namespace
 
 bool CanPinShortcutToTaskbar() {
-  // "Pin to taskbar" isn't directly supported in Windows 10, but WIN10_RS5 has
+  // "Pin to taskbar" stopped being supported in Windows 10, but WIN10_RS5 has
   // some undocumented interfaces to do pinning.
-  return base::win::GetVersion() >= base::win::Version::WIN10_RS5;
+  const auto version = base::win::GetVersion();
+  return version < base::win::Version::WIN10 ||
+         version >= base::win::Version::WIN10_RS5;
 }
 
 bool PinShortcutToTaskbar(const base::FilePath& shortcut) {
diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
index eab276d6ebe23..6c9d906d290ff 100644
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -180,6 +180,7 @@
 #endif  // BUILDFLAG(ENABLE_SPEECH_SERVICE)
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "chrome/renderer/render_frame_font_family_accessor.h"
 #endif
 
@@ -327,6 +328,12 @@ std::unique_ptr<base::Unwinder> CreateV8Unwinder(v8::Isolate* isolate) {
 // made available in other clients of content/ that do not have a Web Share
 // Mojo implementation (e.g. WebView).
 void MaybeEnableWebShare() {
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    // Web Share API is not functional for non-UWP apps prior to Windows 10.
+    return;
+  }
+#endif
 #if BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)
   if (base::FeatureList::IsEnabled(features::kWebShare))
 #endif
diff --git a/chrome/test/delayload/delayloads_unittest.cc b/chrome/test/delayload/delayloads_unittest.cc
index 5c08637ee952a..7be8ee785d92c 100644
--- a/chrome/test/delayload/delayloads_unittest.cc
+++ b/chrome/test/delayload/delayloads_unittest.cc
@@ -22,6 +22,7 @@
 #include "base/test/launcher/unit_test_launcher.h"
 #include "base/test/test_suite.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "chrome/install_static/test/scoped_install_details.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -174,8 +175,13 @@ TEST_F(DelayloadsTest, DISABLED_ChromeDllLoadSanityTestImpl) {
   HMODULE chrome_module_handle = ::LoadLibrary(dll.value().c_str());
   ASSERT_TRUE(chrome_module_handle != nullptr);
 
-  // Loading chrome.dll should not load user32.dll on Windows.
-  EXPECT_EQ(nullptr, ::GetModuleHandle(L"user32.dll"));
+  // Loading chrome.dll should not load user32.dll on Win10.
+  // On Win7, chains of system dlls and lack of apisets result in it loading.
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    EXPECT_EQ(nullptr, ::GetModuleHandle(L"user32.dll"));
+  } else {
+    EXPECT_NE(nullptr, ::GetModuleHandle(L"user32.dll"));
+  }
 }
 
 TEST_F(DelayloadsTest, ChromeElfDllDelayloadsCheck) {
diff --git a/chrome/updater/run_all_unittests.cc b/chrome/updater/run_all_unittests.cc
index a43532dc209db..534fdb9aa7df0 100644
--- a/chrome/updater/run_all_unittests.cc
+++ b/chrome/updater/run_all_unittests.cc
@@ -26,9 +26,11 @@
 #include <memory>
 #include <string>
 
+#include "base/base_paths.h"
 #include "base/path_service.h"
 #include "base/win/registry.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "chrome/installer/util/scoped_token_privilege.h"
 #include "chrome/updater/util/win_util.h"
 
@@ -164,6 +166,12 @@ int main(int argc, char** argv) {
   MaybeIncreaseTestTimeouts(argc, argv);
 
 #if BUILDFLAG(IS_WIN)
+  // TODO(crbug.com/1406309) - this can be deleted once BuildBot removes the
+  // Windows 7 testers.
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    LOG(ERROR) << "Tests didn't run because of an unsupported Windows version.";
+    return 0;
+  }
   updater::test::MaybeExcludePathsFromWindowsDefender();
 
   VLOG(0) << "Process priority: " << base::Process::Current().GetPriority();
diff --git a/chrome/updater/util/unittest_util.cc b/chrome/updater/util/unittest_util.cc
index fff69673b9f68..3f561163817bc 100644
--- a/chrome/updater/util/unittest_util.cc
+++ b/chrome/updater/util/unittest_util.cc
@@ -4,7 +4,6 @@
 
 #include "chrome/updater/util/unittest_util.h"
 
-#include <memory>
 #include <string>
 #include <utility>
 
@@ -43,6 +42,7 @@
 
 #include "base/strings/string_number_conversions_win.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "chrome/test/base/process_inspector_win.h"
 #include "chrome/updater/util/win_util.h"
 #endif
@@ -246,6 +246,11 @@ void MaybeExcludePathsFromWindowsDefender() {
   if (!command_line->HasSwitch(kTestLauncherExcludePathsFromWindowDefender))
     return;
 
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    VLOG(1) << "Skip changing Windows Defender settings for Win7 and below.";
+    return;
+  }
+
   if (!IsServiceRunning(L"WinDefend")) {
     VLOG(1) << "WinDefend is not running, no need to add exclusion paths.";
     return;
@@ -280,6 +285,11 @@ void MaybeExcludePathsFromWindowsDefender() {
 }
 
 base::FilePath StartProcmonLogging() {
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    LOG(WARNING) << __func__ << ": skipping procmon logging on Win7.";
+    return {};
+  }
+
   if (!::IsUserAnAdmin()) {
     LOG(WARNING) << __func__
                  << ": user is not an admin, skipping procmon logging";
diff --git a/chrome/updater/win/installer/installer.cc b/chrome/updater/win/installer/installer.cc
index 0bc559fe7e331..40a0266e89525 100644
--- a/chrome/updater/win/installer/installer.cc
+++ b/chrome/updater/win/installer/installer.cc
@@ -319,7 +319,7 @@ ProcessExitResult InstallerMain(HMODULE module) {
   CHECK(EnableSecureDllLoading());
   EnableProcessHeapMetadataProtection();
 
-  if (base::win::GetVersion() < base::win::Version::WIN10) {
+  if (base::win::GetVersion() < base::win::Version::WIN7) {
     return ProcessExitResult(UNSUPPORTED_WINDOWS_VERSION);
   }
 
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index e7fe1c565aac5..40148eeaef7d1 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -4,8 +4,6 @@
 
 #include "components/embedder_support/user_agent_utils.h"
 
-#include <vector>
-
 #include "base/command_line.h"
 #include "base/debug/stack_trace.h"
 #include "base/feature_list.h"
@@ -83,6 +81,35 @@ int GetPreRS5UniversalApiContractVersion() {
   return 0;
 }
 
+// Return the legacy windows platform version to match the spec description
+// https://wicg.github.io/ua-client-hints/#get-the-legacy-windows-version-number,
+// which is available for Windows versions between range WIN7 and WIN8_1.
+// Otherwise, returns 0.
+const std::string& GetLegacyWindowsPlatformVersion() {
+  static const base::NoDestructor<std::string> legacy_windows_platform_version(
+      [] {
+        int major_version = 0;
+        int minor_version = 0;
+        switch (base::win::GetVersion()) {
+          case base::win::Version::WIN7:
+            minor_version = 1;
+            break;
+          case base::win::Version::WIN8:
+            minor_version = 2;
+            break;
+          case base::win::Version::WIN8_1:
+            minor_version = 3;
+            break;
+          default:
+            minor_version = 0;
+            break;
+        }
+        return base::StrCat({base::NumberToString(major_version), ".",
+                             base::NumberToString(minor_version), ".0"});
+      }());
+  return *legacy_windows_platform_version;
+}
+
 // Returns the UniversalApiContract version number, which is available for
 // Windows versions greater than RS5. Otherwise, returns 0.
 const std::string& GetUniversalApiContractVersion() {
@@ -95,24 +122,26 @@ const std::string& GetUniversalApiContractVersion() {
       [] {
         int major_version = 0;
         int minor_version = 0;
-        if (base::win::GetVersion() <= base::win::Version::WIN10_RS4) {
-          major_version = GetPreRS5UniversalApiContractVersion();
-        } else {
-          base::win::RegKey version_key(
-              HKEY_LOCAL_MACHINE, kWindowsRuntimeWellKnownContractsRegKeyName,
-              KEY_QUERY_VALUE | KEY_WOW64_64KEY);
-          if (version_key.Valid()) {
-            DWORD universal_api_contract_version = 0;
-            LONG result = version_key.ReadValueDW(
-                kUniversalApiContractName, &universal_api_contract_version);
-            if (result == ERROR_SUCCESS) {
-              major_version = HIWORD(universal_api_contract_version);
-              minor_version = LOWORD(universal_api_contract_version);
+        if (base::win::GetVersion() >= base::win::Version::WIN10) {
+          if (base::win::GetVersion() <= base::win::Version::WIN10_RS4) {
+            major_version = GetPreRS5UniversalApiContractVersion();
+          } else {
+            base::win::RegKey version_key(
+                HKEY_LOCAL_MACHINE, kWindowsRuntimeWellKnownContractsRegKeyName,
+                KEY_QUERY_VALUE | KEY_WOW64_64KEY);
+            if (version_key.Valid()) {
+              DWORD universal_api_contract_version = 0;
+              LONG result = version_key.ReadValueDW(
+                  kUniversalApiContractName, &universal_api_contract_version);
+              if (result == ERROR_SUCCESS) {
+                major_version = HIWORD(universal_api_contract_version);
+                minor_version = LOWORD(universal_api_contract_version);
+              } else {
+                major_version = kHighestKnownUniversalApiContractVersion;
+              }
             } else {
               major_version = kHighestKnownUniversalApiContractVersion;
             }
-          } else {
-            major_version = kHighestKnownUniversalApiContractVersion;
           }
         }
         // The major version of the contract is stored in the HIWORD, while the
@@ -124,6 +153,9 @@ const std::string& GetUniversalApiContractVersion() {
 }
 
 const std::string& GetWindowsPlatformVersion() {
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    return GetLegacyWindowsPlatformVersion();
+  }
   return GetUniversalApiContractVersion();
 }
 #endif  // BUILDFLAG(IS_WIN)
@@ -173,6 +205,17 @@ bool ShouldSendUserAgentUnifiedPlatform(
          base::FeatureList::IsEnabled(
              blink::features::kReduceUserAgentAndroidVersionDeviceModel);
 #else
+// For legacy windows, only reduce the user agent platform and oscpu when
+// kLegacyWindowsPlatform parameter set to true.
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    return ShouldReduceUserAgentMinorVersion(user_agent_reduction) &&
+           base::FeatureList::IsEnabled(
+               blink::features::kReduceUserAgentPlatformOsCpu) &&
+           blink::features::kLegacyWindowsPlatform.Get();
+  }
+#endif
+
   return ShouldReduceUserAgentMinorVersion(user_agent_reduction) &&
          base::FeatureList::IsEnabled(
              blink::features::kReduceUserAgentPlatformOsCpu) &&
diff --git a/components/embedder_support/user_agent_utils_unittest.cc b/components/embedder_support/user_agent_utils_unittest.cc
index 25debd50e76b6..6f047920dca19 100644
--- a/components/embedder_support/user_agent_utils_unittest.cc
+++ b/components/embedder_support/user_agent_utils_unittest.cc
@@ -4,8 +4,6 @@
 
 #include "components/embedder_support/user_agent_utils.h"
 
-#include <vector>
-
 #include "base/command_line.h"
 #include "base/strings/strcat.h"
 #include "base/strings/string_number_conversions.h"
@@ -44,6 +42,7 @@
 #include "base/win/hstring_reference.h"
 #include "base/win/scoped_hstring.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif  // BUILDFLAG(IS_WIN)
 
 namespace embedder_support {
@@ -319,6 +318,22 @@ void VerifyWinPlatformVersion(std::string version) {
                              << " to not be supported.";
 }
 
+void VerifyLegacyWinPlatformVersion(const std::string& version) {
+  switch (base::win::GetVersion()) {
+    case base::win::Version::WIN7:
+      EXPECT_EQ("0.1.0", version);
+      break;
+    case base::win::Version::WIN8:
+      EXPECT_EQ("0.2.0", version);
+      break;
+    case base::win::Version::WIN8_1:
+      EXPECT_EQ("0.3.0", version);
+      break;
+    default:
+      EXPECT_EQ("0.0.0", version);
+      break;
+  }
+}
 #endif  // BUILDFLAG(IS_WIN)
 
 bool ContainsBrandVersion(const blink::UserAgentBrandList& brand_list,
@@ -667,11 +682,19 @@ TEST_F(UserAgentUtilsTest, ReduceUserAgentPlatformOsCpu) {
       {});
   {
 #if BUILDFLAG(IS_WIN)
-    EXPECT_EQ(base::StringPrintf(kDesktop,
-                                 version_info::GetMajorVersionNumber().c_str()),
-              GetUserAgent());
-    EXPECT_EQ("Windows NT 10.0; Win64; x64",
-              GetUserAgentPlatformOsCpu(GetUserAgent()));
+    if (base::win::GetVersion() < base::win::Version::WIN10) {
+      EXPECT_NE(base::StringPrintf(
+                    kDesktop, version_info::GetMajorVersionNumber().c_str()),
+                GetUserAgent());
+      EXPECT_NE("Windows NT 10.0; Win64; x64",
+                GetUserAgentPlatformOsCpu(GetUserAgent()));
+    } else {
+      EXPECT_EQ(base::StringPrintf(
+                    kDesktop, version_info::GetMajorVersionNumber().c_str()),
+                GetUserAgent());
+      EXPECT_EQ("Windows NT 10.0; Win64; x64",
+                GetUserAgentPlatformOsCpu(GetUserAgent()));
+    }
 #else
     EXPECT_EQ(base::StringPrintf(kDesktop,
                                  version_info::GetMajorVersionNumber().c_str()),
@@ -869,7 +892,11 @@ TEST_F(UserAgentUtilsTest, UserAgentMetadata) {
                                     product_brand_full_version));
 
 #if BUILDFLAG(IS_WIN)
-  VerifyWinPlatformVersion(metadata.platform_version);
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    VerifyLegacyWinPlatformVersion(metadata.platform_version);
+  } else {
+    VerifyWinPlatformVersion(metadata.platform_version);
+  }
 #else
   int32_t major, minor, bugfix = 0;
   base::SysInfo::OperatingSystemVersionNumbers(&major, &minor, &bugfix);
diff --git a/components/infobars/core/confirm_infobar_delegate.cc b/components/infobars/core/confirm_infobar_delegate.cc
index 400de2cb8455e..9fb80c8912173 100644
--- a/components/infobars/core/confirm_infobar_delegate.cc
+++ b/components/infobars/core/confirm_infobar_delegate.cc
@@ -61,6 +61,10 @@ std::u16string ConfirmInfoBarDelegate::GetButtonTooltip(
   return std::u16string();
 }
 
+bool ConfirmInfoBarDelegate::OKButtonTriggersUACPrompt() const {
+  return false;
+}
+
 #if BUILDFLAG(IS_IOS)
 bool ConfirmInfoBarDelegate::UseIconBackgroundTint() const {
   return true;
diff --git a/components/infobars/core/confirm_infobar_delegate.h b/components/infobars/core/confirm_infobar_delegate.h
index b04ea73e00fe0..dc89f7e64b181 100644
--- a/components/infobars/core/confirm_infobar_delegate.h
+++ b/components/infobars/core/confirm_infobar_delegate.h
@@ -73,6 +73,10 @@ class ConfirmInfoBarDelegate : public infobars::InfoBarDelegate {
   // returns an empty tooltip.
   virtual std::u16string GetButtonTooltip(InfoBarButton button) const;
 
+  // Returns whether or not the OK button will trigger a UAC elevation prompt on
+  // Windows.
+  virtual bool OKButtonTriggersUACPrompt() const;
+
 #if BUILDFLAG(IS_IOS)
   // Returns whether or not a tint should be applied to the icon background.
   // Defaults to true.
diff --git a/components/memory_pressure/system_memory_pressure_evaluator.cc b/components/memory_pressure/system_memory_pressure_evaluator.cc
index 1dc594a6882f9..8487b219cfa80 100644
--- a/components/memory_pressure/system_memory_pressure_evaluator.cc
+++ b/components/memory_pressure/system_memory_pressure_evaluator.cc
@@ -4,9 +4,6 @@
 
 #include "components/memory_pressure/system_memory_pressure_evaluator.h"
 
-#include <memory>
-#include <utility>
-
 #include "base/feature_list.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -16,6 +13,7 @@
 #elif BUILDFLAG(IS_MAC)
 #include "components/memory_pressure/system_memory_pressure_evaluator_mac.h"
 #elif BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "components/memory_pressure/system_memory_pressure_evaluator_win.h"
 #endif
 
@@ -44,7 +42,8 @@ SystemMemoryPressureEvaluator::CreateDefaultSystemEvaluator(
           monitor->CreateVoter());
   // Also subscribe to the OS signals if they're available and the feature is
   // enabled.
-  if (base::FeatureList::IsEnabled(kUseWinOSMemoryPressureSignals)) {
+  if (base::FeatureList::IsEnabled(kUseWinOSMemoryPressureSignals) &&
+      base::win::GetVersion() >= base::win::Version::WIN8_1) {
     evaluator->CreateOSSignalPressureEvaluator(monitor->CreateVoter());
   }
   return evaluator;
diff --git a/components/services/quarantine/quarantine_win.cc b/components/services/quarantine/quarantine_win.cc
index 9e6f72b623c1f..a29932bbdd78a 100644
--- a/components/services/quarantine/quarantine_win.cc
+++ b/components/services/quarantine/quarantine_win.cc
@@ -26,6 +26,7 @@
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "components/services/quarantine/common.h"
 #include "components/services/quarantine/common_win.h"
 #include "url/gurl.h"
@@ -200,16 +201,18 @@ QuarantineFileResult SetInternetZoneIdentifierDirectly(
   static const char kHostUrlFormat[] = "HostUrl=%s\r\n";
 
   std::string identifier = "[ZoneTransfer]\r\nZoneId=3\r\n";
-  // Match what the InvokeAttachmentServices() function will output, including
-  // the order of the values.
-  if (IsValidUrlForAttachmentServices(referrer_url)) {
-    identifier.append(
-        base::StringPrintf(kReferrerUrlFormat, referrer_url.spec().c_str()));
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    // Match what the InvokeAttachmentServices() function will output, including
+    // the order of the values.
+    if (IsValidUrlForAttachmentServices(referrer_url)) {
+      identifier.append(
+          base::StringPrintf(kReferrerUrlFormat, referrer_url.spec().c_str()));
+    }
+    identifier.append(base::StringPrintf(
+        kHostUrlFormat, IsValidUrlForAttachmentServices(source_url)
+                            ? source_url.spec().c_str()
+                            : "about:internet"));
   }
-  identifier.append(base::StringPrintf(
-      kHostUrlFormat, IsValidUrlForAttachmentServices(source_url)
-                          ? source_url.spec().c_str()
-                          : "about:internet"));
 
   // Don't include trailing null in data written.
   DWORD written = 0;
diff --git a/components/services/quarantine/test_support_win.cc b/components/services/quarantine/test_support_win.cc
index 449ba455163df..6f356900fd59e 100644
--- a/components/services/quarantine/test_support_win.cc
+++ b/components/services/quarantine/test_support_win.cc
@@ -12,6 +12,7 @@
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "components/services/quarantine/common.h"
 #include "components/services/quarantine/common_win.h"
 #include "components/services/quarantine/test_support.h"
@@ -78,7 +79,11 @@ bool ZoneIdentifierPresentForFile(const base::FilePath& path,
 bool IsFileQuarantined(const base::FilePath& file,
                        const GURL& source_url,
                        const GURL& referrer_url) {
-  return ZoneIdentifierPresentForFile(file, source_url, referrer_url);
+  if (base::win::GetVersion() >= base::win::Version::WIN10)
+    return ZoneIdentifierPresentForFile(file, source_url, referrer_url);
+  else
+    return ZoneIdentifierPresentForFile(file, GURL::EmptyGURL(),
+                                        GURL::EmptyGURL());
 }
 
 }  // namespace quarantine
diff --git a/components/spellcheck/browser/spellcheck_platform_win.cc b/components/spellcheck/browser/spellcheck_platform_win.cc
index 757ceb168158e..108bad81bcb31 100644
--- a/components/spellcheck/browser/spellcheck_platform_win.cc
+++ b/components/spellcheck/browser/spellcheck_platform_win.cc
@@ -160,8 +160,10 @@ void RecordChromeLocalesStats(PlatformSpellChecker* spell_checker_instance,
   if (!spell_checker_instance) {
     return;
   }
-  static_cast<WindowsSpellChecker*>(spell_checker_instance)
+  if (spellcheck::WindowsVersionSupportsSpellchecker()) {
+    static_cast<WindowsSpellChecker*>(spell_checker_instance)
       ->RecordChromeLocalesStats(std::move(chrome_locales));
+  }
 }
 
 void RecordSpellcheckLocalesStats(
@@ -170,8 +172,11 @@ void RecordSpellcheckLocalesStats(
   if (!spell_checker_instance) {
     return;
   }
-  static_cast<WindowsSpellChecker*>(spell_checker_instance)
+  
+  if (spellcheck::WindowsVersionSupportsSpellchecker()) {
+    static_cast<WindowsSpellChecker*>(spell_checker_instance)
       ->RecordSpellcheckLocalesStats(std::move(spellcheck_locales));
+  }
 }
 
 }  // namespace spellcheck_platform
diff --git a/components/spellcheck/browser/windows_spell_checker.cc b/components/spellcheck/browser/windows_spell_checker.cc
index 18045968e7406..d29909221cc84 100644
--- a/components/spellcheck/browser/windows_spell_checker.cc
+++ b/components/spellcheck/browser/windows_spell_checker.cc
@@ -157,7 +157,8 @@ void BackgroundHelper::CreateSpellCheckerFactory() {
   DCHECK(background_task_runner_->RunsTasksInCurrentSequence());
   base::win::AssertComApartmentType(base::win::ComApartmentType::STA);
 
-  if (FAILED(::CoCreateInstance(__uuidof(::SpellCheckerFactory), nullptr,
+  if (!spellcheck::WindowsVersionSupportsSpellchecker() ||
+      FAILED(::CoCreateInstance(__uuidof(::SpellCheckerFactory), nullptr,
                                 (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER),
                                 IID_PPV_ARGS(&spell_checker_factory_)))) {
     spell_checker_factory_ = nullptr;
diff --git a/components/spellcheck/browser/windows_spell_checker_unittest.cc b/components/spellcheck/browser/windows_spell_checker_unittest.cc
index 9af4bfaea90c4..bf42b4fe29f01 100644
--- a/components/spellcheck/browser/windows_spell_checker_unittest.cc
+++ b/components/spellcheck/browser/windows_spell_checker_unittest.cc
@@ -131,7 +131,8 @@ class WindowsSpellCheckerTest : public testing::Test {
 
 void WindowsSpellCheckerTest::RunRequestTextCheckTest(
     const RequestTextCheckTestCase& test_case) {
-  ASSERT_TRUE(set_language_result_);
+  ASSERT_EQ(set_language_result_,
+            spellcheck::WindowsVersionSupportsSpellchecker());
 
   const std::u16string word(base::ASCIIToUTF16(test_case.text_to_check));
 
@@ -142,6 +143,13 @@ void WindowsSpellCheckerTest::RunRequestTextCheckTest(
                      base::Unretained(this)));
   RunUntilResultReceived();
 
+  if (!spellcheck::WindowsVersionSupportsSpellchecker()) {
+    // On Windows versions that don't support platform spellchecking, the
+    // returned vector of results should be empty.
+    ASSERT_TRUE(spell_check_results_.empty());
+    return;
+  }
+
   ASSERT_EQ(1u, spell_check_results_.size())
       << "RequestTextCheck: Wrong number of results";
 
@@ -216,6 +224,13 @@ TEST_F(WindowsSpellCheckerTest, RetrieveSpellcheckLanguages) {
 
   RunUntilResultReceived();
 
+  if (!spellcheck::WindowsVersionSupportsSpellchecker()) {
+    // On Windows versions that don't support platform spellchecking, the
+    // returned vector of results should be empty.
+    ASSERT_TRUE(spellcheck_languages_.empty());
+    return;
+  }
+
   ASSERT_LE(1u, spellcheck_languages_.size());
   ASSERT_TRUE(base::Contains(spellcheck_languages_, "en-US"));
 }
@@ -243,7 +258,8 @@ TEST_F(WindowsSpellCheckerTest, RetrieveSpellcheckLanguagesFakeDictionaries) {
 }
 
 TEST_F(WindowsSpellCheckerTest, GetPerLanguageSuggestions) {
-  ASSERT_TRUE(set_language_result_);
+  ASSERT_EQ(set_language_result_,
+            spellcheck::WindowsVersionSupportsSpellchecker());
 
   win_spell_checker_->GetPerLanguageSuggestions(
       u"tihs",
@@ -252,6 +268,13 @@ TEST_F(WindowsSpellCheckerTest, GetPerLanguageSuggestions) {
           base::Unretained(this)));
   RunUntilResultReceived();
 
+  if (!spellcheck::WindowsVersionSupportsSpellchecker()) {
+    // On Windows versions that don't support platform spellchecking, the
+    // returned vector of results should be empty.
+    ASSERT_TRUE(per_language_suggestions_.empty());
+    return;
+  }
+
   ASSERT_EQ(per_language_suggestions_.size(), 1u);
   ASSERT_GT(per_language_suggestions_[0].size(), 0u);
 }
diff --git a/components/spellcheck/common/spellcheck_features.cc b/components/spellcheck/common/spellcheck_features.cc
index 9942d3a72004b..0f17118a96785 100644
--- a/components/spellcheck/common/spellcheck_features.cc
+++ b/components/spellcheck/common/spellcheck_features.cc
@@ -8,6 +8,10 @@
 #include "build/build_config.h"
 #include "components/spellcheck/spellcheck_buildflags.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace spellcheck {
 
 #if BUILDFLAG(ENABLE_SPELLCHECK)
@@ -16,7 +20,8 @@ bool UseBrowserSpellChecker() {
 #if !BUILDFLAG(USE_BROWSER_SPELLCHECKER)
   return false;
 #elif BUILDFLAG(IS_WIN)
-  return base::FeatureList::IsEnabled(spellcheck::kWinUseBrowserSpellChecker);
+  return base::FeatureList::IsEnabled(spellcheck::kWinUseBrowserSpellChecker) &&
+         WindowsVersionSupportsSpellchecker();
 #else
   return true;
 #endif
@@ -35,6 +40,10 @@ BASE_FEATURE(kWinRetrieveSuggestionsOnlyOnDemand,
              "WinRetrieveSuggestionsOnlyOnDemand",
              base::FEATURE_ENABLED_BY_DEFAULT);
 
+bool WindowsVersionSupportsSpellchecker() {
+  return base::win::GetVersion() > base::win::Version::WIN7 &&
+         base::win::GetVersion() < base::win::Version::WIN_LAST;
+}
 #endif  // BUILDFLAG(IS_WIN)
 
 #if BUILDFLAG(IS_ANDROID)
diff --git a/components/spellcheck/common/spellcheck_features.h b/components/spellcheck/common/spellcheck_features.h
index f73ce6f7d4ce1..aeade54f1158b 100644
--- a/components/spellcheck/common/spellcheck_features.h
+++ b/components/spellcheck/common/spellcheck_features.h
@@ -43,6 +43,8 @@ BASE_DECLARE_FEATURE(kWinDelaySpellcheckServiceInit);
 // suggestions on demand when the context menu is brought up with a misspelled
 // word selected.
 BASE_DECLARE_FEATURE(kWinRetrieveSuggestionsOnlyOnDemand);
+
+bool WindowsVersionSupportsSpellchecker();
 #endif  // BUILDFLAG(IS_WIN)
 
 #if BUILDFLAG(IS_ANDROID)
diff --git a/components/spellcheck/renderer/spellcheck_provider_unittest.cc b/components/spellcheck/renderer/spellcheck_provider_unittest.cc
index b9ddb1c4e8e71..f8401be3e2028 100644
--- a/components/spellcheck/renderer/spellcheck_provider_unittest.cc
+++ b/components/spellcheck/renderer/spellcheck_provider_unittest.cc
@@ -205,6 +205,10 @@ TEST_P(HybridSpellCheckTest, ShouldUseBrowserSpellCheckOnlyWhenNeeded) {
 }
 
 void HybridSpellCheckTest::RunShouldUseBrowserSpellCheckOnlyWhenNeededTest() {
+  if (!spellcheck::WindowsVersionSupportsSpellchecker()) {
+    return;
+  }
+
   const auto& test_case = GetParam();
 
   FakeTextCheckingResult completion;
@@ -580,6 +584,10 @@ INSTANTIATE_TEST_SUITE_P(
                      4)})}));
 
 TEST_P(CombineSpellCheckResultsTest, ShouldCorrectlyCombineHybridResults) {
+  if (!spellcheck::WindowsVersionSupportsSpellchecker()) {
+    return;
+  }
+
   const auto& test_case = GetParam();
   base::test::ScopedFeatureList local_features;
   local_features.InitAndEnableFeature(spellcheck::kWinUseBrowserSpellChecker);
diff --git a/content/app/initialize_mojo_core.cc b/content/app/initialize_mojo_core.cc
index cf110bb3ca1b7..92a298016351a 100644
--- a/content/app/initialize_mojo_core.cc
+++ b/content/app/initialize_mojo_core.cc
@@ -20,6 +20,10 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "sandbox/policy/sandbox_type.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace content {
 
 void InitializeMojoCore() {
@@ -52,9 +56,12 @@ void InitializeMojoCore() {
       config.force_direct_shared_memory_allocation = true;
   } else {
 #if BUILDFLAG(IS_WIN)
-    // On Windows it's not necessary to broker shared memory allocation, as
-    // even sandboxed processes can allocate their own without trouble.
-    config.force_direct_shared_memory_allocation = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+      // On Windows 8.1 and later it's not necessary to broker shared memory
+      // allocation, as even sandboxed processes can allocate their own without
+      // trouble.
+      config.force_direct_shared_memory_allocation = true;
+    }
 #endif
   }
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 62a5aa48fdf02..e606b4afb7d8d 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2706,6 +2706,8 @@ source_set("browser") {
       "renderer_host/direct_manipulation_helper_win.h",
       "renderer_host/dwrite_font_file_util_win.cc",
       "renderer_host/dwrite_font_file_util_win.h",
+      "renderer_host/dwrite_font_lookup_table_builder_win.cc",
+      "renderer_host/dwrite_font_lookup_table_builder_win.h",
       "renderer_host/dwrite_font_proxy_impl_win.cc",
       "renderer_host/dwrite_font_proxy_impl_win.h",
       "renderer_host/dwrite_font_uma_logging_win.cc",
diff --git a/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc b/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc
index ad5c14492e17c..bb655673ec54a 100644
--- a/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc
+++ b/content/browser/accessibility/ax_platform_node_textrangeprovider_win_browsertest.cc
@@ -8,6 +8,7 @@
 #include "base/win/scoped_bstr.h"
 #include "base/win/scoped_safearray.h"
 #include "base/win/scoped_variant.h"
+#include "base/win/windows_version.h"
 #include "content/browser/accessibility/accessibility_content_browsertest.h"
 #include "content/browser/accessibility/browser_accessibility.h"
 #include "content/browser/accessibility/browser_accessibility_com_win.h"
@@ -3493,6 +3494,11 @@ IN_PROC_BROWSER_TEST_F(AXPlatformNodeTextRangeProviderWinBrowserTest,
 
 IN_PROC_BROWSER_TEST_F(AXPlatformNodeTextRangeProviderWinBrowserTest,
                        DegenerateRangeBoundingRect) {
+  // Due to https://crbug.com/1193359, custom fonts do not load consistently in
+  // Windows 7. So not running this test on Windows 7.
+  if (base::win::GetVersion() == base::win::Version::WIN7)
+    return;
+
   LoadInitialAccessibilityTreeFromHtmlFilePath(
       "/accessibility/html/fixed-width-text.html");
 
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index d49279949d7e6..fe149bb84a5d7 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -191,6 +191,7 @@
 #include <windows.h>
 
 #include "base/threading/platform_thread_win.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "net/base/winsock_init.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
@@ -992,6 +993,16 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
 
   variations::MaybeScheduleFakeCrash();
 
+#if BUILDFLAG(IS_WIN)
+  // ShellBrowserMainParts initializes a ShellBrowserContext with a profile
+  // directory only in PreMainMessageLoopRun(). DWriteFontLookupTableBuilder
+  // needs to access this directory, hence triggering after this stage has run.
+  if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
+    content::DWriteFontLookupTableBuilder::GetInstance()
+        ->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   // Unretained(this) is safe as the main message loop expected to run it is
   // stopped before ~BrowserMainLoop (in the event the message loop doesn't
   // reach idle before that point).
diff --git a/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc b/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc
index 3b3482b9a7a69..9e289625c6026 100644
--- a/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc
+++ b/content/browser/font_unique_name_lookup/font_unique_name_browsertest.cc
@@ -18,6 +18,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/files/scoped_temp_dir.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #endif
 
 namespace content {
diff --git a/content/browser/form_controls_browsertest.cc b/content/browser/form_controls_browsertest.cc
index a286513d2bdcd..6ee45e2d85004 100644
--- a/content/browser/form_controls_browsertest.cc
+++ b/content/browser/form_controls_browsertest.cc
@@ -24,6 +24,10 @@
 #include "base/android/build_info.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 // TODO(crbug.com/958242): Move the baselines to skia gold for easier
 //   rebaselining when all platforms are supported.
 
@@ -140,6 +144,16 @@ class FormControlsBrowserTest : public ContentBrowserTest {
 #endif  // BUILDFLAG(IS_ANDROID)
     return false;
   }
+
+  bool SkipTestForOldWinVersion() const {
+#if BUILDFLAG(IS_WIN)
+    // Win7 font rendering causes too large of rendering diff for pixel
+    // comparison.
+    if (base::win::GetVersion() <= base::win::Version::WIN7)
+      return true;
+#endif  // BUILDFLAG(IS_WIN)
+    return false;
+  }
 };
 
 // Checkbox renders differently on Android x86. crbug.com/1238283
@@ -254,6 +268,9 @@ IN_PROC_BROWSER_TEST_F(FormControlsBrowserTest, Button) {
   if (SkipTestForOldAndroidVersions())
     return;
 
+  if (SkipTestForOldWinVersion())
+    return;
+
   RunTest("form_controls_browsertest_button",
           R"HTML(
             <style>body {margin: 8px} input {margin-bottom: 18px;}</style>
diff --git a/content/browser/gpu/gpu_internals_ui.cc b/content/browser/gpu/gpu_internals_ui.cc
index 2513d9d28526f..f77a508bdd260 100644
--- a/content/browser/gpu/gpu_internals_ui.cc
+++ b/content/browser/gpu/gpu_internals_ui.cc
@@ -59,6 +59,7 @@
 #include "ui/gl/gpu_switching_manager.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
 #include "ui/gfx/win/physical_size.h"
 #endif
 
@@ -180,8 +181,10 @@ base::Value::List GetBasicGpuInfo(const gpu::GPUInfo& gpu_info,
   basic_info.Append(display::BuildGpuInfoEntry(
       "AMD switchable", base::Value(gpu_info.amd_switchable)));
 #if BUILDFLAG(IS_WIN)
+  std::string compositor =
+      ui::win::IsAeroGlassEnabled() ? "Aero Glass" : "none";
   basic_info.Append(
-      display::BuildGpuInfoEntry("Desktop compositing", "Aero Glass"));
+      display::BuildGpuInfoEntry("Desktop compositing", compositor));
 
   basic_info.Append(display::BuildGpuInfoEntry(
       "Direct composition",
diff --git a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
index 971044297de82..935b200114c09 100644
--- a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
+++ b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
@@ -4,14 +4,13 @@
 
 #include "content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.h"
 
-#include <string>
-
 #include "base/command_line.h"
 #include "build/build_config.h"
 #include "content/public/common/content_switches.h"
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "sandbox/policy/features.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/process_mitigations.h"
@@ -37,9 +36,11 @@ bool PpapiPluginSandboxedProcessLauncherDelegate::PreSpawnTarget(
   // create the server side of Chrome pipes.
   sandbox::ResultCode result;
 #if !defined(NACL_WIN64)
-  result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
-  if (result != sandbox::SBOX_ALL_OK) {
-    return false;
+  // We don't support PPAPI win32k lockdown prior to Windows 10.
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
+    if (result != sandbox::SBOX_ALL_OK)
+      return false;
   }
 #endif  // !defined(NACL_WIN64)
 
diff --git a/content/browser/renderer_host/direct_manipulation_helper_win.cc b/content/browser/renderer_host/direct_manipulation_helper_win.cc
index 8a50a633084e7..a0ae3fcb213e3 100644
--- a/content/browser/renderer_host/direct_manipulation_helper_win.cc
+++ b/content/browser/renderer_host/direct_manipulation_helper_win.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/window_event_target.h"
 #include "ui/compositor/compositor.h"
@@ -27,6 +28,10 @@ DirectManipulationHelper::CreateInstance(HWND window,
   if (!::IsWindow(window) || !compositor || !event_target)
     return nullptr;
 
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(window, compositor));
 
@@ -41,6 +46,10 @@ std::unique_ptr<DirectManipulationHelper>
 DirectManipulationHelper::CreateInstanceForTesting(
     ui::WindowEventTarget* event_target,
     Microsoft::WRL::ComPtr<IDirectManipulationViewport> viewport) {
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(0, nullptr));
 
diff --git a/content/browser/renderer_host/direct_manipulation_win_browsertest.cc b/content/browser/renderer_host/direct_manipulation_win_browsertest.cc
index f4bf76309c2cd..2ec0c54615abf 100644
--- a/content/browser/renderer_host/direct_manipulation_win_browsertest.cc
+++ b/content/browser/renderer_host/direct_manipulation_win_browsertest.cc
@@ -4,6 +4,7 @@
 
 #include "content/browser/renderer_host/direct_manipulation_helper_win.h"
 
+#include "base/win/windows_version.h"
 #include "content/browser/renderer_host/direct_manipulation_test_helper_win.h"
 #include "content/browser/renderer_host/legacy_render_widget_host_win.h"
 #include "content/browser/renderer_host/render_widget_host_view_aura.h"
@@ -86,6 +87,9 @@ class DirectManipulationBrowserTest : public DirectManipulationBrowserTestBase {
 // interaction begin and destroyed after direct manipulation interaction end.
 IN_PROC_BROWSER_TEST_F(DirectManipulationBrowserTest,
                        ObserverDuringInteraction) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   EXPECT_TRUE(NavigateToURL(shell(), GURL(url::kAboutBlankURL)));
 
   LegacyRenderWidgetHostHWND* lrwhh = GetLegacyRenderWidgetHostHWND();
@@ -137,6 +141,9 @@ class EventLogger : public ui::EventRewriter {
 
 // Check DirectManipulation events convert to ui::event correctly.
 IN_PROC_BROWSER_TEST_F(DirectManipulationBrowserTest, EventConvert) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   EXPECT_TRUE(NavigateToURL(shell(), GURL(url::kAboutBlankURL)));
 
   LegacyRenderWidgetHostHWND* lrwhh = GetLegacyRenderWidgetHostHWND();
@@ -293,6 +300,9 @@ class PrecisionTouchpadBrowserTest : public DirectManipulationBrowserTestBase {
 // Confirm that preventDefault correctly prevents pinch zoom on precision
 // touchpad.
 IN_PROC_BROWSER_TEST_F(PrecisionTouchpadBrowserTest, PreventDefaultPinchZoom) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   ASSERT_TRUE(NavigateToURL(shell(), GURL(R"HTML(data:text/html,<!DOCTYPE html>
         <html>
           Hello, world
@@ -369,6 +379,9 @@ IN_PROC_BROWSER_TEST_F(PrecisionTouchpadBrowserTest, PreventDefaultPinchZoom) {
 // Confirm that preventDefault correctly prevents scrolling on precision
 // touchpad.
 IN_PROC_BROWSER_TEST_F(PrecisionTouchpadBrowserTest, PreventDefaultScroll) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   ASSERT_TRUE(NavigateToURL(shell(), GURL(R"HTML(data:text/html,<!DOCTYPE html>
     <html>
       <body style='height:2000px; width:2000px;'>
diff --git a/content/browser/renderer_host/direct_manipulation_win_unittest.cc b/content/browser/renderer_host/direct_manipulation_win_unittest.cc
index 542a8d690bf35..f8335bf63da87 100644
--- a/content/browser/renderer_host/direct_manipulation_win_unittest.cc
+++ b/content/browser/renderer_host/direct_manipulation_win_unittest.cc
@@ -6,6 +6,7 @@
 
 #include <objbase.h>
 
+#include "base/win/windows_version.h"
 #include "content/browser/renderer_host/direct_manipulation_test_helper_win.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/base/ui_base_features.h"
@@ -356,6 +357,12 @@ class DirectManipulationUnitTest : public testing::Test {
   MockWindowEventTarget event_target_;
 };
 
+TEST_F(DirectManipulationUnitTest, HelperShouldCreateForWin10) {
+  // We should create DirectManipulationHelper instance when win version >= 10.
+  EXPECT_EQ(GetDirectManipulationHelper() != nullptr,
+            base::win::GetVersion() >= base::win::Version::WIN10);
+}
+
 TEST_F(DirectManipulationUnitTest, ReceiveSimplePanTransform) {
   if (!GetDirectManipulationHelper())
     return;
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
new file mode 100644
index 0000000000000..80fb5b3a1603d
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
@@ -0,0 +1,773 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+
+#include <set>
+#include <utility>
+
+#include "base/file_version_info.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/hash/hash.h"
+#include "base/i18n/case_conversion.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/trace_event/trace_event.h"
+#include "base/types/optional_util.h"
+#include "base/version.h"
+#include "base/win/registry.h"
+#include "content/browser/renderer_host/dwrite_font_file_util_win.h"
+#include "content/browser/renderer_host/dwrite_font_proxy_impl_win.h"
+#include "content/browser/renderer_host/dwrite_font_uma_logging_win.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/common/content_client.h"
+#include "content/public/common/content_features.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_persistence.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "ui/gfx/win/direct_write.h"
+
+namespace content {
+
+namespace {
+
+const base::FilePath::CharType kProtobufFilename[] =
+    FILE_PATH_LITERAL("font_unique_name_table.pb");
+
+// Timeout after which font scanning and metadata extraction is stopped and the
+// local lookup table is cleared. Font scanning and lookup table construction is
+// only needed pre Windows 10. If the timeout is hit, no local font matching
+// will be performed on this particular pre Win 10 system.
+constexpr base::TimeDelta kFontIndexingTimeoutDefault = base::Minutes(5);
+
+// In timeout test case, slow down indexing of one font file to this percentage
+// of the timeout value. Assuming that at least two fonts are indexed, the
+// timeout should be usually hit during indexing the second font.
+constexpr float kIndexingSlowDownForTestingPercentage = 0.75;
+
+// Additional local custom interface specific HRESULT codes (also added to
+// enums.xml) to mark font scanning implementation specific error situations, as
+// part of reporting them in a UMA metric.
+constexpr HRESULT kErrorFontScanningTimedOut =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD101);
+constexpr HRESULT kErrorExtractingLocalizedStringsFailed =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD102);
+constexpr HRESULT kErrorNoFullNameOrPostScriptName =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD103);
+
+bool ExtractCaseFoldedLocalizedStrings(
+    IDWriteLocalizedStrings* dwrite_localized_strings,
+    std::vector<std::string>* localized_strings) {
+  uint32_t strings_count = dwrite_localized_strings->GetCount();
+
+  if (!strings_count)
+    return false;
+
+  localized_strings->reserve(localized_strings->size() + strings_count);
+  for (UINT32 j = 0; j < strings_count; ++j) {
+    UINT32 length;
+    HRESULT hr = dwrite_localized_strings->GetStringLength(j, &length);
+    if (FAILED(hr))
+      continue;
+    std::wstring localized_name;
+    localized_name.resize(length + 1);
+    hr = dwrite_localized_strings->GetString(j, &localized_name[0], length + 1);
+    if (FAILED(hr)) {
+      continue;
+    }
+    localized_name.resize(length);
+    // The documentation for the API call does not specify an encoding but the
+    // results are wchar_t and FireFox considers them UTF-16, as seen here:
+    // https://dxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxDWriteFontList.cpp#90
+    // so we'll assume that.
+    localized_strings->push_back(base::UTF16ToUTF8(
+        base::i18n::FoldCase(base::WideToUTF16(localized_name))));
+  }
+  return true;
+}
+
+bool EnsureCacheDirectory(base::FilePath cache_directory) {
+  // If the directory does not exist already, ensure that the parent directory
+  // exists, which is usually the User Data directory. If it exists, we can try
+  // creating the cache directory.
+  return !cache_directory.empty() &&
+         (base::DirectoryExists(cache_directory) ||
+          (base::DirectoryExists(cache_directory.DirName()) &&
+           CreateDirectory(cache_directory)));
+}
+
+}  // namespace
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    blink::FontUniqueNameTable_UniqueFont&& font,
+    std::vector<std::string>&& names)
+    : font_entry(std::move(font)), extracted_names(std::move(names)) {}
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::
+    ~FontFileWithUniqueNames() = default;
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other) = default;
+
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult() = default;
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult(FamilyResult&& other) =
+    default;
+DWriteFontLookupTableBuilder::FamilyResult::~FamilyResult() = default;
+
+DWriteFontLookupTableBuilder::DWriteFontLookupTableBuilder()
+    : font_indexing_timeout_(kFontIndexingTimeoutDefault) {
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::InitializeCacheDirectoryFromProfile() {
+  // Unit tests that do not launch a full browser environment usually don't need
+  // testing of src:local()-style font matching. Check that an environment is
+  // present here and configcure the cache directory based on that. If none is
+  // configured, catch this in DuplicateMemoryRegion(), i.e. when a client
+  // tries to use this API.
+  cache_directory_ =
+      GetContentClient() && GetContentClient()->browser()
+          ? GetContentClient()->browser()->GetFontLookupTableCacheDir()
+          : base::FilePath();
+}
+
+DWriteFontLookupTableBuilder::~DWriteFontLookupTableBuilder() = default;
+
+base::ReadOnlySharedMemoryRegion
+DWriteFontLookupTableBuilder::DuplicateMemoryRegion() {
+  DCHECK(!TableCacheFilePath().empty())
+      << "Ensure that a cache_directory_ is set (see "
+         "InitializeCacheDirectoryFromProfile())";
+  DCHECK(FontUniqueNameTableReady());
+  return font_table_memory_.region.Duplicate();
+}
+
+bool DWriteFontLookupTableBuilder::IsFontUniqueNameTableValid() {
+  return font_table_memory_.IsValid() && font_table_memory_.mapping.size();
+}
+
+void DWriteFontLookupTableBuilder::InitializeDirectWrite() {
+  if (direct_write_initialized_)
+    return;
+  direct_write_initialized_ = true;
+
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  if (factory == nullptr) {
+    // We won't be able to load fonts, but we should still return messages so
+    // renderers don't hang if they for some reason send us a font message.
+    return;
+  }
+
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
+  factory.As<IDWriteFactory3>(&factory3_);
+
+  HRESULT hr = factory->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+
+  if (!collection_) {
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.GetSystemFontCollectionResult", hr);
+    LogMessageFilterError(MessageFilterError::ERROR_NO_COLLECTION);
+    return;
+  }
+}
+
+std::string DWriteFontLookupTableBuilder::ComputePersistenceHash(
+    const std::string& browser_version) {
+  // Build a hash from DWrite product version, browser major version and font
+  // names and file paths as stored in the registry. The browser major version
+  // is included to ensure that the cache is rebuild at least once for every
+  // Chrome milestone release. DWrite DLL version is included to ensure that any
+  // change in DWrite behavior after an update does not interfere with the
+  // information we have in the cache. The font registry keys and values are
+  // used to detect changes in installed fonts.
+
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  DCHECK(dwrite_version_info);
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  std::string to_hash = dwrite_version;
+
+  const wchar_t kFonts[] =
+      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
+  base::win::RegistryValueIterator it(HKEY_LOCAL_MACHINE, kFonts);
+  for (; it.Valid(); ++it) {
+    to_hash.append(base::WideToUTF8(it.Name()));
+    to_hash.append(base::WideToUTF8(it.Value()));
+  }
+
+  base::Version full_version = base::Version(browser_version);
+
+  // Version can be an empty string on trybots.
+  if (full_version.IsValid()) {
+    to_hash.append(base::NumberToString(full_version.components()[0]));
+  }
+
+  uint32_t fonts_changed_hash = base::PersistentHash(to_hash);
+  return std::to_string(fonts_changed_hash);
+}
+
+void DWriteFontLookupTableBuilder::SetCacheDirectoryForTesting(
+    base::FilePath cache_directory) {
+  cache_directory_ = cache_directory;
+}
+
+void DWriteFontLookupTableBuilder::SetCachingEnabledForTesting(
+    bool caching_enabled) {
+  caching_enabled_ = caching_enabled;
+}
+
+bool DWriteFontLookupTableBuilder::HasDWriteUniqueFontLookups() {
+  InitializeDirectWrite();
+  return factory3_;
+}
+
+void DWriteFontLookupTableBuilder::OverrideDWriteVersionChecksForTesting() {
+  InitializeDirectWrite();
+  factory3_.Reset();
+}
+
+base::TimeDelta DWriteFontLookupTableBuilder::IndexingTimeout() {
+  return font_indexing_timeout_;
+}
+
+void DWriteFontLookupTableBuilder::PostCallbacks() {
+  callbacks_task_runner_->StartWithTaskRunner(
+      base::ThreadPool::CreateSequencedTaskRunner({
+#if DCHECK_IS_ON()
+            // Needed for DCHECK in DuplicateMemoryRegion() which performs file
+            // operations to detect cache directory.
+            base::MayBlock(),
+#endif
+            base::TaskPriority::USER_VISIBLE,
+            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN
+      }));
+}
+
+base::FilePath DWriteFontLookupTableBuilder::TableCacheFilePath() {
+  if (!EnsureCacheDirectory(cache_directory_))
+    return base::FilePath();
+  return cache_directory_.Append(kProtobufFilename);
+}
+
+bool DWriteFontLookupTableBuilder::PersistToFile() {
+  DCHECK(caching_enabled_);
+
+  if (!IsFontUniqueNameTableValid())
+    return false;
+
+  return blink::font_table_persistence::PersistToFile(font_table_memory_,
+                                                      TableCacheFilePath());
+}
+
+bool DWriteFontLookupTableBuilder::LoadFromFile() {
+  DCHECK(caching_enabled_);
+  DCHECK(!IsFontUniqueNameTableValid());
+
+  return blink::font_table_persistence::LoadFromFile(TableCacheFilePath(),
+                                                     &font_table_memory_);
+}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    scoped_refptr<base::SequencedTaskRunner> runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback)
+    : task_runner(std::move(runner)), mojo_callback(std::move(callback)) {}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    CallbackOnTaskRunner&& other) = default;
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::~CallbackOnTaskRunner() =
+    default;
+
+void DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+
+  // base::Unretained(this) acceptable as bound argument here since
+  // DWriteFontLookupTableBuilder is a singleton instance.
+  callbacks_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &DWriteFontLookupTableBuilder::RunPendingCallback,
+          base::Unretained(this),
+          CallbackOnTaskRunner(std::move(task_runner), std::move(callback))));
+}
+
+bool DWriteFontLookupTableBuilder::FontUniqueNameTableReady() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FontUniqueNameTableReady");
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DCHECK(!HasDWriteUniqueFontLookups());
+  return font_table_built_.IsSet() && IsFontUniqueNameTableValid();
+}
+
+void DWriteFontLookupTableBuilder::
+    SchedulePrepareFontUniqueNameTableIfNeeded() {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+    InitializeDirectWrite();
+  }
+
+  // Nothing to do if we have API to directly lookup local fonts by unique name
+  // (as on Windows 10, IDWriteFactory3 available).
+  if (HasDWriteUniqueFontLookups())
+    return;
+
+  // Do not schedule indexing if we do not have a profile or temporary directory
+  // to store the cached table. This prevents repetitive and redundant scanning
+  // when the ContentBrowserClient did not provide a cache directory, as is the
+  // case in content_unittests.
+  if (TableCacheFilePath().empty())
+    return;
+
+  start_time_table_ready_ = base::TimeTicks::Now();
+  scanning_error_reasons_.clear();
+
+  scoped_refptr<base::SequencedTaskRunner> results_collection_task_runner =
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+
+  std::string browser_version =
+      GetContentClient()->browser()->GetUserAgentMetadata().full_version;
+  results_collection_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable,
+                     base::Unretained(this), browser_version));
+}
+
+void DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable(
+    const std::string& browser_version) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  // The table must only be built once.
+  DCHECK(!font_table_built_.IsSet());
+
+  if (caching_enabled_ && LoadFromFile()) {
+    blink::FontUniqueNameTable font_table;
+    const bool update_needed =
+        !IsFontUniqueNameTableValid() ||
+        !font_table.ParseFromArray(font_table_memory_.mapping.memory(),
+                                   font_table_memory_.mapping.size()) ||
+        font_table.stored_for_platform_version_identifier() !=
+            ComputePersistenceHash(browser_version);
+
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTableDiskCacheHit",
+                          !update_needed);
+    if (!update_needed) {
+      base::TimeDelta duration =
+          base::TimeTicks::Now() - start_time_table_ready_;
+      UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                                 duration);
+      font_table_built_.Set();
+      PostCallbacks();
+      return;
+    }
+  }
+
+  start_time_table_build_ = base::TimeTicks::Now();
+  font_unique_name_table_ = std::make_unique<blink::FontUniqueNameTable>();
+
+  // The |stored_for_platform_version_identifier| proto field is used for
+  // persisting the table to disk and identifying whether an update to the
+  // table is needed when loading it back.
+  font_unique_name_table_->set_stored_for_platform_version_identifier(
+      ComputePersistenceHash(browser_version));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+
+    outstanding_family_results_ = collection_->GetFontFamilyCount();
+    family_results_empty_ = 0;
+    family_results_non_empty_ = 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS(
+        "DirectWrite.Fonts.Proxy.FamilyCountIndexingStart",
+        outstanding_family_results_, 1, 5000, 50);
+  }
+  for (UINT32 family_index = 0; family_index < outstanding_family_results_;
+       ++family_index) {
+    // Specify base::ThreadPolicy::MUST_USE_FOREGROUND because in
+    // https://crbug.com/960263 we observed a priority inversion when running
+    // DWrite worker tasks in the background.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+         base::ThreadPolicy::MUST_USE_FOREGROUND,
+         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+        base::BindOnce(
+            &ExtractPathAndNamesFromFamily, collection_, family_index,
+            start_time_table_build_, slow_down_mode_for_testing_,
+            OptionalToPtr(hang_event_for_testing_), IndexingTimeout()),
+        base::BindOnce(&DWriteFontLookupTableBuilder::
+                           AppendFamilyResultAndFinalizeIfNeeded,
+                       base::Unretained(this)));
+  }
+  // Post a task to catch timeouts should one of the
+  // tasks will eventually not reply.
+  timeout_callback_.Reset(base::BindOnce(
+      &DWriteFontLookupTableBuilder::OnTimeout, base::Unretained(this)));
+  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE, timeout_callback_.callback(), IndexingTimeout());
+}
+
+// static
+DWriteFontLookupTableBuilder::FamilyResult
+DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily(
+    Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+    uint32_t family_index,
+    base::TimeTicks start_time,
+    SlowDownMode slow_down_mode_for_testing,
+    base::WaitableEvent* hang_event_for_testing,
+    base::TimeDelta indexing_timeout) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily");
+
+  static base::NoDestructor<std::u16string> windows_fonts_path(
+      GetWindowsFontsPath());
+
+  DWriteFontLookupTableBuilder::FamilyResult family_result;
+
+  if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+    family_result.exit_hresult = kErrorFontScanningTimedOut;
+    return family_result;
+  }
+
+  Microsoft::WRL::ComPtr<IDWriteFontFamily> family;
+  HRESULT hr = collection->GetFontFamily(family_index, &family);
+  if (FAILED(hr)) {
+    family_result.exit_hresult = hr;
+    return family_result;
+  }
+  UINT32 font_count = family->GetFontCount();
+
+  HRESULT last_hresult_continue_reason = S_OK;
+  for (UINT32 font_index = 0; font_index < font_count; ++font_index) {
+    if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+      family_result.exit_hresult = kErrorFontScanningTimedOut;
+      return family_result;
+    }
+
+    Microsoft::WRL::ComPtr<IDWriteFont> font;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = family->GetFont(font_index, &font);
+    }
+    if (FAILED(hr)) {
+      family_result.exit_hresult = hr;
+      return family_result;
+    }
+
+    if (font->GetSimulations() != DWRITE_FONT_SIMULATIONS_NONE)
+      continue;
+
+    std::set<std::wstring> path_set;
+    std::set<std::wstring> custom_font_path_set;
+    uint32_t ttc_index = 0;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = AddFilesForFont(font.Get(), *windows_fonts_path, &path_set,
+                           &custom_font_path_set, &ttc_index);
+      if (FAILED(hr)) {
+        // It's possible to not be able to retrieve a font file for a font that
+        // is in the system font collection, see https://crbug.com/922183. If we
+        // were not able to retrieve a file for a registered font, we do not
+        // need to add it to the map.
+        last_hresult_continue_reason = hr;
+        continue;
+      }
+    }
+
+    // After having received clarification from Microsoft, the API is designed
+    // for allowing multiple files to be returned, if MS was to support a file
+    // format like Type1 fonts with this API, but for now only ever returns 1
+    // font file as only TrueType / OpenType fonts are supported.
+    DCHECK_EQ(path_set.size() + custom_font_path_set.size(), 1u);
+    // If this font is placed in a custom font path location, we pass it to
+    // Blink, and we'll track with UMA there if such a font path is matched
+    // and used. If this happens more than very rarely, we will need to add an
+    // out-of-process loading mechanism for loading those uniquely matched
+    // font files.
+    base::FilePath file_path(path_set.size() ? *path_set.begin()
+                                             : *custom_font_path_set.begin());
+    DCHECK(!file_path.empty());
+
+    // Build entry for being added to the table in separate call.
+    blink::FontUniqueNameTable_UniqueFont unique_font;
+    unique_font.set_file_path(file_path.AsUTF8Unsafe());
+    unique_font.set_ttc_index(ttc_index);
+
+    std::vector<std::string> extracted_names;
+    auto extract_names =
+        [&extracted_names,
+         &font](DWRITE_INFORMATIONAL_STRING_ID font_info_string_id) -> HRESULT {
+      // Now get names, and make them point to the added font.
+      Microsoft::WRL::ComPtr<IDWriteLocalizedStrings> font_id_keyed_names;
+      BOOL has_id_keyed_names;
+      {
+        base::ScopedBlockingCall scoped_blocking_call(
+            FROM_HERE, base::BlockingType::MAY_BLOCK);
+        HRESULT hr = font->GetInformationalStrings(
+            font_info_string_id, &font_id_keyed_names, &has_id_keyed_names);
+        if (FAILED(hr))
+          return hr;
+        if (!has_id_keyed_names)
+          return kErrorNoFullNameOrPostScriptName;
+      }
+
+      return ExtractCaseFoldedLocalizedStrings(font_id_keyed_names.Get(),
+                                               &extracted_names)
+                 ? S_OK
+                 : kErrorExtractingLocalizedStringsFailed;
+    };
+
+    hr = extract_names(DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME);
+    hr = FAILED(hr) ? hr : extract_names(DWRITE_INFORMATIONAL_STRING_FULL_NAME);
+
+    if (UNLIKELY(slow_down_mode_for_testing == SlowDownMode::kDelayEachTask)) {
+      base::PlatformThread::Sleep(indexing_timeout *
+                                  kIndexingSlowDownForTestingPercentage);
+    } else if (UNLIKELY(slow_down_mode_for_testing ==
+                        SlowDownMode::kHangOneTask) &&
+               family_index == 0) {
+      base::ScopedAllowBaseSyncPrimitivesForTesting scoped_allow_sync_;
+      DCHECK(hang_event_for_testing);
+      hang_event_for_testing->Wait();
+    }
+
+    if (extracted_names.empty()) {
+      last_hresult_continue_reason = hr;
+      continue;
+    }
+
+    family_result.exit_hresult = S_OK;
+    family_result.font_files_with_names.push_back(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames(
+            std::move(unique_font), std::move(extracted_names)));
+  }
+
+  if (family_result.font_files_with_names.empty()) {
+    family_result.exit_hresult = last_hresult_continue_reason;
+  }
+
+  return family_result;
+}
+
+void DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded(
+    const FamilyResult& family_result) {
+  TRACE_EVENT0(
+      "dwrite,fonts",
+      "DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded");
+
+  outstanding_family_results_--;
+
+  // If this task's response came late and OnTimeout was called, we
+  // do not need the results anymore and the table was already finalized.
+  if (font_table_built_.IsSet())
+    return;
+
+  if (!family_result.font_files_with_names.size())
+    family_results_empty_++;
+  else
+    family_results_non_empty_++;
+
+  if (FAILED(family_result.exit_hresult))
+    scanning_error_reasons_[family_result.exit_hresult]++;
+
+  for (const FontFileWithUniqueNames& font_of_family :
+       family_result.font_files_with_names) {
+    blink::FontUniqueNameTable_UniqueFont* added_unique_font =
+        font_unique_name_table_->add_fonts();
+
+    *added_unique_font = font_of_family.font_entry;
+
+    int added_font_index = font_unique_name_table_->fonts_size() - 1;
+
+    for (auto& font_name : font_of_family.extracted_names) {
+      blink::FontUniqueNameTable_UniqueNameToFontMapping* added_mapping =
+          font_unique_name_table_->add_name_map();
+      DCHECK(added_mapping);
+      added_mapping->set_font_name(font_name);
+      added_mapping->set_font_index(added_font_index);
+    }
+  }
+
+  if (!outstanding_family_results_) {
+    FinalizeFontTable();
+  }
+}
+
+void DWriteFontLookupTableBuilder::RunPendingCallback(
+    CallbackOnTaskRunner pending_callback) {
+  DCHECK(callbacks_task_runner_->RunsTasksInCurrentSequence());
+  pending_callback.task_runner->PostTask(
+      FROM_HERE, base::BindOnce(std::move(pending_callback.mojo_callback),
+                                DuplicateMemoryRegion()));
+}
+
+void DWriteFontLookupTableBuilder::FinalizeFontTable() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FinalizeFontTable");
+  DCHECK(!font_table_built_.IsSet());
+
+  timeout_callback_.Cancel();
+
+  // Make sure that whatever happens in the remainder of this function the
+  // FontUniqueNameTable object gets released by moving it to a local variable.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table(
+      std::move(font_unique_name_table_));
+
+  bool timed_out = false;
+  if (base::TimeTicks::Now() - start_time_table_build_ > IndexingTimeout()) {
+    font_unique_name_table->clear_fonts();
+    font_unique_name_table->clear_name_map();
+    timed_out = true;
+  }
+  UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.TableBuildTimedOut",
+                        timed_out);
+
+  int empty_family_results_percentage =
+      round(((family_results_empty_ * 1.0f) /
+             (family_results_empty_ + family_results_non_empty_)) *
+            100.0);
+  UMA_HISTOGRAM_PERCENTAGE("DirectWrite.Fonts.Proxy.EmptyFamilyResultsRatio",
+                           empty_family_results_percentage);
+
+  if (empty_family_results_percentage > 0) {
+    auto most_frequent_hresult_element = std::max_element(
+        std::begin(scanning_error_reasons_), std::end(scanning_error_reasons_),
+        [](const decltype(scanning_error_reasons_)::value_type& a,
+           decltype(scanning_error_reasons_)::value_type& b) {
+          return a.second < b.second;
+        });
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.MostFrequentScanningFailure",
+        most_frequent_hresult_element->first);
+  }
+
+  unsigned num_font_files = font_unique_name_table->fonts_size();
+
+  blink::FontTableMatcher::SortUniqueNameTableForSearch(
+      font_unique_name_table.get());
+
+  font_table_memory_ = base::ReadOnlySharedMemoryRegion::Create(
+      font_unique_name_table->ByteSizeLong());
+
+  if (!IsFontUniqueNameTableValid() ||
+      !font_unique_name_table->SerializeToArray(
+          font_table_memory_.mapping.memory(),
+          font_table_memory_.mapping.size())) {
+    font_table_memory_ = base::MappedReadOnlyRegion();
+  }
+
+  if (caching_enabled_) {
+    bool persist_succeeded = PersistToFile();
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTablePersistSuccess",
+                          persist_succeeded);
+  }
+
+  font_table_built_.Set();
+  PostCallbacks();
+
+  if (!IsFontUniqueNameTableValid())
+    return;
+
+  base::TimeDelta duration = base::TimeTicks::Now() - start_time_table_build_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableBuildTime",
+                             duration);
+
+  duration = base::TimeTicks::Now() - start_time_table_ready_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                             duration);
+
+  // The size is usually tens of kilobytes, ~50kb on a standard Windows 10
+  // installation, 1MB should be a more than high enough upper limit.
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.LookupTableSize",
+                              font_table_memory_.mapping.size() / 1024, 1, 1000,
+                              50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.NumFontFiles",
+                              num_font_files, 1, 5000, 50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.IndexingSpeed",
+                              num_font_files / duration.InSecondsF(), 1, 10000,
+                              50);
+}
+
+void DWriteFontLookupTableBuilder::OnTimeout() {
+  DCHECK(!font_table_built_.IsSet());
+  FinalizeFontTable();
+}
+
+void DWriteFontLookupTableBuilder::SetSlowDownIndexingForTestingWithTimeout(
+    SlowDownMode slow_down_mode,
+    base::TimeDelta new_timeout) {
+  slow_down_mode_for_testing_ = slow_down_mode;
+  font_indexing_timeout_ = new_timeout;
+  if (slow_down_mode == SlowDownMode::kHangOneTask)
+    hang_event_for_testing_.emplace();
+}
+
+void DWriteFontLookupTableBuilder::ResetLookupTableForTesting() {
+  slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  font_indexing_timeout_ = kFontIndexingTimeoutDefault;
+  callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+  font_table_memory_ = base::MappedReadOnlyRegion();
+  caching_enabled_ = true;
+  font_table_built_.UnsafeResetForTesting();
+}
+
+void DWriteFontLookupTableBuilder::ResetStateForTesting() {
+  ResetLookupTableForTesting();
+  // Recreate fFactory3 if available, to reset
+  // OverrideDWriteVersionChecksForTesting().
+  direct_write_initialized_ = false;
+  InitializeDirectWrite();
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::ResumeFromHangForTesting() {
+  hang_event_for_testing_->Signal();
+}
+
+// static
+DWriteFontLookupTableBuilder* DWriteFontLookupTableBuilder::GetInstance() {
+  static base::NoDestructor<DWriteFontLookupTableBuilder> instance;
+  return instance.get();
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
new file mode 100644
index 0000000000000..f656225802ed5
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
@@ -0,0 +1,255 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+#define CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <dwrite_3.h>
+#include <wrl.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/cancelable_callback.h"
+#include "base/files/file_path.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/synchronization/atomic_flag.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/task/deferred_sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "content/common/content_export.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom.h"
+
+namespace content {
+
+// Singleton class which encapsulates building the font unique name table lookup
+// once, then serving the built table as a ReadOnlySharedMemoryRegion. Receives
+// requests for accessing this table from DWriteFontProxyImpl after Mojo IPC
+// calls from the renderer. A method ScheduleBuildFontUniqueNameTable() is
+// provided to schedule building the font unique name lookup
+// structure. EnsureFontUniqueNameTable() can be called on any thread to wait
+// for the lookup table to be ready. After that, DuplicateMemoryRegion() can be
+// used to retrieve the lookup structure. Thread-safe when used as described
+// below.
+class CONTENT_EXPORT DWriteFontLookupTableBuilder {
+ public:
+  static DWriteFontLookupTableBuilder* GetInstance();
+
+  DWriteFontLookupTableBuilder(const DWriteFontLookupTableBuilder&) = delete;
+  DWriteFontLookupTableBuilder& operator=(const DWriteFontLookupTableBuilder&) =
+      delete;
+
+  // Retrieve the prepared memory region if it is available.
+  // EnsureFontUniqueNameTable() must be checked before.
+  base::ReadOnlySharedMemoryRegion DuplicateMemoryRegion();
+
+  // Enqueue a request to get notified about the availability of the shared
+  // memory region holding the unique font lookup table.
+  // https://crbug.com/967316 shows that we do have a higher number of
+  // DWriteFontProxyImpl instances, potentially running on different
+  // TaskRunners. Capture each relevant task runner with a call to this method.
+  void QueueShareMemoryRegionWhenReady(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
+      blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback);
+
+  // Returns whether the indexing has completed and the shared memory region is
+  // immediately ready without any sync operations.
+  bool FontUniqueNameTableReady();
+
+  // If needed, i.e. if we're on pre-Windows 10, posts a task to load from cache
+  // or build (if cache not available) the unique name table index, should only
+  // be called once at browser startup, after that,
+  // QueueShareMemoryRegionWhenReady() to trigger the mojo callbacks when the
+  // table is ready.
+  void SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  enum class SlowDownMode { kDelayEachTask, kHangOneTask, kNoSlowdown };
+
+  // Slow down each family indexing step for testing the internal timeout,
+  // either with a single hung task or by delaying each indexing step. At the
+  // same time, configure a new timeout value for testing, overriding the
+  // default timeout.
+  void SetSlowDownIndexingForTestingWithTimeout(SlowDownMode slowdown_mode,
+                                                base::TimeDelta new_timeout);
+
+  // Reset timeout overrides and empty table. Needed to trigger rebuilding the
+  // lookup table, when testing using slowed-down indexing. Otherwise, the test
+  // methods would use the already cached lookup table.
+  void ResetLookupTableForTesting();
+
+  // Resets other overrides such as the DWrite version check override and cache
+  // directory back to its default values.
+  void ResetStateForTesting();
+
+  // Signals hang_event_for_testing_ which is used in testing hanging one of the
+  // font name retrieval tasks.
+  void ResumeFromHangForTesting();
+
+  // Computes a hash to determine whether cache contents needed to be updated,
+  // consisting of font names and their file paths read from the registry (not
+  // from disk), The DWrite.dll's product version and the Chrome version, as a
+  // safety mechanism to refresh the cache for every release. Exposed as a
+  // public method to be able to run the hash function in a test.
+  // `browser_version` is used in the hash.
+  std::string ComputePersistenceHash(const std::string& browser_version);
+
+  // Configures the cache directory in which to store the serialized font table
+  // lookup structure. Use only in testing. Normally the directory name is
+  // retrieved from ContentBrowserClient.
+  void SetCacheDirectoryForTesting(base::FilePath cache_directory);
+
+  // Configures whether the cache should be used. Needed for testing to test
+  // repeated rebuilding of the font table lookup structure.
+  void SetCachingEnabledForTesting(bool caching_enabled);
+
+  // Disable DCHECKs that ensure DWriteFontLookupTableBuilder is only
+  // run pre Windows 10, used for testing only to allow running the tests on
+  // Windows 10.
+  void OverrideDWriteVersionChecksForTesting();
+
+ private:
+  friend class base::NoDestructor<DWriteFontLookupTableBuilder>;
+
+  struct FontFileWithUniqueNames {
+    FontFileWithUniqueNames(blink::FontUniqueNameTable_UniqueFont&& font,
+                            std::vector<std::string>&& names);
+    ~FontFileWithUniqueNames();
+    FontFileWithUniqueNames(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other);
+    FontFileWithUniqueNames(const FontFileWithUniqueNames&) = delete;
+    FontFileWithUniqueNames& operator=(const FontFileWithUniqueNames&) = delete;
+
+    blink::FontUniqueNameTable_UniqueFont font_entry;
+    std::vector<std::string> extracted_names;
+  };
+
+  struct FamilyResult {
+    FamilyResult();
+
+    FamilyResult(const FamilyResult&) = delete;
+    FamilyResult& operator=(const FamilyResult&) = delete;
+
+    FamilyResult(FamilyResult&& other);
+
+    ~FamilyResult();
+
+    std::vector<FontFileWithUniqueNames> font_files_with_names;
+    HRESULT exit_hresult{S_OK};
+  };
+
+  // Try to find a serialized lookup table from the cache directory specified at
+  // construction and load it into memory.
+  bool LoadFromFile();
+
+  // Serialize the current lookup table into a file in the cache directory
+  // specified at construction time.
+  bool PersistToFile();
+
+  // Initialize the cache directory from the user profile directory if
+  // DWriteFontLookupTableBuilder is executed in an environment where the
+  // profile is accessible.
+  void InitializeCacheDirectoryFromProfile();
+
+  // Load from cache or construct the font unique name lookup table. If the
+  // cache is up to date, do not schedule a run to scan all Windows-enumerated
+  // fonts. `browser_version` is used in the hashing algorithm for the cache
+  // key.
+  void PrepareFontUniqueNameTable(const std::string& browser_version);
+
+  // Helper function to perform DWrite operations to retrieve path names, full
+  // font name and PostScript name for a font specified by collection + family
+  // index.
+  static FamilyResult ExtractPathAndNamesFromFamily(
+      Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+      uint32_t family_index,
+      base::TimeTicks start_time,
+      SlowDownMode slow_down_mode,
+      base::WaitableEvent* hang_event_for_testing,
+      base::TimeDelta indexing_timeout);
+
+  // Callback from scheduled tasks to add the retrieved font names to the
+  // protobuf.
+  void AppendFamilyResultAndFinalizeIfNeeded(const FamilyResult& family_result);
+
+  // Sort the results that were collected into the protobuf structure and
+  // signal that font unique name lookup table construction is complete.
+  // Serializes the constructed protobuf to disk.
+  void FinalizeFontTable();
+
+  void OnTimeout();
+
+  bool IsFontUniqueNameTableValid();
+
+  void InitializeDirectWrite();
+
+  base::FilePath TableCacheFilePath();
+
+  // Returns true if IDWriteFactory3 is available, which means that we can
+  // access IDWriteFontSet API which provides direct lookup by PostScript name
+  // and full font name, in which case we do not need to build this table.
+  bool HasDWriteUniqueFontLookups();
+
+  base::TimeDelta IndexingTimeout();
+
+  void PostCallbacks();
+
+  DWriteFontLookupTableBuilder();
+  ~DWriteFontLookupTableBuilder();
+
+  // Protobuf structure temporarily used and shared during table construction.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table_;
+
+  struct CallbackOnTaskRunner {
+    CallbackOnTaskRunner(
+        scoped_refptr<base::SequencedTaskRunner>,
+        blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback);
+    CallbackOnTaskRunner(CallbackOnTaskRunner&&);
+    ~CallbackOnTaskRunner();
+    scoped_refptr<base::SequencedTaskRunner> task_runner;
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback
+        mojo_callback;
+  };
+
+  // Task method to bind the CallbackOnTaskRunner for delayed execution when
+  // building the font table is completed.
+  void RunPendingCallback(CallbackOnTaskRunner pending_callback);
+
+  base::MappedReadOnlyRegion font_table_memory_;
+  base::AtomicFlag font_table_built_;
+
+  bool direct_write_initialized_ = false;
+  base::TimeDelta font_indexing_timeout_;
+  Microsoft::WRL::ComPtr<IDWriteFontCollection> collection_;
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2_;
+  Microsoft::WRL::ComPtr<IDWriteFactory3> factory3_;
+  SlowDownMode slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  uint32_t outstanding_family_results_ = 0;
+  uint32_t family_results_non_empty_ = 0;
+  uint32_t family_results_empty_ = 0;
+  base::TimeTicks start_time_table_ready_;
+  base::TimeTicks start_time_table_build_;
+  base::FilePath cache_directory_;
+
+  bool caching_enabled_ = true;
+  absl::optional<base::WaitableEvent> hang_event_for_testing_;
+  base::CancelableOnceCallback<void()> timeout_callback_;
+
+  // All responses are serialized through this DeferredSequencedTaskRunner. It
+  // is started when the table is ready and guarantees that requests made before
+  // the table was ready are replied to first.
+  scoped_refptr<base::DeferredSequencedTaskRunner> callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+
+  std::map<HRESULT, unsigned> scanning_error_reasons_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc
new file mode 100644
index 0000000000000..f121022d3075e
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc
@@ -0,0 +1,241 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/memory/raw_ptr.h"
+#include "base/path_service.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/test/bind.h"
+#include "base/test/scoped_feature_list.h"
+#include "base/test/task_environment.h"
+#include "content/public/common/content_features.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+
+namespace content {
+
+namespace {
+
+struct FontExpectation {
+  const char font_name[64];
+  uint16_t ttc_index;
+};
+
+constexpr FontExpectation kExpectedTestFonts[] = {{"CambriaMath", 1},
+                                                  {"Ming-Lt-HKSCS-ExtB", 2},
+                                                  {"NSimSun", 1},
+                                                  {"calibri-bolditalic", 0}};
+
+constexpr base::TimeDelta kTestingTimeout = base::Seconds(10);
+
+class DWriteFontLookupTableBuilderTest : public testing::Test {
+ public:
+  DWriteFontLookupTableBuilderTest() {
+    feature_list_.InitAndEnableFeature(features::kFontSrcLocalMatching);
+  }
+
+  void SetUp() override {
+    font_lookup_table_builder_ = DWriteFontLookupTableBuilder::GetInstance();
+    font_lookup_table_builder_->OverrideDWriteVersionChecksForTesting();
+    font_lookup_table_builder_->ResetLookupTableForTesting();
+    bool temp_dir_created = scoped_temp_dir_.CreateUniqueTempDir();
+    ASSERT_TRUE(temp_dir_created);
+    font_lookup_table_builder_->SetCacheDirectoryForTesting(
+        scoped_temp_dir_.GetPath());
+  }
+
+  void TearDown() override {
+    font_lookup_table_builder_->ResetStateForTesting();
+  }
+
+  void TestMatchFonts() {
+    base::ReadOnlySharedMemoryRegion font_table_memory =
+        font_lookup_table_builder_->DuplicateMemoryRegion();
+    blink::FontTableMatcher font_table_matcher(font_table_memory.Map());
+
+    for (auto& test_font_name_index : kExpectedTestFonts) {
+      absl::optional<blink::FontTableMatcher::MatchResult> match_result =
+          font_table_matcher.MatchName(test_font_name_index.font_name);
+      ASSERT_TRUE(match_result) << "No font matched for font name: "
+                                << test_font_name_index.font_name;
+      base::File unique_font_file(
+          base::FilePath::FromUTF8Unsafe(match_result->font_path),
+          base::File::FLAG_OPEN | base::File::FLAG_READ);
+      ASSERT_TRUE(unique_font_file.IsValid());
+      ASSERT_GT(unique_font_file.GetLength(), 0);
+      ASSERT_EQ(test_font_name_index.ttc_index, match_result->ttc_index);
+    }
+  }
+
+ protected:
+  base::test::ScopedFeatureList feature_list_;
+  base::test::TaskEnvironment task_environment_;
+  raw_ptr<DWriteFontLookupTableBuilder> font_lookup_table_builder_;
+  base::ScopedTempDir scoped_temp_dir_;
+};
+
+class DWriteFontLookupTableBuilderTimeoutTest
+    : public DWriteFontLookupTableBuilderTest,
+      public ::testing::WithParamInterface<
+          DWriteFontLookupTableBuilder::SlowDownMode> {};
+
+}  // namespace
+
+// Run a test similar to DWriteFontProxyImplUnitTest, TestFindUniqueFont but
+// without going through Mojo and running it on the DWRiteFontLookupTableBuilder
+// class directly.
+TEST_F(DWriteFontLookupTableBuilderTest, TestFindUniqueFontDirect) {
+  font_lookup_table_builder_->SchedulePrepareFontUniqueNameTableIfNeeded();
+  bool test_callback_executed = false;
+  font_lookup_table_builder_->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(),
+      base::BindLambdaForTesting(
+          [this, &test_callback_executed](base::ReadOnlySharedMemoryRegion) {
+            TestMatchFonts();
+            test_callback_executed = true;
+          }));
+  task_environment_.RunUntilIdle();
+  ASSERT_TRUE(test_callback_executed);
+}
+
+TEST_P(DWriteFontLookupTableBuilderTimeoutTest, TestTimeout) {
+  font_lookup_table_builder_->SetSlowDownIndexingForTestingWithTimeout(
+      GetParam(), kTestingTimeout);
+  font_lookup_table_builder_->SchedulePrepareFontUniqueNameTableIfNeeded();
+  bool test_callback_executed = false;
+  font_lookup_table_builder_->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(),
+      base::BindLambdaForTesting([this, &test_callback_executed](
+                                     base::ReadOnlySharedMemoryRegion
+                                         font_table_memory) {
+        blink::FontTableMatcher font_table_matcher(font_table_memory.Map());
+
+        for (auto& test_font_name_index : kExpectedTestFonts) {
+          absl::optional<blink::FontTableMatcher::MatchResult> match_result =
+              font_table_matcher.MatchName(test_font_name_index.font_name);
+          ASSERT_TRUE(!match_result);
+        }
+        if (GetParam() ==
+            DWriteFontLookupTableBuilder::SlowDownMode::kHangOneTask)
+          font_lookup_table_builder_->ResumeFromHangForTesting();
+        test_callback_executed = true;
+      }));
+  task_environment_.RunUntilIdle();
+  ASSERT_TRUE(test_callback_executed);
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    All,
+    DWriteFontLookupTableBuilderTimeoutTest,
+    ::testing::Values(
+        DWriteFontLookupTableBuilder::SlowDownMode::kDelayEachTask,
+        DWriteFontLookupTableBuilder::SlowDownMode::kHangOneTask));
+
+TEST_F(DWriteFontLookupTableBuilderTest, TestReadyEarly) {
+  font_lookup_table_builder_->SetSlowDownIndexingForTestingWithTimeout(
+      DWriteFontLookupTableBuilder::SlowDownMode::kHangOneTask,
+      kTestingTimeout);
+
+  font_lookup_table_builder_->SchedulePrepareFontUniqueNameTableIfNeeded();
+  bool test_callback_executed = false;
+  font_lookup_table_builder_->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(),
+      base::BindLambdaForTesting(
+          [this, &test_callback_executed](base::ReadOnlySharedMemoryRegion) {
+            ASSERT_TRUE(font_lookup_table_builder_->FontUniqueNameTableReady());
+            test_callback_executed = true;
+          }));
+  ASSERT_FALSE(font_lookup_table_builder_->FontUniqueNameTableReady());
+  font_lookup_table_builder_->ResumeFromHangForTesting();
+  task_environment_.RunUntilIdle();
+  ASSERT_TRUE(test_callback_executed);
+}
+
+TEST_F(DWriteFontLookupTableBuilderTest, RepeatedScheduling) {
+  for (unsigned i = 0; i < 3; ++i) {
+    font_lookup_table_builder_->ResetLookupTableForTesting();
+    font_lookup_table_builder_->SetCachingEnabledForTesting(false);
+    font_lookup_table_builder_->SchedulePrepareFontUniqueNameTableIfNeeded();
+    bool test_callback_executed = false;
+    font_lookup_table_builder_->QueueShareMemoryRegionWhenReady(
+        base::SequencedTaskRunner::GetCurrentDefault(),
+        base::BindLambdaForTesting(
+            [&test_callback_executed](base::ReadOnlySharedMemoryRegion) {
+              test_callback_executed = true;
+            }));
+    task_environment_.RunUntilIdle();
+    ASSERT_TRUE(test_callback_executed);
+  }
+}
+
+TEST_F(DWriteFontLookupTableBuilderTest, FontsHash) {
+  ASSERT_GT(
+      font_lookup_table_builder_->ComputePersistenceHash("6.0.1.2").size(), 0u);
+  // Validate an empty string doesn't cause problems.
+  ASSERT_GT(font_lookup_table_builder_->ComputePersistenceHash("").size(), 0u);
+}
+
+TEST_F(DWriteFontLookupTableBuilderTest, HandleCorruptCacheFile) {
+  // Cycle once to build cache file.
+  font_lookup_table_builder_->ResetLookupTableForTesting();
+  font_lookup_table_builder_->SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  bool test_callback_executed = false;
+  base::File cache_file;
+  font_lookup_table_builder_->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(),
+      base::BindLambdaForTesting([this, &cache_file, &test_callback_executed](
+                                     base::ReadOnlySharedMemoryRegion) {
+        ASSERT_TRUE(font_lookup_table_builder_->FontUniqueNameTableReady());
+        // Truncate table for testing
+        base::FilePath cache_file_path = scoped_temp_dir_.GetPath().Append(
+            FILE_PATH_LITERAL("font_unique_name_table.pb"));
+        // Use FLAG_WIN_EXCLUSIVE_WRITE to block file and make persisting the
+        // cache fail as well, use FLAG_OPEN to ensure it got created by the
+        // table builder implementation.
+        cache_file = base::File(cache_file_path,
+                                base::File::FLAG_OPEN | base::File::FLAG_READ |
+                                    base::File::FLAG_WRITE |
+                                    base::File::FLAG_WIN_EXCLUSIVE_WRITE);
+        // Ensure the cache file was created in the empty scoped_temp_dir_
+        // and has a non-zero length.
+        ASSERT_TRUE(cache_file.IsValid());
+        ASSERT_TRUE(cache_file.GetLength() > 0);
+        ASSERT_TRUE(cache_file.SetLength(cache_file.GetLength() / 2));
+        ASSERT_TRUE(cache_file.SetLength(cache_file.GetLength() * 2));
+        test_callback_executed = true;
+      }));
+  task_environment_.RunUntilIdle();
+  ASSERT_TRUE(test_callback_executed);
+
+  // Reload the cache file.
+  font_lookup_table_builder_->ResetLookupTableForTesting();
+  font_lookup_table_builder_->SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  test_callback_executed = false;
+  font_lookup_table_builder_->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(),
+      base::BindLambdaForTesting(
+          [this, &test_callback_executed](base::ReadOnlySharedMemoryRegion) {
+            TestMatchFonts();
+            test_callback_executed = true;
+          }));
+
+  task_environment_.RunUntilIdle();
+  ASSERT_TRUE(test_callback_executed);
+
+  // Ensure that the table is still valid even though persisting has failed
+  // due to the exclusive write lock on the file.
+  ASSERT_TRUE(font_lookup_table_builder_->FontUniqueNameTableReady());
+}
+
+}  // namespace content
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
index a42f326f9d951..6aa658d36f176 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
@@ -396,6 +396,21 @@ void DWriteFontProxyImpl::MapCharacters(
   DCHECK_GT(result->mapped_length, 0u);
 }
 
+void DWriteFontProxyImpl::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  /* Table is not synchronously available, return immediately. */
+  if (!DWriteFontLookupTableBuilder::GetInstance()
+           ->FontUniqueNameTableReady()) {
+    std::move(callback).Run(false, base::ReadOnlySharedMemoryRegion());
+    return;
+  }
+
+  std::move(callback).Run(
+      true,
+      DWriteFontLookupTableBuilder::GetInstance()->DuplicateMemoryRegion());
+}
+
 void DWriteFontProxyImpl::MatchUniqueFont(
     const std::u16string& unique_font_name,
     MatchUniqueFontCallback callback) {
@@ -485,6 +500,25 @@ void DWriteFontProxyImpl::MatchUniqueFont(
   std::move(callback).Run(std::move(font_file), ttc_index);
 }
 
+void DWriteFontProxyImpl::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {
+  InitializeDirectWrite();
+  // If factory3_ is available, that means we can use IDWriteFontSet to filter
+  // for PostScript name and full font name directly and do not need to build
+  // the lookup table.
+  blink::mojom::UniqueFontLookupMode lookup_mode =
+      factory3_.Get() ? blink::mojom::UniqueFontLookupMode::kSingleLookups
+                      : blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  std::move(callback).Run(lookup_mode);
+}
+
+void DWriteFontProxyImpl::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DWriteFontLookupTableBuilder::GetInstance()->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
+}
+
 void DWriteFontProxyImpl::FallbackFamilyAndStyleForCodepoint(
     const std::string& base_family_name,
     const std::string& locale_name,
@@ -543,15 +577,14 @@ void DWriteFontProxyImpl::InitializeDirectWrite() {
     return;
   }
 
-  // QueryInterface for IDWriteFactory2. This should succeed since we only
-  // support >= Win10.
+  // QueryInterface for IDWriteFactory2. It's ok for this to fail if we are
+  // running an older version of DirectWrite (earlier than Win8.1).
   factory_.As<IDWriteFactory2>(&factory2_);
-  DCHECK(factory2_);
 
-  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows.
-  // This should succeed since we only support >= Win10.
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
   factory_.As<IDWriteFactory3>(&factory3_);
-  DCHECK(factory3_);
 
   HRESULT hr = factory_->GetSystemFontCollection(&collection_);
   DCHECK(SUCCEEDED(hr));
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
index b01c7f171c591..66d503a8093ca 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "base/memory/read_only_shared_memory_region.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/browser_message_filter.h"
 #include "content/public/browser/browser_thread.h"
@@ -57,6 +58,15 @@ class CONTENT_EXPORT DWriteFontProxyImpl
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+
   void FallbackFamilyAndStyleForCodepoint(
       const std::string& base_family_name,
       const std::string& locale_name,
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
index e2475e0aac662..eea9f114d4d32 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
@@ -10,19 +10,25 @@
 #include <memory>
 
 #include "base/containers/contains.h"
+#include "base/file_version_info.h"
 #include "base/files/file.h"
+#include "base/files/scoped_temp_dir.h"
 #include "base/memory/ref_counted.h"
 #include "base/run_loop.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/synchronization/waitable_event.h"
 #include "base/test/scoped_feature_list.h"
 #include "base/test/task_environment.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/win/windows_version.h"
 #include "content/public/common/content_features.h"
 #include "content/public/test/browser_task_environment.h"
 #include "mojo/public/cpp/bindings/receiver.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/service_manager/public/cpp/bind_source_info.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
 #include "third_party/icu/source/common/unicode/umachine.h"
 #include "ui/gfx/test/font_fallback_test_data.h"
@@ -31,6 +37,24 @@ namespace content {
 
 namespace {
 
+struct FontExpectation {
+  const char* font_name;
+  uint16_t ttc_index;
+};
+
+constexpr FontExpectation kExpectedTestFonts[] = {{"CambriaMath", 1},
+                                                  {"Ming-Lt-HKSCS-ExtB", 2},
+                                                  {"NSimSun", 1},
+                                                  {"calibri-bolditalic", 0}};
+
+// DirectWrite on Windows supports IDWriteFontSet API which allows for querying
+// by PostScript name and full font name directly. In the implementation of
+// DWriteFontProxy we check whether this API is available by checking for
+// whether IDWriteFactory3 is available. In order to validate in a unit test
+// whether this check works, compare it against the dwrite.dll major version -
+// versions starting from 10 have the required functionality.
+constexpr int kDWriteMajorVersionSupportingSingleLookups = 10;
+
 // Base test class that sets up the Mojo connection to DWriteFontProxy so that
 // tests can call its Mojo methods.
 class DWriteFontProxyImplUnitTest : public testing::Test {
@@ -42,12 +66,60 @@ class DWriteFontProxyImplUnitTest : public testing::Test {
     return *dwrite_font_proxy_;
   }
 
+  bool SupportsSingleLookups() {
+    blink::mojom::UniqueFontLookupMode lookup_mode;
+    dwrite_font_proxy().GetUniqueFontLookupMode(&lookup_mode);
+    return lookup_mode == blink::mojom::UniqueFontLookupMode::kSingleLookups;
+  }
+
   base::test::TaskEnvironment task_environment_;
   mojo::Remote<blink::mojom::DWriteFontProxy> dwrite_font_proxy_;
   DWriteFontProxyImpl impl_;
   mojo::Receiver<blink::mojom::DWriteFontProxy> receiver_;
 };
 
+// Derived class for tests that exercise font unique local matching mojo methods
+// of DWriteFontProxy. Needs a ScopedFeatureList to activate the feature as it
+// is currently behind a flag.
+class DWriteFontProxyLocalMatchingTest : public DWriteFontProxyImplUnitTest {
+ public:
+  DWriteFontProxyLocalMatchingTest() {
+    feature_list_.InitAndEnableFeature(features::kFontSrcLocalMatching);
+  }
+
+ private:
+  base::test::ScopedFeatureList feature_list_;
+};
+
+// Derived class for tests that exercise the parts of the DWriteFontProxy Mojo
+// interface that deal with accessing the font lookup table created by
+// DWriteFontLookupTableBuilder. Initializes the DWriteFontLookupTableBuilder
+// and has a ScopedTempDir for testing persisting the lookup table to disk.
+class DWriteFontProxyTableMatchingTest
+    : public DWriteFontProxyLocalMatchingTest {
+ public:
+  void SetUp() override {
+    DWriteFontLookupTableBuilder* table_builder_instance =
+        DWriteFontLookupTableBuilder::GetInstance();
+    bool temp_dir_success = scoped_temp_dir_.CreateUniqueTempDir();
+    ASSERT_TRUE(temp_dir_success);
+    table_builder_instance->OverrideDWriteVersionChecksForTesting();
+    table_builder_instance->SetCacheDirectoryForTesting(
+        scoped_temp_dir_.GetPath());
+    table_builder_instance->ResetLookupTableForTesting();
+    table_builder_instance->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+
+  void TearDown() override {
+    DWriteFontLookupTableBuilder* table_builder_instance =
+        DWriteFontLookupTableBuilder::GetInstance();
+    table_builder_instance->ResetStateForTesting();
+  }
+
+ private:
+  base::ScopedTempDir scoped_temp_dir_;
+};
+
 TEST_F(DWriteFontProxyImplUnitTest, GetFamilyCount) {
   UINT32 family_count = 0;
   dwrite_font_proxy().GetFamilyCount(&family_count);
@@ -115,6 +187,9 @@ TEST_F(DWriteFontProxyImplUnitTest, GetFontFilesIndexOutOfBounds) {
 }
 
 TEST_F(DWriteFontProxyImplUnitTest, MapCharacter) {
+  if (!blink::DWriteRasterizerSupport::IsDWriteFactory2Available())
+    return;
+
   blink::mojom::MapCharactersResultPtr result;
   dwrite_font_proxy().MapCharacters(
       u"abc",
@@ -134,6 +209,9 @@ TEST_F(DWriteFontProxyImplUnitTest, MapCharacter) {
 }
 
 TEST_F(DWriteFontProxyImplUnitTest, MapCharacterInvalidCharacter) {
+  if (!blink::DWriteRasterizerSupport::IsDWriteFactory2Available())
+    return;
+
   blink::mojom::MapCharactersResultPtr result;
   dwrite_font_proxy().MapCharacters(
       u"\ufffe\uffffabc",
@@ -149,6 +227,9 @@ TEST_F(DWriteFontProxyImplUnitTest, MapCharacterInvalidCharacter) {
 }
 
 TEST_F(DWriteFontProxyImplUnitTest, MapCharacterInvalidAfterValid) {
+  if (!blink::DWriteRasterizerSupport::IsDWriteFactory2Available())
+    return;
+
   blink::mojom::MapCharactersResultPtr result;
   dwrite_font_proxy().MapCharacters(
       u"abc\ufffe\uffff",
@@ -187,7 +268,12 @@ TEST_F(DWriteFontProxyImplUnitTest, TestCustomFontFiles) {
 }
 
 TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
+  const bool on_win10 = base::win::GetVersion() >= base::win::Version::WIN10;
+
   for (auto& fallback_request : gfx::kGetFontFallbackTests) {
+    if (fallback_request.is_win10 && !on_win10)
+      continue;
+
     blink::mojom::FallbackFamilyAndStylePtr fallback_family_and_style;
     UChar32 codepoint;
     U16_GET(fallback_request.text.c_str(), 0, 0, fallback_request.text.size(),
@@ -212,6 +298,91 @@ TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
   }
 }
 
+namespace {
+void TestWhenLookupTableReady(
+    bool* did_test_fonts,
+    base::ReadOnlySharedMemoryRegion font_table_memory) {
+  blink::FontTableMatcher font_table_matcher(font_table_memory.Map());
+  for (auto& test_font_name_index : kExpectedTestFonts) {
+    absl::optional<blink::FontTableMatcher::MatchResult> match_result =
+        font_table_matcher.MatchName(test_font_name_index.font_name);
+    ASSERT_TRUE(match_result)
+        << "No font matched for font name: " << test_font_name_index.font_name;
+    base::File unique_font_file(
+        base::FilePath::FromUTF8Unsafe(match_result->font_path),
+        base::File::FLAG_OPEN | base::File::FLAG_READ);
+    ASSERT_TRUE(unique_font_file.IsValid());
+    ASSERT_GT(unique_font_file.GetLength(), 0);
+    ASSERT_EQ(test_font_name_index.ttc_index, match_result->ttc_index);
+    *did_test_fonts = true;
+  }
+}
+}  // namespace
+
+TEST_F(DWriteFontProxyTableMatchingTest, TestFindUniqueFont) {
+  bool lookup_table_results_were_tested = false;
+  dwrite_font_proxy().GetUniqueNameLookupTable(base::BindOnce(
+      &TestWhenLookupTableReady, &lookup_table_results_were_tested));
+  task_environment_.RunUntilIdle();
+  ASSERT_TRUE(lookup_table_results_were_tested);
+}
+
+TEST_F(DWriteFontProxyLocalMatchingTest, TestSingleLookup) {
+  // Do not run this test on unsupported Windows versions.
+  if (!SupportsSingleLookups())
+    return;
+  for (auto& test_font_name_index : kExpectedTestFonts) {
+    base::File result_handle;
+    uint32_t ttc_index;
+    dwrite_font_proxy().MatchUniqueFont(
+        base::UTF8ToUTF16(test_font_name_index.font_name), &result_handle,
+        &ttc_index);
+    ASSERT_TRUE(result_handle.IsValid());
+    ASSERT_GT(result_handle.GetLength(), 0);
+    ASSERT_EQ(test_font_name_index.ttc_index, ttc_index);
+  }
+}
+
+TEST_F(DWriteFontProxyLocalMatchingTest, TestSingleLookupUnavailable) {
+  // Do not run this test on unsupported Windows versions.
+  if (!SupportsSingleLookups())
+    return;
+  base::File result_handle;
+  uint32_t ttc_index;
+  std::u16string unavailable_font_name =
+      u"Unavailable_Font_Name_56E7EA7E-2C69-4E23-99DC-750BC19B250E";
+  dwrite_font_proxy().MatchUniqueFont(unavailable_font_name, &result_handle,
+                                      &ttc_index);
+  ASSERT_FALSE(result_handle.IsValid());
+  ASSERT_EQ(ttc_index, 0u);
+}
+
+TEST_F(DWriteFontProxyLocalMatchingTest, TestLookupMode) {
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  int dwrite_major_version_number = 0;
+  ASSERT_TRUE(
+      base::StringToInt(dwrite_version.substr(0, dwrite_version.find(".")),
+                        &dwrite_major_version_number));
+
+  blink::mojom::UniqueFontLookupMode expected_lookup_mode;
+  if (dwrite_major_version_number >=
+      kDWriteMajorVersionSupportingSingleLookups) {
+    expected_lookup_mode = blink::mojom::UniqueFontLookupMode::kSingleLookups;
+  } else {
+    expected_lookup_mode = blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  }
+
+  blink::mojom::UniqueFontLookupMode lookup_mode;
+  dwrite_font_proxy().GetUniqueFontLookupMode(&lookup_mode);
+  ASSERT_EQ(lookup_mode, expected_lookup_mode);
+}
+
 }  // namespace
 
 }  // namespace content
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 0f4588f2d8fd8..59bf2ea0c1064 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3495,6 +3495,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
 #endif
 #if BUILDFLAG(IS_WIN)
     switches::kDisableHighResTimer,
+    switches::kEnableWin7WebRtcHWH264Decoding,
     switches::kTrySupportedChannelLayouts,
     switches::kRaiseTimerFrequency,
 #endif
diff --git a/content/browser/renderer_host/render_widget_host_view_aura_vk_browsertest.cc b/content/browser/renderer_host/render_widget_host_view_aura_vk_browsertest.cc
index 2541bea8d7201..8046505dbba7a 100644
--- a/content/browser/renderer_host/render_widget_host_view_aura_vk_browsertest.cc
+++ b/content/browser/renderer_host/render_widget_host_view_aura_vk_browsertest.cc
@@ -4,6 +4,7 @@
 
 #include "base/memory/raw_ptr.h"
 #include "base/observer_list.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "content/browser/accessibility/browser_accessibility.h"
 #include "content/browser/accessibility/browser_accessibility_manager.h"
@@ -200,6 +201,11 @@ class RenderWidgetHostViewAuraBrowserMockIMETest : public ContentBrowserTest {
 #if BUILDFLAG(IS_WIN)
 IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
                        VirtualKeyboardAccessibilityFocusTest) {
+  // The keyboard input pane events are not supported on Win7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return;
+  }
+
   LoadInitialAccessibilityTreeFromHtml(R"HTML(
       <div><button>Before</button></div>
       <div contenteditable>Editable text</div>
@@ -227,6 +233,11 @@ IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
 
 IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
                        VirtualKeyboardShowVKTest) {
+  // The keyboard input pane events are not supported on Win7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return;
+  }
+
   GURL start_url = server_.GetURL("a.test", "/virtual-keyboard.html");
   ASSERT_TRUE(NavigateToURL(shell(), start_url));
 
@@ -255,6 +266,11 @@ IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
 
 IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
                        DontShowVKOnJSFocus) {
+  // The keyboard input pane events are not supported on Win7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return;
+  }
+
   WebContentsImpl* web_contents =
       static_cast<WebContentsImpl*>(shell()->web_contents());
   TextInputManagerShowImeIfNeededObserver show_ime_observer_false(web_contents,
@@ -283,6 +299,11 @@ IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
 
 IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
                        ShowAndThenHideVK) {
+  // The keyboard input pane events are not supported on Win7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return;
+  }
+
   GURL start_url = server_.GetURL("a.test", "/virtual-keyboard.html");
   ASSERT_TRUE(NavigateToURL(shell(), start_url));
 
@@ -316,6 +337,11 @@ IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
 
 IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
                        ShowAndThenHideVKInEditContext) {
+  // The keyboard input pane events are not supported on Win7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return;
+  }
+
   GURL start_url = server_.GetURL("a.test", "/virtual-keyboard.html");
   ASSERT_TRUE(NavigateToURL(shell(), start_url));
 
@@ -349,6 +375,11 @@ IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
 
 IN_PROC_BROWSER_TEST_F(RenderWidgetHostViewAuraBrowserMockIMETest,
                        VKVisibilityRequestInDeletedDocument) {
+  // The keyboard input pane events are not supported on Win7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return;
+  }
+
   const char kVirtualKeyboardDataURL[] =
       "data:text/html,<!DOCTYPE html>"
       "<body>"
diff --git a/content/child/font_warmup_win.cc b/content/child/font_warmup_win.cc
index d71bd63281f51..f8a50e5081e8a 100644
--- a/content/child/font_warmup_win.cc
+++ b/content/child/font_warmup_win.cc
@@ -7,8 +7,6 @@
 #include <dwrite.h>
 #include <stdint.h>
 #include <map>
-#include <string>
-#include <utility>
 
 #include "base/debug/alias.h"
 #include "base/files/file_path.h"
@@ -24,6 +22,7 @@
 #include "base/sys_byteorder.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/iat_patch_function.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "ppapi/buildflags/buildflags.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
@@ -392,7 +391,10 @@ void PatchServiceManagerCalls() {
   static bool is_patched = false;
   if (is_patched)
     return;
-  const char* service_provider_dll = "api-ms-win-service-management-l1-1-0.dll";
+  const char* service_provider_dll =
+      (base::win::GetVersion() >= base::win::Version::WIN8
+           ? "api-ms-win-service-management-l1-1-0.dll"
+           : "advapi32.dll");
 
   is_patched = true;
 
diff --git a/content/child/font_warmup_win_unittest.cc b/content/child/font_warmup_win_unittest.cc
index 051af55e65a2c..80eb0ec7f9add 100644
--- a/content/child/font_warmup_win_unittest.cc
+++ b/content/child/font_warmup_win_unittest.cc
@@ -19,6 +19,7 @@
 #include "base/path_service.h"
 #include "base/sys_byteorder.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
 
 #include "content/child/dwrite_font_proxy/dwrite_font_proxy_win.h"
 #include "content/public/common/content_paths.h"
@@ -136,6 +137,8 @@ int CALLBACK EnumFontCallbackTest(const LOGFONT* log_font,
 }  // namespace
 
 TEST_F(GDIFontEmulationTest, CreateDeleteDCSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_FALSE(!patch_data);
 
@@ -147,6 +150,8 @@ TEST_F(GDIFontEmulationTest, CreateDeleteDCSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateUniqueDCSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
 
@@ -162,6 +167,8 @@ TEST_F(GDIFontEmulationTest, CreateUniqueDCSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateFontSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   LOGFONTW logfont = {0};
@@ -173,6 +180,8 @@ TEST_F(GDIFontEmulationTest, CreateFontSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, CreateFontFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   LOGFONTW logfont = {0};
@@ -182,6 +191,8 @@ TEST_F(GDIFontEmulationTest, CreateFontFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, EnumFontFamilySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -194,6 +205,8 @@ TEST_F(GDIFontEmulationTest, EnumFontFamilySuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, EnumFontFamilyFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -206,6 +219,8 @@ TEST_F(GDIFontEmulationTest, EnumFontFamilyFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, DeleteDCFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = reinterpret_cast<HDC>(0x55667788);
@@ -213,6 +228,8 @@ TEST_F(GDIFontEmulationTest, DeleteDCFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, DeleteObjectFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HFONT font = reinterpret_cast<HFONT>(0x88aabbcc);
@@ -220,6 +237,8 @@ TEST_F(GDIFontEmulationTest, DeleteObjectFailure) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataSizeSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -237,6 +256,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataSizeSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataInvalidTagSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -253,6 +274,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataInvalidTagSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataInvalidFontSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
@@ -263,6 +286,8 @@ TEST_F(GDIFontEmulationTest, GetFontDataInvalidFontSuccess) {
 }
 
 TEST_F(GDIFontEmulationTest, GetFontDataDataSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   std::unique_ptr<GdiFontPatchData> patch_data(SetupTest());
   EXPECT_NE(patch_data, nullptr);
   HDC hdc = CreateCompatibleDC(0);
diff --git a/content/child/runtime_features.cc b/content/child/runtime_features.cc
index 43d691207c097..3a75babe0f5d4 100644
--- a/content/child/runtime_features.cc
+++ b/content/child/runtime_features.cc
@@ -4,7 +4,6 @@
 
 #include "content/child/runtime_features.h"
 
-#include <string>
 #include <vector>
 
 #include "base/base_switches.h"
@@ -52,6 +51,10 @@
 #include "device/vr/public/cpp/features.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using blink::WebRuntimeFeatures;
 
 namespace {
@@ -69,7 +72,9 @@ void SetRuntimeFeatureDefaultsForPlatform(
   WebRuntimeFeatures::EnableCompositedSelectionUpdate(true);
 #endif
 #if BUILDFLAG(IS_WIN)
-  WebRuntimeFeatures::EnableWebBluetooth(true);
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    WebRuntimeFeatures::EnableWebBluetooth(true);
+  }
 #endif
 
 #if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_CHROMEOS_LACROS)
diff --git a/content/child/webthemeengine_impl_default_browsertest.cc b/content/child/webthemeengine_impl_default_browsertest.cc
index a638c432bb49d..e68ee23fdbd23 100644
--- a/content/child/webthemeengine_impl_default_browsertest.cc
+++ b/content/child/webthemeengine_impl_default_browsertest.cc
@@ -15,7 +15,7 @@ namespace content {
 
 class WebThemeEngineImplDefaultBrowserTest : public ContentBrowserTest {
  public:
-  WebThemeEngineImplDefaultBrowserTest() = default;
+  WebThemeEngineImplDefaultBrowserTest() {}
 };
 
 #if BUILDFLAG(IS_WIN)
@@ -23,9 +23,6 @@ IN_PROC_BROWSER_TEST_F(WebThemeEngineImplDefaultBrowserTest, GetSystemColor) {
   // The test non-deterministically fails on Windows-2008ServerR2 builders due
   // to a difference in the default theme. As a result, only run the test on
   // non-server versions.
-  // TODO(https://crbug.com/1385856): Remove this, and the windows_version.h
-  // include, if the failure turns out to be specific to Windows-2008ServerR2
-  // and not any Windows server.
   if (base::win::OSInfo::GetInstance()->version_type() ==
       base::win::VersionType::SUITE_SERVER) {
     return;
@@ -115,19 +112,36 @@ IN_PROC_BROWSER_TEST_F(WebThemeEngineImplDefaultBrowserTest, GetSystemColor) {
                                   "window",
                                   "windowFrame",
                                   "windowText"};
-  const std::vector<std::string> expected_colors = {
-      "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
-      "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
-      "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
-      "rgb(0, 120, 215)",   "rgb(255, 255, 255)", "rgb(0, 0, 0)",
-      "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
-      "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
-      "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
-      "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  std::vector<std::string> expected_colors;
+  if (base::win::GetVersion() <= base::win::Version::WIN8_1) {
+    expected_colors = {
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
+        "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
+        "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
+        "rgb(51, 153, 255)",  "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  } else {
+    expected_colors = {
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)",       "rgb(0, 102, 204)",
+        "rgb(255, 255, 255)", "rgb(255, 255, 255)", "rgb(240, 240, 240)",
+        "rgb(240, 240, 240)", "rgb(240, 240, 240)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(0, 0, 0)",       "rgb(109, 109, 109)",
+        "rgb(0, 120, 215)",   "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(255, 255, 255)", "rgb(0, 0, 0)",
+        "rgb(240, 240, 240)", "rgb(0, 0, 0)",       "rgb(0, 0, 0)",
+        "rgb(0, 0, 0)",       "rgb(0, 102, 204)",   "rgb(255, 255, 255)",
+        "rgb(0, 0, 0)",       "rgb(0, 0, 0)"};
+  }
 
   ASSERT_EQ(ids.size(), expected_colors.size());
 
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index 75dbea1be3e60..28afdb7d6f13a 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -670,6 +670,10 @@ std::string ContentBrowserClient::GetDefaultDownloadName() {
   return std::string();
 }
 
+base::FilePath ContentBrowserClient::GetFontLookupTableCacheDir() {
+  return base::FilePath();
+}
+
 base::FilePath ContentBrowserClient::GetShaderDiskCacheDirectory() {
   return base::FilePath();
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index 868dd480c66e3..174a8d9197876 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1083,6 +1083,11 @@ class CONTENT_EXPORT ContentBrowserClient {
   // else we should do with the file.
   virtual std::string GetDefaultDownloadName();
 
+  // Returns the path to the font lookup table cache directory in which - on
+  // Windows 7 & 8 - we cache font name meta information to perform @font-face {
+  // src: local() } lookups.
+  virtual base::FilePath GetFontLookupTableCacheDir();
+
   // Returns the path to the browser shader disk cache root.
   virtual base::FilePath GetShaderDiskCacheDirectory();
 
diff --git a/content/public/common/content_features.cc b/content/public/common/content_features.cc
index d9940584efb10..8a831d908dd9e 100644
--- a/content/public/common/content_features.cc
+++ b/content/public/common/content_features.cc
@@ -4,14 +4,16 @@
 
 #include "content/public/common/content_features.h"
 
-#include <string>
-
 #include "base/feature_list.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "content/common/buildflags.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace features {
 
 // All features in alphabetical order.
@@ -1558,6 +1560,11 @@ VideoCaptureServiceConfiguration GetVideoCaptureServiceConfiguration() {
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
   return VideoCaptureServiceConfiguration::kEnabledForBrowserProcess;
 #else
+#if BUILDFLAG(IS_WIN)
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    return VideoCaptureServiceConfiguration::kEnabledForBrowserProcess;
+  }
+#endif
   return base::FeatureList::IsEnabled(
              features::kRunVideoCaptureServiceInBrowserProcess)
              ? VideoCaptureServiceConfiguration::kEnabledForBrowserProcess
diff --git a/content/public/common/content_switches.cc b/content/public/common/content_switches.cc
index 02d4e1b7f2ea2..d8aa08b05e337 100644
--- a/content/public/common/content_switches.cc
+++ b/content/public/common/content_switches.cc
@@ -1033,6 +1033,10 @@ const char kDeviceScaleFactor[]     = "device-scale-factor";
 // Disable the Legacy Window which corresponds to the size of the WebContents.
 const char kDisableLegacyIntermediateWindow[] = "disable-legacy-window";
 
+// Enables H264 HW decode acceleration for WebRtc on Win 7.
+const char kEnableWin7WebRtcHWH264Decoding[] =
+    "enable-win7-webrtc-hw-h264-decoding";
+
 // DirectWrite FontCache is shared by browser to renderers using shared memory.
 // This switch allows us to pass the shared memory handle to the renderer.
 const char kFontCacheSharedHandle[] = "font-cache-shared-handle";
diff --git a/content/public/common/content_switches.h b/content/public/common/content_switches.h
index bd73d0f6d2f5e..54415091a4054 100644
--- a/content/public/common/content_switches.h
+++ b/content/public/common/content_switches.h
@@ -282,6 +282,7 @@ CONTENT_EXPORT extern const char kPrefetchArgumentOther[];
 // like renderers, etc.
 CONTENT_EXPORT extern const char kDeviceScaleFactor[];
 CONTENT_EXPORT extern const char kDisableLegacyIntermediateWindow[];
+CONTENT_EXPORT extern const char kEnableWin7WebRtcHWH264Decoding[];
 // Switch to pass the font cache shared memory handle to the renderer.
 CONTENT_EXPORT extern const char kFontCacheSharedHandle[];
 CONTENT_EXPORT extern const char kPpapiAntialiasedTextEnabled[];
diff --git a/content/renderer/pepper/content_renderer_pepper_host_factory.cc b/content/renderer/pepper/content_renderer_pepper_host_factory.cc
index 54379d58e8cd0..c732b56f4a3d6 100644
--- a/content/renderer/pepper/content_renderer_pepper_host_factory.cc
+++ b/content/renderer/pepper/content_renderer_pepper_host_factory.cc
@@ -40,6 +40,10 @@
 #include "third_party/blink/public/web/web_document.h"
 #include "third_party/blink/public/web/web_plugin_container.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using ppapi::host::ResourceHost;
 using ppapi::UnpackMessage;
 
@@ -120,10 +124,12 @@ ContentRendererPepperHostFactory::CreateResourceHost(
       ppapi::PPB_ImageData_Shared::ImageDataType image_type =
           ppapi::PPB_ImageData_Shared::PLATFORM;
 #if BUILDFLAG(IS_WIN)
+      // Win32K lockdown mitigations are enabled for Windows 8 and beyond.
       // We use the SIMPLE image data type as the PLATFORM image data type
       // calls GDI functions to create DIB sections etc which fail in Win32K
       // lockdown mode.
-      image_type = ppapi::PPB_ImageData_Shared::SIMPLE;
+      if (base::win::GetVersion() >= base::win::Version::WIN8)
+        image_type = ppapi::PPB_ImageData_Shared::SIMPLE;
 #endif
       scoped_refptr<PPB_ImageData_Impl> image_data(new PPB_ImageData_Impl(
           instance, image_type));
diff --git a/content/renderer/pepper/resource_creation_impl.cc b/content/renderer/pepper/resource_creation_impl.cc
index a4a00ac5cb2e3..8db7102d7e1ab 100644
--- a/content/renderer/pepper/resource_creation_impl.cc
+++ b/content/renderer/pepper/resource_creation_impl.cc
@@ -27,6 +27,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/command_line.h"
+#include "base/win/windows_version.h"
 #endif
 
 using ppapi::InputEventData;
@@ -136,17 +137,18 @@ PP_Resource ResourceCreationImpl::CreateImageData(PP_Instance instance,
                                                   const PP_Size* size,
                                                   PP_Bool init_to_zero) {
 #if BUILDFLAG(IS_WIN)
-  // We use the SIMPLE image data type as the PLATFORM image data type
+  // If Win32K lockdown mitigations are enabled for Windows 8 and beyond,
+  // we use the SIMPLE image data type as the PLATFORM image data type
   // calls GDI functions to create DIB sections etc which fail in Win32K
   // lockdown mode.
-  return CreateImageDataSimple(instance, format, size, init_to_zero);
-#else
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    return CreateImageDataSimple(instance, format, size, init_to_zero);
+#endif
   return PPB_ImageData_Impl::Create(instance,
                                     ppapi::PPB_ImageData_Shared::PLATFORM,
                                     format,
                                     *size,
                                     init_to_zero);
-#endif
 }
 
 PP_Resource ResourceCreationImpl::CreateImageDataSimple(
diff --git a/content/renderer/render_view_browsertest.cc b/content/renderer/render_view_browsertest.cc
index d1f61c4e57355..83ff9d52fbcda 100644
--- a/content/renderer/render_view_browsertest.cc
+++ b/content/renderer/render_view_browsertest.cc
@@ -123,6 +123,10 @@
 #include "third_party/blink/public/common/input/web_input_event.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_OZONE)
 #include "ui/events/keycodes/keyboard_code_conversion.h"
 #endif
@@ -3152,6 +3156,12 @@ TEST_F(RenderViewImplScaleFactorTest, ConvertViewportToWindow) {
 TEST_F(RenderViewImplScaleFactorTest,
        DISABLED_GetCompositionCharacterBoundsTest) {  // http://crbug.com/582016
   SetDeviceScaleFactor(1.f);
+#if BUILDFLAG(IS_WIN)
+  // http://crbug.com/508747
+  if (base::win::GetVersion() >= base::win::Version::WIN10)
+    return;
+#endif
+
   LoadHTML("<textarea id=\"test\"></textarea>");
   ExecuteJavaScriptForTests("document.getElementById('test').focus();");
 
diff --git a/content/renderer/renderer_blink_platform_impl.cc b/content/renderer/renderer_blink_platform_impl.cc
index a0811daead7bc..3fec748b4c76c 100644
--- a/content/renderer/renderer_blink_platform_impl.cc
+++ b/content/renderer/renderer_blink_platform_impl.cc
@@ -120,6 +120,10 @@
 #include "base/file_descriptor_posix.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 using blink::Platform;
 using blink::WebAudioDevice;
 using blink::WebAudioLatencyHint;
@@ -624,6 +628,22 @@ void RendererBlinkPlatformImpl::GetWebRTCRendererPreferences(
   *allow_mdns_obfuscation = true;
 }
 
+bool RendererBlinkPlatformImpl::IsWebRtcHWH264DecodingEnabled(
+    webrtc::VideoCodecType video_codec_type) {
+#if BUILDFLAG(IS_WIN)
+  // Do not use hardware decoding for H.264 on Win7, due to high latency.
+  // See https://crbug.com/webrtc/5717.
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kEnableWin7WebRtcHWH264Decoding) &&
+      video_codec_type == webrtc::kVideoCodecH264 &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    DVLOG(1) << "H.264 HW decoding is not supported on Win7";
+    return false;
+  }
+#endif  // BUILDFLAG(IS_WIN)
+  return true;
+}
+
 bool RendererBlinkPlatformImpl::IsWebRtcHWEncodingEnabled() {
   return !base::CommandLine::ForCurrentProcess()->HasSwitch(
       switches::kDisableWebRtcHWEncoding);
diff --git a/content/renderer/renderer_blink_platform_impl.h b/content/renderer/renderer_blink_platform_impl.h
index f9b61ff32e3e7..2b0c4e3a7d5ee 100644
--- a/content/renderer/renderer_blink_platform_impl.h
+++ b/content/renderer/renderer_blink_platform_impl.h
@@ -153,6 +153,8 @@ class CONTENT_EXPORT RendererBlinkPlatformImpl : public BlinkPlatformImpl {
                                     uint16_t* udp_min_port,
                                     uint16_t* udp_max_port,
                                     bool* allow_mdns_obfuscation) override;
+  bool IsWebRtcHWH264DecodingEnabled(
+      webrtc::VideoCodecType video_coded_type) override;
   bool IsWebRtcHWEncodingEnabled() override;
   bool IsWebRtcHWDecodingEnabled() override;
   bool IsWebRtcSrtpAesGcmEnabled() override;
diff --git a/content/shell/browser/shell_content_browser_client.cc b/content/shell/browser/shell_content_browser_client.cc
index 9f48acb9dd982..f2da991706dda 100644
--- a/content/shell/browser/shell_content_browser_client.cc
+++ b/content/shell/browser/shell_content_browser_client.cc
@@ -450,6 +450,11 @@ void ShellContentBrowserClient::OverrideWebkitPrefs(
     override_web_preferences_callback_.Run(prefs);
 }
 
+base::FilePath ShellContentBrowserClient::GetFontLookupTableCacheDir() {
+  return browser_context()->GetPath().Append(
+      FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 std::unique_ptr<content::DevToolsManagerDelegate>
 ShellContentBrowserClient::CreateDevToolsManagerDelegate() {
   return std::make_unique<ShellDevToolsManagerDelegate>(browser_context());
diff --git a/content/shell/browser/shell_content_browser_client.h b/content/shell/browser/shell_content_browser_client.h
index f070810b8c150..176a7fe15b1fd 100644
--- a/content/shell/browser/shell_content_browser_client.h
+++ b/content/shell/browser/shell_content_browser_client.h
@@ -77,6 +77,7 @@ class ShellContentBrowserClient : public ContentBrowserClient {
       override;
   void OverrideWebkitPrefs(WebContents* web_contents,
                            blink::web_pref::WebPreferences* prefs) override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   std::unique_ptr<content::DevToolsManagerDelegate>
   CreateDevToolsManagerDelegate() override;
   void ExposeInterfacesToRenderer(
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index 00ac830553e3a..2495fc91af0a4 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -2963,6 +2963,7 @@ test("content_unittests") {
       "../browser/renderer_host/direct_manipulation_test_helper_win.cc",
       "../browser/renderer_host/direct_manipulation_test_helper_win.h",
       "../browser/renderer_host/direct_manipulation_win_unittest.cc",
+      "../browser/renderer_host/dwrite_font_lookup_table_builder_win_unittest.cc",
       "../browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc",
       "../browser/screenlock_monitor/screenlock_monitor_device_source_win_unittest.cc",
       "../child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc",
diff --git a/content/test/data/accessibility/aom/aom-live-region-expected-uia-win7.txt b/content/test/data/accessibility/aom/aom-live-region-expected-uia-win7.txt
new file mode 100644
index 0000000000000..163a0a34d82d8
--- /dev/null
+++ b/content/test/data/accessibility/aom/aom-live-region-expected-uia-win7.txt
@@ -0,0 +1,5 @@
+Document LocalizedControlType='document' AriaProperties='readonly=true;expanded=false;multiline=false;multiselectable=false;required=false'
+++Text LocalizedControlType='marquee' IsControlElement=false AriaProperties='atomic=false;readonly=true;expanded=false;live=off;multiline=false;multiselectable=false;relevant=additions text;required=false'
+++Text LocalizedControlType='marquee' IsControlElement=false AriaProperties='atomic=false;readonly=true;expanded=false;live=polite;multiline=false;multiselectable=false;relevant=additions text;required=false'
+++StatusBar LocalizedControlType='status bar' IsControlElement=false AriaProperties='atomic=true;readonly=true;expanded=false;live=assertive;multiline=false;multiselectable=false;relevant=additions text;required=false'
+++Text LocalizedControlType='alert' IsControlElement=false AriaProperties='atomic=true;readonly=true;expanded=false;live=assertive;multiline=false;multiselectable=false;relevant=additions text;required=false'
diff --git a/content/test/data/accessibility/aom/aom-modal-dialog-expected-uia-win7.txt b/content/test/data/accessibility/aom/aom-modal-dialog-expected-uia-win7.txt
new file mode 100644
index 0000000000000..443fa44dee354
--- /dev/null
+++ b/content/test/data/accessibility/aom/aom-modal-dialog-expected-uia-win7.txt
@@ -0,0 +1,7 @@
+#<skip -- crbug.com/1289698>
+Document LocalizedControlType='document'
+++Group LocalizedControlType='group' IsControlElement=false
+++++Text LocalizedControlType='text' Name='Content outside modal dialog. '
+++++Button LocalizedControlType='button' Name='Button outside modal dialog.'
+++Window LocalizedControlType='pane' Name='Modal dialog.' Window.IsModal=true
+++++Button LocalizedControlType='button' Name='Button inside modal dialog.'
diff --git a/content/test/data/accessibility/aria/aria-contentinfo-expected-uia-win7.txt b/content/test/data/accessibility/aria/aria-contentinfo-expected-uia-win7.txt
new file mode 100644
index 0000000000000..00a31d3b2426b
--- /dev/null
+++ b/content/test/data/accessibility/aria/aria-contentinfo-expected-uia-win7.txt
@@ -0,0 +1,3 @@
+Document
+++Group LocalizedControlType='content information'
+++++Text Name='This is ARIA role contentinfo.'
diff --git a/content/test/data/accessibility/aria/aria-describedby-expected-uia-win7.txt b/content/test/data/accessibility/aria/aria-describedby-expected-uia-win7.txt
new file mode 100644
index 0000000000000..dc9221b23fb07
--- /dev/null
+++ b/content/test/data/accessibility/aria/aria-describedby-expected-uia-win7.txt
@@ -0,0 +1,5 @@
+Document
+++Edit
+++ToolTip Name='Your username should be your email id'
+++++Text Name='Your username should be your email id' IsControlElement=false
+++Edit
diff --git a/content/test/data/accessibility/aria/aria-description-expected-uia-win7.txt b/content/test/data/accessibility/aria/aria-description-expected-uia-win7.txt
new file mode 100644
index 0000000000000..6eaa4dc5ef16f
--- /dev/null
+++ b/content/test/data/accessibility/aria/aria-description-expected-uia-win7.txt
@@ -0,0 +1,5 @@
+Document
+++Group Name='description'
+++Group Name='both'
+++ToolTip Name='Description from describedby'
+++++Text Name='Description from describedby' IsControlElement=false
diff --git a/content/test/data/accessibility/aria/aria-details-multiple-expected-uia-win7.txt b/content/test/data/accessibility/aria/aria-details-multiple-expected-uia-win7.txt
new file mode 100644
index 0000000000000..65ddf5e5e55e2
--- /dev/null
+++ b/content/test/data/accessibility/aria/aria-details-multiple-expected-uia-win7.txt
@@ -0,0 +1,11 @@
+Document
+++Text Name='Some '
+++Text
+++++Text Name='highlighted text'
+++Text Name=' example.'
+++Group
+++++Text Name='Good job!'
+++ListItem
+++++Text Name='Some footnote.'
+++Group
+++++Text Name='The meaning is.'
diff --git a/content/test/data/accessibility/aria/aria-tree-discontinuous-expected-uia-win7.txt b/content/test/data/accessibility/aria/aria-tree-discontinuous-expected-uia-win7.txt
new file mode 100644
index 0000000000000..92a3e0f47c279
--- /dev/null
+++ b/content/test/data/accessibility/aria/aria-tree-discontinuous-expected-uia-win7.txt
@@ -0,0 +1,7 @@
+Document
+++Tree Selection.CanSelectMultiple=false Selection.IsSelectionRequired=false
+++++TreeItem Name='card content' ExpandCollapse.ExpandCollapseState='LeafNode' SelectionItem.IsSelected=false
+++++++Text Name='card content' IsControlElement=false
+++++Group
+++++TreeItem Name='card content' ExpandCollapse.ExpandCollapseState='LeafNode' SelectionItem.IsSelected=false
+++++++Text Name='card content' IsControlElement=false
diff --git a/content/test/data/accessibility/aria/aria-treegrid-expected-uia-win7.txt b/content/test/data/accessibility/aria/aria-treegrid-expected-uia-win7.txt
new file mode 100644
index 0000000000000..4d729532d4ea1
--- /dev/null
+++ b/content/test/data/accessibility/aria/aria-treegrid-expected-uia-win7.txt
@@ -0,0 +1,79 @@
+Document
+++DataGrid Grid.ColumnCount=2 Grid.RowCount=8 Selection.CanSelectMultiple=false Selection.IsSelectionRequired=false Table.RowOrColumnMajor='RowMajor'
+++++TreeItem Name='Cell 1, row 1, level 1 Cell 2, row 1, level 1'
+++++++DataItem Name='Cell 1, row 1, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 1, level 1' IsControlElement=false
+++++++DataItem Name='Cell 2, row 1, level 1' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1
+++++++++Text Name='Cell 2, row 1, level 1' IsControlElement=false
+++++TreeItem Name='Cell 1, row 2, level 1 Cell 2, row 2, level 1'
+++++++DataItem Name='Cell 1, row 2, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 2, level 1' IsControlElement=false
+++++++DataItem Name='Cell 2, row 2, level 1' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1
+++++++++Text Name='Cell 2, row 2, level 1' IsControlElement=false
+++++TreeItem Name='Cell 1, row 3, level 1 Cell 2, row 3, level 1'
+++++++DataItem Name='Cell 1, row 3, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 3, level 1' IsControlElement=false
+++++++DataItem Name='Cell 2, row 3, level 1' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1
+++++++++Text Name='Cell 2, row 3, level 1' IsControlElement=false
+++++TreeItem Name='Cell 1, row 1, level 2'
+++++++DataItem Name='Cell 1, row 1, level 2' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 1, level 2' IsControlElement=false
+++++TreeItem Name='Cell 1, row 2, level 2'
+++++++DataItem Name='Cell 1, row 2, level 2' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 2, level 2' IsControlElement=false
+++++TreeItem Name='Cell 1, row 3, level 2'
+++++++DataItem Name='Cell 1, row 3, level 2' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 3, level 2' IsControlElement=false
+++++TreeItem Name='Cell 1, row 4, level 2'
+++++++DataItem Name='Cell 1, row 4, level 2' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=6 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 4, level 2' IsControlElement=false
+++++TreeItem Name='Cell 1, row 2, level 2'
+++++++DataItem Name='Cell 1, row 2, level 2' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=7 GridItem.RowSpan=1
+++++++++Text Name='Cell 1, row 2, level 2' IsControlElement=false
+++DataGrid Grid.ColumnCount=3 Grid.RowCount=7 Selection.CanSelectMultiple=false Selection.IsSelectionRequired=false Table.RowOrColumnMajor='RowMajor'
+++++Group
+++++++TreeItem Name='Cell 1, row 1, rowgroup 1, level 1'
+++++++++DataItem Name='Cell 1, row 1, rowgroup 1, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1
+++++++++++Text Name='Cell 1, row 1, rowgroup 1, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 2, rowgroup 1, level 1'
+++++++++DataItem Name='Cell 1, row 2, rowgroup 1, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1
+++++++++++Text Name='Cell 1, row 2, rowgroup 1, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 3, rowgroup 1, level 1'
+++++++++DataItem Name='Cell 1, row 3, rowgroup 1, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1
+++++++++++Text Name='Cell 1, row 3, rowgroup 1, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 1, rowgroup 1, level 2'
+++++++++DataItem Name='Cell 1, row 1, rowgroup 1, level 2' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1
+++++++++++Text Name='Cell 1, row 1, rowgroup 1, level 2' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 1, rowgroup 1, level 1'
+++++++++DataItem Name='Cell 1, row 1, rowgroup 1, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1
+++++++++++Text Name='Cell 1, row 1, rowgroup 1, level 1' IsControlElement=false
+++++Group
+++++++TreeItem Name='Cell 1, row 1, rowgroup 2, level 1 Cell 2, row 1, rowgroup 2, level 1'
+++++++++DataItem Name='Cell 1, row 1, rowgroup 2, level 1' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1
+++++++++++Text Name='Cell 1, row 1, rowgroup 2, level 1' IsControlElement=false
+++++++++DataItem Name='Cell 2, row 1, rowgroup 2, level 1' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1
+++++++++++Text Name='Cell 2, row 1, rowgroup 2, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 1, rowgroup 2, level 2 Cell 2, row 1, rowgroup 2, level 2 Cell 3, row 1, rowgroup 2, level 2'
+++++++++DataItem Name='Cell 1, row 1, rowgroup 2, level 2' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=6 GridItem.RowSpan=1
+++++++++++Text Name='Cell 1, row 1, rowgroup 2, level 2' IsControlElement=false
+++++++++DataItem Name='Cell 2, row 1, rowgroup 2, level 2' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=6 GridItem.RowSpan=1
+++++++++++Text Name='Cell 2, row 1, rowgroup 2, level 2' IsControlElement=false
+++++++++DataItem Name='Cell 3, row 1, rowgroup 2, level 2' GridItem.Column=2 GridItem.ColumnSpan=1 GridItem.Row=6 GridItem.RowSpan=1
+++++++++++Text Name='Cell 3, row 1, rowgroup 2, level 2' IsControlElement=false
+++DataGrid Grid.ColumnCount=0 Grid.RowCount=0 Selection.CanSelectMultiple=false Selection.IsSelectionRequired=false Table.RowOrColumnMajor='RowMajor'
+++++Group
+++++++TreeItem Name='Cell 1, row 1, rowgroup 1, level 1'
+++++++++Text Name='Cell 1, row 1, rowgroup 1, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 2, rowgroup 1, level 1'
+++++++++Text Name='Cell 1, row 2, rowgroup 1, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 3, rowgroup 1, level 1'
+++++++++Text Name='Cell 1, row 3, rowgroup 1, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 1, rowgroup 1, level 2'
+++++++++Text Name='Cell 1, row 1, rowgroup 1, level 2' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 1, rowgroup 1, level 1'
+++++++++Text Name='Cell 1, row 1, rowgroup 1, level 1' IsControlElement=false
+++++Group
+++++++TreeItem Name='Cell 1, row 1, rowgroup 2, level 1 Cell 2, row 1, rowgroup 2, level 1'
+++++++++Text Name='Cell 1, row 1, rowgroup 2, level 1 Cell 2, row 1, rowgroup 2, level 1' IsControlElement=false
+++++++TreeItem Name='Cell 1, row 1, rowgroup 2, level 2 Cell 2, row 1, rowgroup 2, level 2 Cell 3, row 1, rowgroup 2, level 2'
+++++++++Text Name='Cell 1, row 1, rowgroup 2, level 2 Cell 2, row 1, rowgroup 2, level 2 Cell 3, row 1, rowgroup 2, level 2' IsControlElement=false
\ No newline at end of file
diff --git a/content/test/data/accessibility/event/add-alert-content-expected-uia-win7.txt b/content/test/data/accessibility/event/add-alert-content-expected-uia-win7.txt
new file mode 100644
index 0000000000000..2aa360ca65d83
--- /dev/null
+++ b/content/test/data/accessibility/event/add-alert-content-expected-uia-win7.txt
@@ -0,0 +1,5 @@
+LiveRegionChanged on role=alert, name=Foo
+=== Start Continuation ===
+LiveRegionChanged on role=alert, name=Bar
+=== Start Continuation ===
+LiveRegionChanged on role=alert, name=Baz
diff --git a/content/test/data/accessibility/event/add-dialog-described-by-expected-uia-win7.txt b/content/test/data/accessibility/event/add-dialog-described-by-expected-uia-win7.txt
new file mode 100644
index 0000000000000..1486541735edf
--- /dev/null
+++ b/content/test/data/accessibility/event/add-dialog-described-by-expected-uia-win7.txt
@@ -0,0 +1,6 @@
+AriaProperties changed on role=dialog
+AriaProperties changed on role=heading, name=Described by dialog title
+AriaProperties changed on role=textbox
+IsDataValidForForm changed on role=textbox
+StructureChanged/ChildAdded on role=dialog
+StructureChanged/ChildrenReordered on role=document
diff --git a/content/test/data/accessibility/event/add-dialog-expected-uia-win7.txt b/content/test/data/accessibility/event/add-dialog-expected-uia-win7.txt
new file mode 100644
index 0000000000000..7905d6a385ea9
--- /dev/null
+++ b/content/test/data/accessibility/event/add-dialog-expected-uia-win7.txt
@@ -0,0 +1,6 @@
+AriaProperties changed on role=dialog, name=Dialog title
+AriaProperties changed on role=heading, name=Dialog title
+AriaProperties changed on role=textbox
+IsDataValidForForm changed on role=textbox
+StructureChanged/ChildAdded on role=dialog, name=Dialog title
+StructureChanged/ChildrenReordered on role=document
diff --git a/content/test/data/accessibility/event/add-dialog-no-info-expected-uia-win7.txt b/content/test/data/accessibility/event/add-dialog-no-info-expected-uia-win7.txt
new file mode 100644
index 0000000000000..6145419e3ad21
--- /dev/null
+++ b/content/test/data/accessibility/event/add-dialog-no-info-expected-uia-win7.txt
@@ -0,0 +1,6 @@
+AriaProperties changed on role=dialog
+AriaProperties changed on role=heading, name=Dialog title
+AriaProperties changed on role=textbox
+IsDataValidForForm changed on role=textbox
+StructureChanged/ChildAdded on role=dialog
+StructureChanged/ChildrenReordered on role=document
diff --git a/content/test/data/accessibility/event/aria-combo-box-collapse-expected-uia-win7.txt b/content/test/data/accessibility/event/aria-combo-box-collapse-expected-uia-win7.txt
new file mode 100644
index 0000000000000..3a5263041d7bb
--- /dev/null
+++ b/content/test/data/accessibility/event/aria-combo-box-collapse-expected-uia-win7.txt
@@ -0,0 +1,5 @@
+AriaProperties changed on role=combobox
+AutomationFocusChanged on role=combobox
+AutomationFocusChanged on role=combobox
+AutomationFocusChanged on role=option, name=Orange
+ExpandCollapseExpandCollapseState changed on role=combobox
diff --git a/content/test/data/accessibility/event/aria-flow-to-expected-uia-win7.txt b/content/test/data/accessibility/event/aria-flow-to-expected-uia-win7.txt
new file mode 100644
index 0000000000000..f8223695b8996
--- /dev/null
+++ b/content/test/data/accessibility/event/aria-flow-to-expected-uia-win7.txt
@@ -0,0 +1,11 @@
+FlowsTo changed on role=group, name=a1
+=== Start Continuation ===
+FlowsTo changed on role=group, name=c2
+=== Start Continuation ===
+FlowsTo changed on role=group, name=c3
+=== Start Continuation ===
+FlowsTo changed on role=group, name=a4
+=== Start Continuation ===
+FlowsTo changed on role=group, name=a5
+=== Start Continuation ===
+FlowsTo changed on role=group, name=a6
diff --git a/content/test/data/accessibility/event/aria-level-changed-expected-uia-win7.txt b/content/test/data/accessibility/event/aria-level-changed-expected-uia-win7.txt
new file mode 100644
index 0000000000000..073c1f8077c79
--- /dev/null
+++ b/content/test/data/accessibility/event/aria-level-changed-expected-uia-win7.txt
@@ -0,0 +1,3 @@
+AriaProperties changed on role=heading, name=Item2
+AriaProperties changed on role=heading, name=Item3
+AriaProperties changed on role=heading, name=Item4
diff --git a/content/test/data/accessibility/event/aria-live-changed-expected-uia-win7.txt b/content/test/data/accessibility/event/aria-live-changed-expected-uia-win7.txt
new file mode 100644
index 0000000000000..72df9b590ed1c
--- /dev/null
+++ b/content/test/data/accessibility/event/aria-live-changed-expected-uia-win7.txt
@@ -0,0 +1,4 @@
+AriaProperties changed on role=heading, name=Item2
+AriaProperties changed on role=heading, name=Item3
+AriaProperties changed on role=heading, name=Item4
+AriaProperties changed on role=heading, name=Item5
diff --git a/content/test/data/accessibility/event/aria-posinset-changed-expected-uia-win7.txt b/content/test/data/accessibility/event/aria-posinset-changed-expected-uia-win7.txt
new file mode 100644
index 0000000000000..8f1bdff40afbe
--- /dev/null
+++ b/content/test/data/accessibility/event/aria-posinset-changed-expected-uia-win7.txt
@@ -0,0 +1,2 @@
+AriaProperties changed on role=option, name=Li1
+AriaProperties changed on role=option, name=Li2
diff --git a/content/test/data/accessibility/event/aria-setsize-changed-expected-uia-win7.txt b/content/test/data/accessibility/event/aria-setsize-changed-expected-uia-win7.txt
new file mode 100644
index 0000000000000..687744806258f
--- /dev/null
+++ b/content/test/data/accessibility/event/aria-setsize-changed-expected-uia-win7.txt
@@ -0,0 +1,3 @@
+AriaProperties changed on role=option, name=Li1
+AriaProperties changed on role=option, name=Li2
+AriaProperties changed on role=option, name=Li3
diff --git a/content/test/data/accessibility/event/description-change-expected-uia-win7.txt b/content/test/data/accessibility/event/description-change-expected-uia-win7.txt
new file mode 100644
index 0000000000000..e69de29bb2d1d
diff --git a/content/test/data/accessibility/event/description-change-indirect-expected-uia-win7.txt b/content/test/data/accessibility/event/description-change-indirect-expected-uia-win7.txt
new file mode 100644
index 0000000000000..22b973d7a37ec
--- /dev/null
+++ b/content/test/data/accessibility/event/description-change-indirect-expected-uia-win7.txt
@@ -0,0 +1,4 @@
+Name changed on role=heading, name=oranges
+StructureChanged/ChildAdded on role=heading, name=oranges
+StructureChanged/ChildRemoved on role=heading, name=oranges
+StructureChanged/ChildrenReordered on role=heading, name=oranges
diff --git a/content/test/data/accessibility/event/live-region-add-expected-uia-win7.txt b/content/test/data/accessibility/event/live-region-add-expected-uia-win7.txt
new file mode 100644
index 0000000000000..fe8f43462d689
--- /dev/null
+++ b/content/test/data/accessibility/event/live-region-add-expected-uia-win7.txt
@@ -0,0 +1,4 @@
+LiveRegionChanged on role=group
+StructureChanged/ChildAdded on role=group
+StructureChanged/ChildrenReordered on role=group
+Text_TextChanged on role=document
diff --git a/content/test/data/accessibility/event/live-region-add-live-attribute-expected-uia-win7.txt b/content/test/data/accessibility/event/live-region-add-live-attribute-expected-uia-win7.txt
new file mode 100644
index 0000000000000..20d199f70247e
--- /dev/null
+++ b/content/test/data/accessibility/event/live-region-add-live-attribute-expected-uia-win7.txt
@@ -0,0 +1,2 @@
+AriaProperties changed on role=group
+LiveRegionChanged on role=group
diff --git a/content/test/data/accessibility/event/live-region-change-expected-uia-win7.txt b/content/test/data/accessibility/event/live-region-change-expected-uia-win7.txt
new file mode 100644
index 0000000000000..d377859b7d3a4
--- /dev/null
+++ b/content/test/data/accessibility/event/live-region-change-expected-uia-win7.txt
@@ -0,0 +1,2 @@
+LiveRegionChanged on role=group
+Text_TextChanged on role=description, name=After
diff --git a/content/test/data/accessibility/event/menubar-show-hide-menus-expected-uia-win7.txt b/content/test/data/accessibility/event/menubar-show-hide-menus-expected-uia-win7.txt
new file mode 100644
index 0000000000000..ccaf8feabdff8
--- /dev/null
+++ b/content/test/data/accessibility/event/menubar-show-hide-menus-expected-uia-win7.txt
@@ -0,0 +1,32 @@
+ExpandCollapseExpandCollapseState changed on role=menuitem, name=File
+ExpandCollapseExpandCollapseState changed on role=menuitem, name=New
+MenuOpened on role=menu, name=File
+MenuOpened on role=menu, name=New
+MenuOpened on role=region
+MenuOpened on role=region
+Name changed on role=group, name=open file and new done
+=== Start Continuation ===
+ExpandCollapseExpandCollapseState changed on role=menuitem, name=File
+MenuClosed 
+MenuClosed 
+MenuClosed 
+MenuClosed 
+Name changed on role=group, name=close file and new done
+=== Start Continuation ===
+Name changed on role=group, name=open new done
+=== Start Continuation ===
+ExpandCollapseExpandCollapseState changed on role=menuitem, name=File
+ExpandCollapseExpandCollapseState changed on role=menuitem, name=New
+MenuOpened on role=menu, name=File
+MenuOpened on role=menu, name=New
+MenuOpened on role=region
+MenuOpened on role=region
+Name changed on role=group, name=open file done
+=== Start Continuation ===
+MenuClosed 
+MenuClosed 
+MenuClosed 
+MenuClosed 
+Name changed on role=group, name=hide menubar done
+=== Start Continuation ===
+Name changed on role=group, name=show menubar done
diff --git a/content/test/data/accessibility/event/menulist-collapse-expected-uia-win7.txt b/content/test/data/accessibility/event/menulist-collapse-expected-uia-win7.txt
new file mode 100644
index 0000000000000..ff95e032bfa7d
--- /dev/null
+++ b/content/test/data/accessibility/event/menulist-collapse-expected-uia-win7.txt
@@ -0,0 +1,8 @@
+#<skip -- crbug.com/1083492>
+AutomationFocusChanged on role=combobox
+AutomationFocusChanged on role=combobox
+=== Start Continuation ===
+AriaProperties changed on role=combobox
+SelectionItemIsSelected changed on role=combobox
+SelectionItem_ElementRemovedFromSelection on role=combobox
+ValueValue changed on role=combobox
diff --git a/content/test/data/accessibility/event/menulist-collapse-next-expected-uia-win7.txt b/content/test/data/accessibility/event/menulist-collapse-next-expected-uia-win7.txt
new file mode 100644
index 0000000000000..9280d2ab0b398
--- /dev/null
+++ b/content/test/data/accessibility/event/menulist-collapse-next-expected-uia-win7.txt
@@ -0,0 +1,11 @@
+#<skip -- crbug.com/1083492>
+AutomationFocusChanged on role=combobox
+AutomationFocusChanged on role=combobox
+=== Start Continuation ===
+AriaProperties changed on role=combobox
+AriaProperties changed on role=listitem, name=Orange
+AutomationFocusChanged on role=combobox
+SelectionItemIsSelected changed on role=combobox
+SelectionItemIsSelected changed on role=listitem, name=Orange
+SelectionItem_ElementSelected on role=listitem, name=Orange
+ValueValue changed on role=combobox
diff --git a/content/test/data/accessibility/event/visibility-hidden-changed-expected-uia-win7.txt b/content/test/data/accessibility/event/visibility-hidden-changed-expected-uia-win7.txt
new file mode 100644
index 0000000000000..c6206d660b02c
--- /dev/null
+++ b/content/test/data/accessibility/event/visibility-hidden-changed-expected-uia-win7.txt
@@ -0,0 +1,3 @@
+AriaProperties changed on role=document
+AriaProperties changed on role=heading, name=Item2
+AriaProperties changed on role=heading, name=Item4
diff --git a/content/test/data/accessibility/html/a-name-calc-expected-uia-win7.txt b/content/test/data/accessibility/html/a-name-calc-expected-uia-win7.txt
new file mode 100644
index 0000000000000..73728b2c0d3e3
--- /dev/null
+++ b/content/test/data/accessibility/html/a-name-calc-expected-uia-win7.txt
@@ -0,0 +1,15 @@
+Document
+++Hyperlink Name='InnerText0'
+++++Text Name='InnerText0' IsControlElement=false
+++Text Name=' '
+++Hyperlink Name='InnerText1'
+++++Text Name='InnerText1' IsControlElement=false
+++Text Name=' '
+++Hyperlink Name='Title2'
+++++Text Name='InnerText2' IsControlElement=false
+++Text Name=' '
+++Hyperlink Name='LabelledBy3'
+++++Text Name='InnerText3' IsControlElement=false
+++Hyperlink Name='Title4'
+++Hyperlink Name='Label5'
+++Hyperlink Name='LabelledBy6'
diff --git a/content/test/data/accessibility/html/button-name-calc-expected-uia-win7.txt b/content/test/data/accessibility/html/button-name-calc-expected-uia-win7.txt
new file mode 100644
index 0000000000000..479732d442209
--- /dev/null
+++ b/content/test/data/accessibility/html/button-name-calc-expected-uia-win7.txt
@@ -0,0 +1,20 @@
+Document
+++Button Name='InnerText0'
+++Button Name='InnerText1'
+++Button Name='AriaLabel2'
+++Button Name='LabelledBy3'
+++Button Name='LabelledBy4'
+++Button Name='InnerText5'
+++Button Name='Outer inner'
+++++Text Name='Outer' IsControlElement=false
+++++Group IsControlElement=false
+++++++Text Name='inner' IsControlElement=false
+++Button Name='Outer inner1'
+++++Text Name='Outer' IsControlElement=false
+++++Group Name='inner1'
+++++++Text Name='inner2' IsControlElement=false
+++Button Name='Outer grandchild'
+++++Text Name='Outer' IsControlElement=false
+++++Group
+++++++Group IsControlElement=false
+++++++++Text Name='grandchild' IsControlElement=false
diff --git a/content/test/data/accessibility/html/footer-expected-uia-win7.txt b/content/test/data/accessibility/html/footer-expected-uia-win7.txt
new file mode 100644
index 0000000000000..0aedab951f7d5
--- /dev/null
+++ b/content/test/data/accessibility/html/footer-expected-uia-win7.txt
@@ -0,0 +1,3 @@
+Document
+++Group LocalizedControlType='footer'
+++++Text Name='Footer element'
diff --git a/content/test/data/accessibility/html/input-date-with-popup-open-expected-uia-win7.txt b/content/test/data/accessibility/html/input-date-with-popup-open-expected-uia-win7.txt
new file mode 100644
index 0000000000000..45ab7324b0529
--- /dev/null
+++ b/content/test/data/accessibility/html/input-date-with-popup-open-expected-uia-win7.txt
@@ -0,0 +1,134 @@
+Document
+++Group IsControlElement=false
+++++Edit LocalizedControlType='date picker' ControllerFor='{document}' Value.Value='2008-09-01'
+++++++Group IsControlElement=false
+++++++++Group IsControlElement=false
+++++++++++Spinner Name='Month' RangeValue.IsReadOnly=false RangeValue.LargeChange=0.00 RangeValue.SmallChange=0.00 RangeValue.Maximum=12.00 RangeValue.Minimum=1.00 RangeValue.Value=9.00 Value.Value='09'
+++++++++++Text Name='/'
+++++++++++Spinner Name='Day' RangeValue.IsReadOnly=false RangeValue.LargeChange=0.00 RangeValue.SmallChange=0.00 RangeValue.Maximum=31.00 RangeValue.Minimum=1.00 RangeValue.Value=1.00 Value.Value='01'
+++++++++++Text Name='/'
+++++++++++Spinner Name='Year' RangeValue.IsReadOnly=false RangeValue.LargeChange=0.00 RangeValue.SmallChange=0.00 RangeValue.Maximum=275760.00 RangeValue.Minimum=1.00 RangeValue.Value=2008.00 Value.Value='2008'
+++++++Button Name='Show date picker' ExpandCollapse.ExpandCollapseState='Collapsed'
+++++++Pane Name='Chrome Legacy Window' IsControlElement=false
+++++++++Document
+++++++++++Group
+++++++++++++Group IsControlElement=false
+++++++++++++++Group IsControlElement=false
+++++++++++++++++Group IsControlElement=false
+++++++++++++++++++Button Name='Show month selection panel'
+++++++++++++++++++++Text Name='September, 2008' IsControlElement=false
+++++++++++++++++++++Image
+++++++++++++++++Button Name='Show previous month'
+++++++++++++++++++Image
+++++++++++++++++Button Name='Show next month'
+++++++++++++++++++Image
+++++++++++++++++DataGrid Grid.ColumnCount=7 Grid.RowCount=6 Selection.CanSelectMultiple=false Selection.IsSelectionRequired=false Table.RowOrColumnMajor='RowMajor'
+++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++Text Name='Su'
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++Text Name='Mo'
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++Text Name='Tu'
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++Text Name='We'
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++Text Name='Th'
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++Text Name='Fr'
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++Text Name='Sa'
+++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++Group IsControlElement=false
+++++++++++++++++++++++DataItem
+++++++++++++++++++++++++DataItem Name='Sunday, August 31, 2008' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='31' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Monday, September 1, 2008' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1 SelectionItem.IsSelected=true
+++++++++++++++++++++++++++Text Name='1' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Tuesday, September 2, 2008' GridItem.Column=2 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='2' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Wednesday, September 3, 2008' GridItem.Column=3 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='3' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Thursday, September 4, 2008' GridItem.Column=4 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='4' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Friday, September 5, 2008' GridItem.Column=5 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='5' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Saturday, September 6, 2008' GridItem.Column=6 GridItem.ColumnSpan=1 GridItem.Row=0 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='6' IsControlElement=false
+++++++++++++++++++++++DataItem
+++++++++++++++++++++++++DataItem Name='Sunday, September 7, 2008' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='7' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Monday, September 8, 2008' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='8' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Tuesday, September 9, 2008' GridItem.Column=2 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='9' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Wednesday, September 10, 2008' GridItem.Column=3 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='10' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Thursday, September 11, 2008' GridItem.Column=4 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='11' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Friday, September 12, 2008' GridItem.Column=5 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='12' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Saturday, September 13, 2008' GridItem.Column=6 GridItem.ColumnSpan=1 GridItem.Row=1 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='13' IsControlElement=false
+++++++++++++++++++++++DataItem
+++++++++++++++++++++++++DataItem Name='Sunday, September 14, 2008' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='14' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Monday, September 15, 2008' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='15' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Tuesday, September 16, 2008' GridItem.Column=2 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='16' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Wednesday, September 17, 2008' GridItem.Column=3 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='17' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Thursday, September 18, 2008' GridItem.Column=4 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='18' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Friday, September 19, 2008' GridItem.Column=5 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='19' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Saturday, September 20, 2008' GridItem.Column=6 GridItem.ColumnSpan=1 GridItem.Row=2 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='20' IsControlElement=false
+++++++++++++++++++++++DataItem
+++++++++++++++++++++++++DataItem Name='Sunday, September 21, 2008' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='21' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Monday, September 22, 2008' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='22' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Tuesday, September 23, 2008' GridItem.Column=2 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='23' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Wednesday, September 24, 2008' GridItem.Column=3 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='24' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Thursday, September 25, 2008' GridItem.Column=4 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='25' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Friday, September 26, 2008' GridItem.Column=5 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='26' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Saturday, September 27, 2008' GridItem.Column=6 GridItem.ColumnSpan=1 GridItem.Row=3 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='27' IsControlElement=false
+++++++++++++++++++++++DataItem
+++++++++++++++++++++++++DataItem Name='Sunday, September 28, 2008' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='28' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Monday, September 29, 2008' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='29' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Tuesday, September 30, 2008' GridItem.Column=2 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='30' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Wednesday, October 1, 2008' GridItem.Column=3 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='1' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Thursday, October 2, 2008' GridItem.Column=4 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='2' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Friday, October 3, 2008' GridItem.Column=5 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='3' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Saturday, October 4, 2008' GridItem.Column=6 GridItem.ColumnSpan=1 GridItem.Row=4 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='4' IsControlElement=false
+++++++++++++++++++++++DataItem
+++++++++++++++++++++++++DataItem Name='Sunday, October 5, 2008' GridItem.Column=0 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='5' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Monday, October 6, 2008' GridItem.Column=1 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='6' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Tuesday, October 7, 2008' GridItem.Column=2 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='7' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Wednesday, October 8, 2008' GridItem.Column=3 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='8' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Thursday, October 9, 2008' GridItem.Column=4 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='9' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Friday, October 10, 2008' GridItem.Column=5 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='10' IsControlElement=false
+++++++++++++++++++++++++DataItem Name='Saturday, October 11, 2008' GridItem.Column=6 GridItem.ColumnSpan=1 GridItem.Row=5 GridItem.RowSpan=1 SelectionItem.IsSelected=false
+++++++++++++++++++++++++++Text Name='11' IsControlElement=false
+++++++++++++++++++Button Name='Clear'
+++++++++++++++++++Button Name='Today'
\ No newline at end of file
diff --git a/content/test/data/accessibility/html/list-item-aria-setsize-unknown-expected-uia-win7.txt b/content/test/data/accessibility/html/list-item-aria-setsize-unknown-expected-uia-win7.txt
new file mode 100644
index 0000000000000..7b8a943b7de38
--- /dev/null
+++ b/content/test/data/accessibility/html/list-item-aria-setsize-unknown-expected-uia-win7.txt
@@ -0,0 +1,15 @@
+Document
+++List
+++++ListItem Name='Level 1, item 5 of set size unknown'
+++++++Text Name='Level 1, item 5 of set size unknown'
+++++ListItem Name='Level 1, item 6 of set size unknown'
+++++++Text Name='Level 1, item 6 of set size unknown'
+++++++List
+++++++++ListItem Name='Level 2, item 6 of set size unknown'
+++++++++++Text Name='Level 2, item 6 of set size unknown'
+++++++++ListItem Name='Level 2, item 7 of set size unknown'
+++++++++++Text Name='Level 2, item 7 of set size unknown'
+++++ListItem Name='Level 1, item 7 of set size 2'
+++++++Text Name='Level 1, item 7 of set size 2'
+++++ListItem Name='Level 1, item 8 of set size 3'
+++++++Text Name='Level 1, item 8 of set size 3'
diff --git a/content/test/data/accessibility/html/list-item-aria-setsize-unknown-flattened-expected-uia-win7.txt b/content/test/data/accessibility/html/list-item-aria-setsize-unknown-flattened-expected-uia-win7.txt
new file mode 100644
index 0000000000000..a5f0fa75fb12b
--- /dev/null
+++ b/content/test/data/accessibility/html/list-item-aria-setsize-unknown-flattened-expected-uia-win7.txt
@@ -0,0 +1,32 @@
+Document
+++List
+++++ListItem Name='Level 1, item 1 of set size unknown'
+++++++Text Name='Level 1, item 1 of set size unknown'
+++List
+++++ListItem Name='++Level 2, item 1 of set size unknown'
+++++++Text Name='++Level 2, item 1 of set size unknown'
+++List
+++++ListItem Name='++Level 2, item 2 of set size unknown'
+++++++Text Name='++Level 2, item 2 of set size unknown'
+++List
+++++ListItem Name='++Level 2, item 3 of set size unknown'
+++++++Text Name='++Level 2, item 3 of set size unknown'
+++List
+++++ListItem Name='++++Level 3, item 1 of set size unknown'
+++++++Text Name='++++Level 3, item 1 of set size unknown'
+++List
+++++ListItem Name='++++Level 3, item 2 of set size unknown'
+++++++Text Name='++++Level 3, item 2 of set size unknown'
+++List
+++++ListItem Name='Level 1, item 2 of set size unknown'
+++++++Text Name='Level 1, item 2 of set size unknown'
+++List
+++++ListItem Name='Level 1, item 3 of set size unknown'
+++++++Text Name='Level 1, item 3 of set size unknown'
+++List
+++++List
+++++++ListItem Name='Level Unspecified, aria-setsize attribute does not exist, item 4 of set size 4'
+++++++++Text Name='Level Unspecified, aria-setsize attribute does not exist, item 4 of set size 4'
+++++List
+++++++ListItem Name='Level Unspecified, aria-setsize attribute does not exist, item 5 of set size 5'
+++++++++Text Name='Level Unspecified, aria-setsize attribute does not exist, item 5 of set size 5'
diff --git a/content/test/data/accessibility/html/output-expected-uia-win7.txt b/content/test/data/accessibility/html/output-expected-uia-win7.txt
new file mode 100644
index 0000000000000..84b0aaf9bc3ba
--- /dev/null
+++ b/content/test/data/accessibility/html/output-expected-uia-win7.txt
@@ -0,0 +1,7 @@
+Document LocalizedControlType='document'
+++Group LocalizedControlType='group'
+++++Spinner LocalizedControlType='spinner' RangeValue.IsReadOnly=false RangeValue.LargeChange=10.00 RangeValue.SmallChange=1.00 RangeValue.Maximum=0.00 RangeValue.Minimum=0.00 RangeValue.Value=0.00
+++++Text LocalizedControlType='text' Name=' + '
+++++Spinner LocalizedControlType='spinner' RangeValue.IsReadOnly=false RangeValue.LargeChange=10.00 RangeValue.SmallChange=1.00 RangeValue.Maximum=0.00 RangeValue.Minimum=0.00 RangeValue.Value=0.00
+++++Text LocalizedControlType='text' Name=' ='
+++++StatusBar LocalizedControlType='status bar' IsControlElement=false
\ No newline at end of file
diff --git a/content/test/dwrite_font_fake_sender_win.cc b/content/test/dwrite_font_fake_sender_win.cc
index efc265e7415ca..8c13485aab80d 100644
--- a/content/test/dwrite_font_fake_sender_win.cc
+++ b/content/test/dwrite_font_fake_sender_win.cc
@@ -139,6 +139,15 @@ void FakeFontCollection::MapCharacters(
 void FakeFontCollection::MatchUniqueFont(const std::u16string& unique_font_name,
                                          MatchUniqueFontCallback callback) {}
 
+void FakeFontCollection::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {}
+
+void FakeFontCollection::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {}
+
+void FakeFontCollection::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {}
+
 void FakeFontCollection::FallbackFamilyAndStyleForCodepoint(
     const std::string& base_family_name,
     const std::string& locale_name,
diff --git a/content/test/dwrite_font_fake_sender_win.h b/content/test/dwrite_font_fake_sender_win.h
index 5f6d2774566e2..fae569ee748e8 100644
--- a/content/test/dwrite_font_fake_sender_win.h
+++ b/content/test/dwrite_font_fake_sender_win.h
@@ -125,6 +125,12 @@ class FakeFontCollection : public blink::mojom::DWriteFontProxy {
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
   void FallbackFamilyAndStyleForCodepoint(
       const std::string& base_family_name,
       const std::string& locale_name,
diff --git a/device/bluetooth/bluetooth_adapter_factory.cc b/device/bluetooth/bluetooth_adapter_factory.cc
index 4b76da7907493..bab3f3bcfcd22 100644
--- a/device/bluetooth/bluetooth_adapter_factory.cc
+++ b/device/bluetooth/bluetooth_adapter_factory.cc
@@ -4,7 +4,6 @@
 
 #include "device/bluetooth/bluetooth_adapter_factory.h"
 
-#include <memory>
 #include <utility>
 #include <vector>
 
@@ -21,6 +20,7 @@
 #include "base/mac/mac_util.h"
 #endif
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "device/bluetooth/bluetooth_adapter_win.h"
 #endif
 
@@ -56,8 +56,13 @@ bool BluetoothAdapterFactory::IsLowEnergySupported() {
   }
 
 #if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_LINUX) || \
-    BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)
+    BUILDFLAG(IS_MAC)
   return true;
+#elif BUILDFLAG(IS_WIN)
+  // Windows 8 supports Low Energy GATT operations but it does not support
+  // scanning, initiating connections and GATT Server. To keep the API
+  // consistent we consider Windows 8 as lacking Low Energy support.
+  return base::win::GetVersion() >= base::win::Version::WIN10;
 #else
   return false;
 #endif
@@ -88,6 +93,12 @@ void BluetoothAdapterFactory::GetClassicAdapter(AdapterCallback callback) {
 #if BUILDFLAG(IS_WIN)
   DCHECK(IsBluetoothSupported());
 
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    // Prior to Win10, the default adapter will support Bluetooth classic.
+    GetAdapter(std::move(callback));
+    return;
+  }
+
   if (!classic_adapter_) {
     classic_adapter_callbacks_.push_back(std::move(callback));
 
diff --git a/device/bluetooth/bluetooth_adapter_win.cc b/device/bluetooth/bluetooth_adapter_win.cc
index 31ceac0c0dec5..81e43b9e05ca8 100644
--- a/device/bluetooth/bluetooth_adapter_win.cc
+++ b/device/bluetooth/bluetooth_adapter_win.cc
@@ -17,6 +17,7 @@
 #include "base/stl_util.h"
 #include "base/task/sequenced_task_runner.h"
 #include "base/task/single_thread_task_runner.h"
+#include "base/win/windows_version.h"
 #include "device/base/features.h"
 #include "device/bluetooth/bluetooth_adapter_winrt.h"
 #include "device/bluetooth/bluetooth_classic_win.h"
@@ -50,10 +51,16 @@ scoped_refptr<BluetoothAdapter> BluetoothAdapterWin::CreateClassicAdapter() {
 
 // static
 bool BluetoothAdapterWin::UseNewBLEWinImplementation() {
-  return base::FeatureList::IsEnabled(kNewBLEWinImplementation);
+  return base::FeatureList::IsEnabled(kNewBLEWinImplementation) &&
+         base::win::GetVersion() >= base::win::Version::WIN10;
 }
 
-BluetoothAdapterWin::BluetoothAdapterWin() = default;
+BluetoothAdapterWin::BluetoothAdapterWin()
+    : BluetoothAdapter(),
+      initialized_(false),
+      powered_(false),
+      discovery_status_(NOT_DISCOVERING),
+      force_update_device_for_test_(false) {}
 
 BluetoothAdapterWin::~BluetoothAdapterWin() {
   if (task_manager_.get())
diff --git a/device/bluetooth/bluetooth_adapter_win.h b/device/bluetooth/bluetooth_adapter_win.h
index 491a001a41201..ea5c8c2e8d469 100644
--- a/device/bluetooth/bluetooth_adapter_win.h
+++ b/device/bluetooth/bluetooth_adapter_win.h
@@ -138,9 +138,9 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothAdapterWin
   base::OnceClosure init_callback_;
   std::string address_;
   std::string name_;
-  bool initialized_ = false;
-  bool powered_ = false;
-  DiscoveryStatus discovery_status_ = NOT_DISCOVERING;
+  bool initialized_;
+  bool powered_;
+  DiscoveryStatus discovery_status_;
   std::unordered_set<std::string> discovered_devices_;
 
   DiscoverySessionResultCallback discovery_changed_callback_;
@@ -151,7 +151,7 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothAdapterWin
   base::ThreadChecker thread_checker_;
 
   // Flag indicating a device update must be forced in DevicesPolled.
-  bool force_update_device_for_test_ = false;
+  bool force_update_device_for_test_;
 
   // NOTE: This should remain the last member so it'll be destroyed and
   // invalidate its weak pointers before any other members are destroyed.
diff --git a/device/bluetooth/bluetooth_low_energy_win.cc b/device/bluetooth/bluetooth_low_energy_win.cc
index fb640e4e46bea..7a54a2283f705 100644
--- a/device/bluetooth/bluetooth_low_energy_win.cc
+++ b/device/bluetooth/bluetooth_low_energy_win.cc
@@ -5,7 +5,6 @@
 #include "device/bluetooth/bluetooth_low_energy_win.h"
 
 #include <memory>
-#include <string>
 #include <utility>
 
 #include "base/files/file.h"
@@ -15,6 +14,7 @@
 #include "base/strings/string_util.h"
 #include "base/strings/sys_string_conversions.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "third_party/re2/src/re2/re2.h"
 
 namespace {
@@ -24,6 +24,8 @@ using device::win::DevicePropertyValue;
 using device::win::BluetoothLowEnergyDeviceInfo;
 using device::win::BluetoothLowEnergyServiceInfo;
 
+const char kPlatformNotSupported[] =
+    "Bluetooth Low energy is only supported on Windows 8 and later.";
 const char kDeviceEnumError[] = "Error enumerating Bluetooth LE devices.";
 const char kDeviceInfoError[] =
     "Error retrieving Bluetooth LE device information.";
@@ -617,7 +619,8 @@ DevicePropertyValue::DevicePropertyValue(DEVPROPTYPE property_type,
       value_(std::move(value)),
       value_size_(value_size) {}
 
-DevicePropertyValue::~DevicePropertyValue() = default;
+DevicePropertyValue::~DevicePropertyValue() {
+}
 
 uint32_t DevicePropertyValue::AsUint32() const {
   CHECK_EQ(property_type_, static_cast<DEVPROPTYPE>(DEVPROP_TYPE_UINT32));
@@ -625,11 +628,14 @@ uint32_t DevicePropertyValue::AsUint32() const {
   return *reinterpret_cast<uint32_t*>(value_.get());
 }
 
-BluetoothLowEnergyServiceInfo::BluetoothLowEnergyServiceInfo() = default;
+BluetoothLowEnergyServiceInfo::BluetoothLowEnergyServiceInfo() {
+}
 
-BluetoothLowEnergyServiceInfo::~BluetoothLowEnergyServiceInfo() = default;
+BluetoothLowEnergyServiceInfo::~BluetoothLowEnergyServiceInfo() {
+}
 
-BluetoothLowEnergyDeviceInfo::BluetoothLowEnergyDeviceInfo() {
+BluetoothLowEnergyDeviceInfo::BluetoothLowEnergyDeviceInfo()
+    : visible(false), authenticated(false), connected(false) {
   address.ullLong = BLUETOOTH_NULL_ADDRESS;
 }
 
@@ -643,12 +649,21 @@ bool ExtractBluetoothAddressFromDeviceInstanceIdForTesting(
   return ExtractBluetoothAddressFromDeviceInstanceId(instance_id, btha, error);
 }
 
-BluetoothLowEnergyWrapper::BluetoothLowEnergyWrapper() = default;
-BluetoothLowEnergyWrapper::~BluetoothLowEnergyWrapper() = default;
+BluetoothLowEnergyWrapper::BluetoothLowEnergyWrapper() {}
+BluetoothLowEnergyWrapper::~BluetoothLowEnergyWrapper() {}
+
+bool BluetoothLowEnergyWrapper::IsBluetoothLowEnergySupported() {
+  return base::win::GetVersion() >= base::win::Version::WIN8;
+}
 
 bool BluetoothLowEnergyWrapper::EnumerateKnownBluetoothLowEnergyDevices(
     std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
     std::string* error) {
+  if (!IsBluetoothLowEnergySupported()) {
+    *error = kPlatformNotSupported;
+    return false;
+  }
+
   return EnumerateKnownBLEOrBLEGattServiceDevices(
       GUID_BLUETOOTHLE_DEVICE_INTERFACE, devices, error);
 }
@@ -657,6 +672,11 @@ bool BluetoothLowEnergyWrapper::
     EnumerateKnownBluetoothLowEnergyGattServiceDevices(
         std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
         std::string* error) {
+  if (!IsBluetoothLowEnergySupported()) {
+    *error = kPlatformNotSupported;
+    return false;
+  }
+
   return EnumerateKnownBLEOrBLEGattServiceDevices(
       GUID_BLUETOOTH_GATT_SERVICE_DEVICE_INTERFACE, devices, error);
 }
@@ -665,6 +685,11 @@ bool BluetoothLowEnergyWrapper::EnumerateKnownBluetoothLowEnergyServices(
     const base::FilePath& device_path,
     std::vector<std::unique_ptr<BluetoothLowEnergyServiceInfo>>* services,
     std::string* error) {
+  if (!IsBluetoothLowEnergySupported()) {
+    *error = kPlatformNotSupported;
+    return false;
+  }
+
   return CollectBluetoothLowEnergyDeviceServices(device_path, services, error);
 }
 
diff --git a/device/bluetooth/bluetooth_low_energy_win.h b/device/bluetooth/bluetooth_low_energy_win.h
index f9280a683feb1..74d9449ee4e27 100644
--- a/device/bluetooth/bluetooth_low_energy_win.h
+++ b/device/bluetooth/bluetooth_low_energy_win.h
@@ -110,9 +110,9 @@ struct DEVICE_BLUETOOTH_EXPORT BluetoothLowEnergyDeviceInfo {
   std::string id;
   absl::optional<std::string> friendly_name;
   BLUETOOTH_ADDRESS address;
-  bool visible = false;
-  bool authenticated = false;
-  bool connected = false;
+  bool visible;
+  bool authenticated;
+  bool connected;
 };
 
 bool DEVICE_BLUETOOTH_EXPORT
@@ -128,6 +128,9 @@ class DEVICE_BLUETOOTH_EXPORT BluetoothLowEnergyWrapper {
   BluetoothLowEnergyWrapper();
   virtual ~BluetoothLowEnergyWrapper();
 
+  // Returns true only on Windows platforms supporting Bluetooth Low Energy.
+  virtual bool IsBluetoothLowEnergySupported();
+
   // Enumerates the list of known (i.e. already paired) Bluetooth LE devices on
   // this machine. In case of error, returns false and sets |error| with an
   // error message describing the problem.
diff --git a/device/bluetooth/bluetooth_low_energy_win_fake.cc b/device/bluetooth/bluetooth_low_energy_win_fake.cc
index 1ebdf3039f152..b3b50e52658ed 100644
--- a/device/bluetooth/bluetooth_low_energy_win_fake.cc
+++ b/device/bluetooth/bluetooth_low_energy_win_fake.cc
@@ -5,15 +5,18 @@
 #include "device/bluetooth/bluetooth_low_energy_win_fake.h"
 
 #include <memory>
-#include <string>
-#include <utility>
-#include <vector>
 
 #include "base/memory/ptr_util.h"
 #include "base/strings/stringprintf.h"
 #include "device/bluetooth/bluetooth_low_energy_defs_win.h"
 
-namespace device::win {
+namespace {
+const char kPlatformNotSupported[] =
+    "Bluetooth Low energy is only supported on Windows 8 and later.";
+}  // namespace
+
+namespace device {
+namespace win {
 
 BLEDevice::BLEDevice() {}
 BLEDevice::~BLEDevice() {}
@@ -34,9 +37,18 @@ BluetoothLowEnergyWrapperFake::BluetoothLowEnergyWrapperFake()
     : observer_(nullptr) {}
 BluetoothLowEnergyWrapperFake::~BluetoothLowEnergyWrapperFake() {}
 
+bool BluetoothLowEnergyWrapperFake::IsBluetoothLowEnergySupported() {
+  return true;
+}
+
 bool BluetoothLowEnergyWrapperFake::EnumerateKnownBluetoothLowEnergyDevices(
     std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
     std::string* error) {
+  if (!IsBluetoothLowEnergySupported()) {
+    *error = kPlatformNotSupported;
+    return false;
+  }
+
   for (auto& device : simulated_devices_) {
     if (device.second->marked_as_deleted)
       continue;
@@ -51,6 +63,11 @@ bool BluetoothLowEnergyWrapperFake::
     EnumerateKnownBluetoothLowEnergyGattServiceDevices(
         std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
         std::string* error) {
+  if (!IsBluetoothLowEnergySupported()) {
+    *error = kPlatformNotSupported;
+    return false;
+  }
+
   for (auto& device : simulated_devices_) {
     for (auto& service : device.second->primary_services) {
       auto device_info = std::make_unique<BluetoothLowEnergyDeviceInfo>();
@@ -69,6 +86,11 @@ bool BluetoothLowEnergyWrapperFake::EnumerateKnownBluetoothLowEnergyServices(
     const base::FilePath& device_path,
     std::vector<std::unique_ptr<BluetoothLowEnergyServiceInfo>>* services,
     std::string* error) {
+  if (!IsBluetoothLowEnergySupported()) {
+    *error = kPlatformNotSupported;
+    return false;
+  }
+
   std::wstring device_address =
       ExtractDeviceAddressFromDevicePath(device_path.value());
   std::vector<std::string> service_attribute_handles =
@@ -622,4 +644,5 @@ std::string BluetoothLowEnergyWrapperFake::BluetoothAddressToCanonicalString(
   return result;
 }
 
-}  // namespace device::win
+}  // namespace win
+}  // namespace device
diff --git a/device/bluetooth/bluetooth_low_energy_win_fake.h b/device/bluetooth/bluetooth_low_energy_win_fake.h
index 072fa7abaeea6..ec515e552ea12 100644
--- a/device/bluetooth/bluetooth_low_energy_win_fake.h
+++ b/device/bluetooth/bluetooth_low_energy_win_fake.h
@@ -103,6 +103,7 @@ class BluetoothLowEnergyWrapperFake : public BluetoothLowEnergyWrapper {
   BluetoothLowEnergyWrapperFake();
   ~BluetoothLowEnergyWrapperFake() override;
 
+  bool IsBluetoothLowEnergySupported() override;
   bool EnumerateKnownBluetoothLowEnergyDevices(
       std::vector<std::unique_ptr<BluetoothLowEnergyDeviceInfo>>* devices,
       std::string* error) override;
diff --git a/device/bluetooth/bluetooth_task_manager_win.cc b/device/bluetooth/bluetooth_task_manager_win.cc
index 6a1e32747b6c6..f4357621a146a 100644
--- a/device/bluetooth/bluetooth_task_manager_win.cc
+++ b/device/bluetooth/bluetooth_task_manager_win.cc
@@ -562,6 +562,10 @@ bool BluetoothTaskManagerWin::SearchClassicDevices(
 
 bool BluetoothTaskManagerWin::SearchLowEnergyDevices(
     std::vector<std::unique_ptr<DeviceState>>* device_list) {
+  if (!le_wrapper_->IsBluetoothLowEnergySupported()) {
+    return true;  // Bluetooth LE not supported is not an error.
+  }
+
   std::vector<std::unique_ptr<win::BluetoothLowEnergyDeviceInfo>> btle_devices;
   std::string error;
   bool success = le_wrapper_->EnumerateKnownBluetoothLowEnergyDevices(
@@ -718,6 +722,10 @@ int BluetoothTaskManagerWin::DiscoverClassicDeviceServicesWorker(
 bool BluetoothTaskManagerWin::DiscoverLowEnergyDeviceServices(
     const base::FilePath& device_path,
     std::vector<std::unique_ptr<ServiceRecordState>>* service_record_states) {
+  if (!le_wrapper_->IsBluetoothLowEnergySupported()) {
+    return true;  // Bluetooth LE not supported is not an error.
+  }
+
   std::string error;
   std::vector<std::unique_ptr<win::BluetoothLowEnergyServiceInfo>> services;
   bool success = le_wrapper_->EnumerateKnownBluetoothLowEnergyServices(
diff --git a/device/bluetooth/test/bluetooth_test_win.cc b/device/bluetooth/test/bluetooth_test_win.cc
index 297eb57d3f674..05b3775f8075a 100644
--- a/device/bluetooth/test/bluetooth_test_win.cc
+++ b/device/bluetooth/test/bluetooth_test_win.cc
@@ -55,7 +55,10 @@
 // Note: As UWP does not provide int specializations for IObservableVector and
 // VectorChangedEventHandler we need to supply our own. UUIDs were generated
 // using `uuidgen`.
-namespace ABI::Windows::Foundation::Collections {
+namespace ABI {
+namespace Windows {
+namespace Foundation {
+namespace Collections {
 
 template <>
 struct __declspec(uuid("2736c37e-4218-496f-a46a-92d5d9e610a9"))
@@ -65,7 +68,10 @@ template <>
 struct __declspec(uuid("94844fba-ddf9-475c-be6e-ebb87039cef6"))
     VectorChangedEventHandler<GUID> : VectorChangedEventHandler_impl<GUID> {};
 
-}  // namespace ABI::Windows::Foundation::Collections
+}  // namespace Collections
+}  // namespace Foundation
+}  // namespace Windows
+}  // namespace ABI
 
 namespace device {
 
@@ -256,6 +262,8 @@ BluetoothTestWin::BluetoothTestWin()
 BluetoothTestWin::~BluetoothTestWin() {}
 
 bool BluetoothTestWin::PlatformSupportsLowEnergy() {
+  if (fake_bt_le_wrapper_)
+    return fake_bt_le_wrapper_->IsBluetoothLowEnergySupported();
   return true;
 }
 
@@ -685,7 +693,9 @@ BluetoothTestWinrt::BluetoothTestWinrt() {
   std::vector<base::test::FeatureRef> disabled;
   if (GetParam().new_ble_implementation_enabled) {
     enabled.push_back(kNewBLEWinImplementation);
-    scoped_winrt_initializer_.emplace();
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      scoped_winrt_initializer_.emplace();
+    }
   } else {
     disabled.push_back(kNewBLEWinImplementation);
   }
@@ -706,6 +716,12 @@ BluetoothTestWinrt::~BluetoothTestWinrt() {
   notify_sessions_.clear();
 }
 
+bool BluetoothTestWinrt::PlatformSupportsLowEnergy() {
+  return UsesNewBleImplementation()
+             ? base::win::GetVersion() >= base::win::Version::WIN10
+             : BluetoothTestWin::PlatformSupportsLowEnergy();
+}
+
 bool BluetoothTestWinrt::UsesNewBleImplementation() const {
   return GetParam().new_ble_implementation_enabled;
 }
@@ -832,9 +848,8 @@ void BluetoothTestWinrt::SimulateAdapterPoweredOff() {
 
 BluetoothDevice* BluetoothTestWinrt::SimulateLowEnergyDevice(
     int device_ordinal) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateLowEnergyDevice(device_ordinal);
-  }
 
   LowEnergyDeviceData data = GetLowEnergyDeviceData(device_ordinal);
   static_cast<TestBluetoothAdapterWinrt*>(adapter_.get())
@@ -911,9 +926,8 @@ void BluetoothTestWinrt::SimulateAdvertisementError(
 }
 
 void BluetoothTestWinrt::SimulateGattConnection(BluetoothDevice* device) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattConnection(device);
-  }
 
   // Spin the message loop to make sure a device instance was obtained.
   base::RunLoop().RunUntilIdle();
@@ -934,9 +948,8 @@ void BluetoothTestWinrt::SimulateGattConnection(BluetoothDevice* device) {
 
 void BluetoothTestWinrt::SimulateGattNameChange(BluetoothDevice* device,
                                                 const std::string& new_name) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattNameChange(device, new_name);
-  }
 
   auto* const ble_device =
       static_cast<TestBluetoothDeviceWinrt*>(device)->ble_device();
@@ -946,9 +959,8 @@ void BluetoothTestWinrt::SimulateGattNameChange(BluetoothDevice* device,
 
 void BluetoothTestWinrt::SimulateStatusChangeToDisconnect(
     BluetoothDevice* device) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateStatusChangeToDisconnect(device);
-  }
   // Spin the message loop to make sure a device instance was obtained.
   base::RunLoop().RunUntilIdle();
   auto* const ble_device =
@@ -1000,10 +1012,9 @@ void BluetoothTestWinrt::SimulateGattServicesDiscovered(
     BluetoothDevice* device,
     const std::vector<std::string>& uuids,
     const std::vector<std::string>& blocked_uuids) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattServicesDiscovered(device, uuids,
                                                             blocked_uuids);
-  }
 
   auto* const ble_device =
       static_cast<TestBluetoothDeviceWinrt*>(device)->ble_device();
@@ -1012,9 +1023,8 @@ void BluetoothTestWinrt::SimulateGattServicesDiscovered(
 }
 
 void BluetoothTestWinrt::SimulateGattServicesChanged(BluetoothDevice* device) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattServicesChanged(device);
-  }
 
   auto* const ble_device =
       static_cast<TestBluetoothDeviceWinrt*>(device)->ble_device();
@@ -1024,9 +1034,8 @@ void BluetoothTestWinrt::SimulateGattServicesChanged(BluetoothDevice* device) {
 
 void BluetoothTestWinrt::SimulateGattServiceRemoved(
     BluetoothRemoteGattService* service) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattServiceRemoved(service);
-  }
 
   auto* const ble_device =
       static_cast<TestBluetoothDeviceWinrt*>(service->GetDevice())
@@ -1037,9 +1046,8 @@ void BluetoothTestWinrt::SimulateGattServiceRemoved(
 
 void BluetoothTestWinrt::SimulateGattServicesDiscoveryError(
     BluetoothDevice* device) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattServicesDiscoveryError(device);
-  }
 
   auto* const ble_device =
       static_cast<TestBluetoothDeviceWinrt*>(device)->ble_device();
@@ -1051,10 +1059,9 @@ void BluetoothTestWinrt::SimulateGattCharacteristic(
     BluetoothRemoteGattService* service,
     const std::string& uuid,
     int properties) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattCharacteristic(service, uuid,
                                                         properties);
-  }
 
   auto* const ble_device =
       static_cast<TestBluetoothDeviceWinrt*>(service->GetDevice())
@@ -1065,9 +1072,8 @@ void BluetoothTestWinrt::SimulateGattCharacteristic(
 
 void BluetoothTestWinrt::SimulateGattNotifySessionStarted(
     BluetoothRemoteGattCharacteristic* characteristic) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattNotifySessionStarted(characteristic);
-  }
 
   static_cast<FakeGattCharacteristicWinrt*>(
       static_cast<BluetoothRemoteGattCharacteristicWinrt*>(characteristic)
@@ -1078,7 +1084,7 @@ void BluetoothTestWinrt::SimulateGattNotifySessionStarted(
 void BluetoothTestWinrt::SimulateGattNotifySessionStartError(
     BluetoothRemoteGattCharacteristic* characteristic,
     BluetoothGattService::GattErrorCode error_code) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy()) {
     return BluetoothTestWin::SimulateGattNotifySessionStartError(characteristic,
                                                                  error_code);
   }
@@ -1109,7 +1115,7 @@ void BluetoothTestWinrt::SimulateGattNotifySessionStopError(
 void BluetoothTestWinrt::SimulateGattCharacteristicChanged(
     BluetoothRemoteGattCharacteristic* characteristic,
     const std::vector<uint8_t>& value) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy()) {
     return BluetoothTestWin::SimulateGattCharacteristicChanged(characteristic,
                                                                value);
   }
@@ -1123,7 +1129,7 @@ void BluetoothTestWinrt::SimulateGattCharacteristicChanged(
 void BluetoothTestWinrt::SimulateGattCharacteristicRead(
     BluetoothRemoteGattCharacteristic* characteristic,
     const std::vector<uint8_t>& value) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy()) {
     return BluetoothTestWin::SimulateGattCharacteristicRead(characteristic,
                                                             value);
   }
@@ -1137,7 +1143,7 @@ void BluetoothTestWinrt::SimulateGattCharacteristicRead(
 void BluetoothTestWinrt::SimulateGattCharacteristicReadError(
     BluetoothRemoteGattCharacteristic* characteristic,
     BluetoothGattService::GattErrorCode error_code) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy()) {
     return BluetoothTestWin::SimulateGattCharacteristicReadError(characteristic,
                                                                  error_code);
   }
@@ -1150,9 +1156,8 @@ void BluetoothTestWinrt::SimulateGattCharacteristicReadError(
 
 void BluetoothTestWinrt::SimulateGattCharacteristicWrite(
     BluetoothRemoteGattCharacteristic* characteristic) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattCharacteristicWrite(characteristic);
-  }
 
   static_cast<FakeGattCharacteristicWinrt*>(
       static_cast<BluetoothRemoteGattCharacteristicWinrt*>(characteristic)
@@ -1163,7 +1168,7 @@ void BluetoothTestWinrt::SimulateGattCharacteristicWrite(
 void BluetoothTestWinrt::SimulateGattCharacteristicWriteError(
     BluetoothRemoteGattCharacteristic* characteristic,
     BluetoothGattService::GattErrorCode error_code) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy()) {
     return BluetoothTestWin::SimulateGattCharacteristicWriteError(
         characteristic, error_code);
   }
@@ -1177,9 +1182,8 @@ void BluetoothTestWinrt::SimulateGattCharacteristicWriteError(
 void BluetoothTestWinrt::SimulateGattDescriptor(
     BluetoothRemoteGattCharacteristic* characteristic,
     const std::string& uuid) {
-  if (!UsesNewBleImplementation()) {
+  if (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
     return BluetoothTestWin::SimulateGattDescriptor(characteristic, uuid);
-  }
 
   auto* const ble_device = static_cast<TestBluetoothDeviceWinrt*>(
                                characteristic->GetService()->GetDevice())
@@ -1224,8 +1228,9 @@ void BluetoothTestWinrt::SimulateGattDescriptorWriteError(
 }
 
 void BluetoothTestWinrt::DeleteDevice(BluetoothDevice* device) {
-  (!UsesNewBleImplementation()) ? BluetoothTestWin::DeleteDevice(device)
-                                : BluetoothTestBase::DeleteDevice(device);
+  (!UsesNewBleImplementation() || !PlatformSupportsLowEnergy())
+      ? BluetoothTestWin::DeleteDevice(device)
+      : BluetoothTestBase::DeleteDevice(device);
 }
 
 void BluetoothTestWinrt::OnFakeBluetoothDeviceConnectGattAttempt() {
diff --git a/device/bluetooth/test/bluetooth_test_win.h b/device/bluetooth/test/bluetooth_test_win.h
index 18b8649e02238..72f14b5786e85 100644
--- a/device/bluetooth/test/bluetooth_test_win.h
+++ b/device/bluetooth/test/bluetooth_test_win.h
@@ -180,6 +180,7 @@ class BluetoothTestWinrt
   void SimulateSpuriousRadioStateChangedEvent();
 
   // BluetoothTestBase:
+  bool PlatformSupportsLowEnergy() override;
   void InitWithDefaultAdapter() override;
   void InitWithoutDefaultAdapter() override;
   void InitWithFakeAdapter() override;
diff --git a/device/gamepad/gamepad_platform_data_fetcher.h b/device/gamepad/gamepad_platform_data_fetcher.h
index 45fd194d1c931..fc38188f3620f 100644
--- a/device/gamepad/gamepad_platform_data_fetcher.h
+++ b/device/gamepad/gamepad_platform_data_fetcher.h
@@ -18,6 +18,7 @@
 #if BUILDFLAG(IS_ANDROID)
 #include "device/gamepad/gamepad_platform_data_fetcher_android.h"
 #elif BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "device/gamepad/nintendo_data_fetcher.h"
 #include "device/gamepad/raw_input_data_fetcher_win.h"
 #include "device/gamepad/wgi_data_fetcher_win.h"
@@ -43,7 +44,8 @@ void AddGamepadPlatformDataFetchers(GamepadDataFetcherManager* manager) {
 
   // Windows.Gaming.Input is available in Windows 10.0.10240.0 and later.
   if (base::FeatureList::IsEnabled(
-          features::kEnableWindowsGamingInputDataFetcher)) {
+          features::kEnableWindowsGamingInputDataFetcher) &&
+      base::win::GetVersion() >= base::win::Version::WIN10) {
     manager->AddFactory(new WgiDataFetcherWin::Factory());
   } else {
     manager->AddFactory(new XInputDataFetcherWin::Factory());
diff --git a/device/gamepad/wgi_data_fetcher_win_unittest.cc b/device/gamepad/wgi_data_fetcher_win_unittest.cc
index 248306a6c014c..56916794df5b5 100644
--- a/device/gamepad/wgi_data_fetcher_win_unittest.cc
+++ b/device/gamepad/wgi_data_fetcher_win_unittest.cc
@@ -23,6 +23,7 @@
 #include "base/threading/thread.h"
 #include "base/time/time.h"
 #include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 #include "device/gamepad/gamepad_id_list.h"
 #include "device/gamepad/gamepad_pad_state_provider.h"
 #include "device/gamepad/gamepad_provider.h"
@@ -158,6 +159,13 @@ class WgiDataFetcherWinTest : public DeviceServiceTestBase {
   WgiDataFetcherWinTest() = default;
   ~WgiDataFetcherWinTest() override = default;
 
+  void SetUp() override {
+    // Windows.Gaming.Input is available in Windows 10.0.10240.0 and later.
+    if (base::win::GetVersion() < base::win::Version::WIN10)
+      GTEST_SKIP();
+    DeviceServiceTestBase::SetUp();
+  }
+
   void SetUpXInputEnv(WgiTestErrorCode error_code) {
     // Resetting MockXInputGetStateExFunc static variable state.
     MockXInputGetStateExFunc(XUSER_MAX_COUNT + 1, nullptr);
diff --git a/device/gamepad/xinput_data_fetcher_win.cc b/device/gamepad/xinput_data_fetcher_win.cc
index 1493dccfaa523..c000cd69da153 100644
--- a/device/gamepad/xinput_data_fetcher_win.cc
+++ b/device/gamepad/xinput_data_fetcher_win.cc
@@ -16,6 +16,7 @@
 #include "base/task/sequenced_task_runner.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 
 namespace device {
 
@@ -43,9 +44,6 @@ static const LPCSTR kXInputGetStateExOrdinal = (LPCSTR)100;
 // Bitmask for the Guide button in XInputGamepadEx.wButtons.
 static const int kXInputGamepadGuide = 0x0400;
 
-constexpr base::FilePath::CharType kXInputDllFileName[] =
-    FILE_PATH_LITERAL("xinput1_4.dll");
-
 float NormalizeXInputAxis(SHORT value) {
   return ((value + 32768.f) / 32767.5f) - 1.f;
 }
@@ -77,6 +75,17 @@ const wchar_t* GamepadSubTypeName(BYTE sub_type) {
   }
 }
 
+const base::FilePath::CharType* XInputDllFileName() {
+  // Xinput.h defines filename (XINPUT_DLL) on different Windows versions, but
+  // Xinput.h specifies it in build time. Approach here uses the same values
+  // and it is resolving dll filename based on Windows version it is running on.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    // For Windows 8+, XINPUT_DLL is xinput1_4.dll.
+    return FILE_PATH_LITERAL("xinput1_4.dll");
+  }
+  return FILE_PATH_LITERAL("xinput9_1_0.dll");
+}
+
 }  // namespace
 
 XInputDataFetcherWin::XInputDataFetcherWin() : xinput_available_(false) {}
@@ -93,7 +102,7 @@ GamepadSource XInputDataFetcherWin::source() {
 }
 
 void XInputDataFetcherWin::OnAddedToProvider() {
-  xinput_dll_ = base::ScopedNativeLibrary(base::FilePath(kXInputDllFileName));
+  xinput_dll_ = base::ScopedNativeLibrary(base::FilePath(XInputDllFileName()));
   xinput_available_ = GetXInputDllFunctions();
 }
 
@@ -403,7 +412,7 @@ bool XInputDataFetcherWin::GetXInputDllFunctionsForWgiDataFetcher() {
 }
 
 void XInputDataFetcherWin::InitializeForWgiDataFetcher() {
-  xinput_dll_ = base::ScopedNativeLibrary(base::FilePath(kXInputDllFileName));
+  xinput_dll_ = base::ScopedNativeLibrary(base::FilePath(XInputDllFileName()));
   xinput_available_ = GetXInputDllFunctionsForWgiDataFetcher();
 }
 
diff --git a/extensions/browser/api/app_window/app_window_apitest.cc b/extensions/browser/api/app_window/app_window_apitest.cc
index 05fd65925c610..d51e23e9a1006 100644
--- a/extensions/browser/api/app_window/app_window_apitest.cc
+++ b/extensions/browser/api/app_window/app_window_apitest.cc
@@ -24,6 +24,10 @@
 #include "ui/base/base_window.h"
 #include "ui/gfx/geometry/rect.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
+#endif
+
 namespace extensions {
 
 using AppWindowApiTest = PlatformAppBrowserTest;
@@ -143,6 +147,12 @@ IN_PROC_BROWSER_TEST_F(AppWindowApiTest, MAYBE_AlphaEnabledHasPermissions) {
 // of lacros-chrome is complete.
 #if defined(USE_AURA) && !(BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
   test_dir = kHasAlphaDir;
+
+#if BUILDFLAG(IS_WIN)
+  if (!ui::win::IsAeroGlassEnabled()) {
+    test_dir = kNoAlphaDir;
+  }
+#endif  // BUILDFLAG(IS_WIN)
 #endif  // USE_AURA && !(OS_LINUX || IS_CHROMEOS_LACROS)
 
   EXPECT_TRUE(RunExtensionTest(test_dir, {.launch_as_platform_app = true}))
diff --git a/gpu/command_buffer/service/dxgi_shared_handle_manager_unittest.cc b/gpu/command_buffer/service/dxgi_shared_handle_manager_unittest.cc
index 7f33a273d6241..c2507b73cdaa1 100644
--- a/gpu/command_buffer/service/dxgi_shared_handle_manager_unittest.cc
+++ b/gpu/command_buffer/service/dxgi_shared_handle_manager_unittest.cc
@@ -11,6 +11,7 @@
 #include "base/synchronization/lock.h"
 #include "base/task/thread_pool.h"
 #include "base/test/bind.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gl/gl_angle_util_win.h"
 
@@ -20,9 +21,12 @@ namespace {
 class DXGISharedHandleManagerTest : public testing::Test {
  protected:
   void SetUp() override {
+    // Using DXGI NT handles is universally supported only on Win8 and above.
     // TODO(sunnyps): Unify this with the check in D3DImageBackingFactory.
+    const bool shared_handles_supported =
+        base::win::GetVersion() >= base::win::Version::WIN8;
     d3d11_device_ = gl::QueryD3D11DeviceObjectFromANGLE();
-    if (d3d11_device_) {
+    if (shared_handles_supported && d3d11_device_) {
       dxgi_shared_handle_manager_ =
           base::MakeRefCounted<DXGISharedHandleManager>(d3d11_device_);
     }
diff --git a/gpu/command_buffer/service/shared_image/dxgi_swap_chain_image_backing.cc b/gpu/command_buffer/service/shared_image/dxgi_swap_chain_image_backing.cc
index 4cbecffd7a2a5..428662c9b5b17 100644
--- a/gpu/command_buffer/service/shared_image/dxgi_swap_chain_image_backing.cc
+++ b/gpu/command_buffer/service/shared_image/dxgi_swap_chain_image_backing.cc
@@ -12,6 +12,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "gpu/command_buffer/common/mailbox.h"
 #include "gpu/command_buffer/common/shared_image_usage.h"
 #include "gpu/command_buffer/service/memory_tracking.h"
@@ -40,7 +41,9 @@ namespace {
 const char* kDXGISwapChainImageBackingLabel = "DXGISwapChainImageBacking";
 
 bool IsWaitableSwapChainEnabled() {
-  return base::FeatureList::IsEnabled(features::kDXGIWaitableSwapChain);
+  // Waitable swap chains were first enabled in Win 8.1/DXGI 1.3
+  return (base::win::GetVersion() >= base::win::Version::WIN8_1) &&
+         base::FeatureList::IsEnabled(features::kDXGIWaitableSwapChain);
 }
 
 UINT GetMaxWaitableQueuedFrames() {
diff --git a/gpu/config/gpu_info_collector_win.cc b/gpu/config/gpu_info_collector_win.cc
index fd4c295d1f38b..cb0230755c272 100644
--- a/gpu/config/gpu_info_collector_win.cc
+++ b/gpu/config/gpu_info_collector_win.cc
@@ -8,6 +8,11 @@
 #include <stddef.h>
 #include <stdint.h>
 
+// This has to be included before windows.h.
+#include "third_party/re2/src/re2/re2.h"
+
+#include <windows.h>
+
 #include <d3d11.h>
 #include <d3d11_3.h>
 #include <d3d12.h>
@@ -27,9 +32,9 @@
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "build/branding_buildflags.h"
 #include "gpu/config/gpu_util.h"
-#include "third_party/re2/src/re2/re2.h"
 #include "ui/gl/direct_composition_support.h"
 #include "ui/gl/gl_angle_util_win.h"
 #include "ui/gl/gl_display.h"
@@ -158,6 +163,20 @@ bool GetActiveAdapterLuid(LUID* luid) {
 
 }  // namespace
 
+#if BUILDFLAG(GOOGLE_CHROME_BRANDING) && defined(OFFICIAL_BUILD)
+// This function has a real implementation for official builds that can
+// be found in src/third_party/amd.
+bool GetAMDSwitchableInfo(bool* is_switchable,
+                          uint32_t* active_vendor_id,
+                          uint32_t* active_device_id);
+#else
+bool GetAMDSwitchableInfo(bool* is_switchable,
+                          uint32_t* active_vendor_id,
+                          uint32_t* active_device_id) {
+  return false;
+}
+#endif
+
 // This has to be called after a context is created, active GPU is identified,
 // and GPU driver bug workarounds are computed again. Otherwise the workaround
 // |disable_direct_composition| may not be correctly applied.
@@ -192,6 +211,10 @@ bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
   if (FAILED(hr))
     return false;
 
+  bool found_amd = false;
+  bool found_intel = false;
+  bool found_nvidia = false;
+
   UINT i;
   Microsoft::WRL::ComPtr<IDXGIAdapter> dxgi_adapter;
   for (i = 0; SUCCEEDED(dxgi_factory->EnumAdapters(i, &dxgi_adapter)); i++) {
@@ -218,6 +241,20 @@ bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
       DLOG(ERROR) << "Unable to retrieve the umd version of adapter: "
                   << desc.Description << " HR: " << std::hex << hr;
     }
+    switch (device.vendor_id) {
+      case 0x8086:
+        found_intel = true;
+        break;
+      case 0x1002:
+        found_amd = true;
+        break;
+      case 0x10de:
+        found_nvidia = true;
+        break;
+      default:
+        break;
+    }
+
     if (i == 0) {
       gpu_info->gpu = device;
     } else {
@@ -225,6 +262,23 @@ bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
     }
   }
 
+  if (found_intel && base::win::GetVersion() < base::win::Version::WIN10) {
+    // Since Windows 10 (and Windows 8.1 on some systems), switchable graphics
+    // platforms are managed by Windows and each adapter is accessible as
+    // separate devices.
+    // See https://msdn.microsoft.com/en-us/windows/dn265501(v=vs.80)
+    if (found_amd) {
+      bool is_amd_switchable = false;
+      uint32_t active_vendor = 0, active_device = 0;
+      GetAMDSwitchableInfo(&is_amd_switchable, &active_vendor, &active_device);
+      gpu_info->amd_switchable = is_amd_switchable;
+    } else if (found_nvidia) {
+      // nvd3d9wrap.dll is loaded into all processes when Optimus is enabled.
+      HMODULE nvd3d9wrap = GetModuleHandleW(L"nvd3d9wrap.dll");
+      gpu_info->optimus = nvd3d9wrap != nullptr;
+    }
+  }
+
   Microsoft::WRL::ComPtr<IDXGIFactory6> dxgi_factory6;
   if (gpu_info->GpuCount() > 1 && SUCCEEDED(dxgi_factory.As(&dxgi_factory6))) {
     if (SUCCEEDED(dxgi_factory6->EnumAdapterByGpuPreference(
@@ -487,6 +541,7 @@ bool InitVulkanInstanceProc(
     PFN_vkEnumeratePhysicalDevices* vkEnumeratePhysicalDevices,
     PFN_vkEnumerateDeviceExtensionProperties*
         vkEnumerateDeviceExtensionProperties) {
+
   *vkEnumeratePhysicalDevices =
       reinterpret_cast<PFN_vkEnumeratePhysicalDevices>(
           vkGetInstanceProcAddr(vk_instance, "vkEnumeratePhysicalDevices"));
diff --git a/gpu/ipc/service/gpu_watchdog_thread.cc b/gpu/ipc/service/gpu_watchdog_thread.cc
index 7dfca75187822..38d1d946d0b71 100644
--- a/gpu/ipc/service/gpu_watchdog_thread.cc
+++ b/gpu/ipc/service/gpu_watchdog_thread.cc
@@ -4,10 +4,6 @@
 
 #include "gpu/ipc/service/gpu_watchdog_thread.h"
 
-#include <memory>
-#include <string>
-#include <utility>
-
 #include "base/atomicops.h"
 #include "base/bit_cast.h"
 #include "base/command_line.h"
@@ -34,6 +30,10 @@
 #include "gpu/config/gpu_switches.h"
 #include "gpu/ipc/common/result_codes.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gpu {
 
 base::TimeDelta GetGpuWatchdogTimeout() {
@@ -50,11 +50,12 @@ base::TimeDelta GetGpuWatchdogTimeout() {
   }
 
 #if BUILDFLAG(IS_WIN)
-  int num_of_processors = base::SysInfo::NumberOfProcessors();
-  if (num_of_processors > 8) {
-    return (kGpuWatchdogTimeout - base::Seconds(10));
-  } else if (num_of_processors <= 4) {
-    return kGpuWatchdogTimeout + base::Seconds(5);
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    int num_of_processors = base::SysInfo::NumberOfProcessors();
+    if (num_of_processors > 8)
+      return (kGpuWatchdogTimeout - base::Seconds(10));
+    else if (num_of_processors <= 4)
+      return kGpuWatchdogTimeout + base::Seconds(5);
   }
 #endif
 
diff --git a/gpu/ipc/service/gpu_watchdog_thread_unittest.cc b/gpu/ipc/service/gpu_watchdog_thread_unittest.cc
index 13bea03495651..23d68d8a9545e 100644
--- a/gpu/ipc/service/gpu_watchdog_thread_unittest.cc
+++ b/gpu/ipc/service/gpu_watchdog_thread_unittest.cc
@@ -3,10 +3,6 @@
 // found in the LICENSE file.
 
 #include "gpu/ipc/service/gpu_watchdog_thread.h"
-
-#include <memory>
-#include <string>
-
 #include "base/test/task_environment.h"
 
 #include "base/power_monitor/power_monitor.h"
@@ -19,6 +15,10 @@
 #include "build/build_config.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_MAC)
 #include "base/mac/mac_util.h"
 #endif
@@ -121,7 +121,13 @@ void GpuWatchdogTest::SetUp() {
 
   TimeOutType timeout_type = kNormal;
 
-#if BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_WIN)
+  // Win7
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    timeout_type = kSlow;
+  }
+
+#elif BUILDFLAG(IS_MAC)
   // Use slow timeout for Mac versions < 11.00 and for MacBookPro model <
   // MacBookPro14,1
   int os_version = base::mac::internal::MacOSVersion();
diff --git a/media/audio/audio_encoders_unittest.cc b/media/audio/audio_encoders_unittest.cc
index 849e7ce70d8e3..dac9b48236755 100644
--- a/media/audio/audio_encoders_unittest.cc
+++ b/media/audio/audio_encoders_unittest.cc
@@ -27,6 +27,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "media/gpu/windows/mf_audio_encoder.h"
 #define HAS_AAC_ENCODER 1
 #endif
@@ -158,6 +159,11 @@ class AudioEncodersTest : public ::testing::TestWithParam<TestAudioParams> {
     } else if (options_.codec == AudioCodec::kAAC) {
 #if BUILDFLAG(IS_WIN)
       EXPECT_TRUE(com_initializer_.Succeeded());
+      if (options_.channels == 6 &&
+          base::win::GetVersion() < base::win::Version::WIN10) {
+        GTEST_SKIP() << "5.1 channel audio is not supported by the MF AAC "
+                        "encoder on versions below Win10.";
+      }
       ASSERT_TRUE(base::SequencedTaskRunner::HasCurrentDefault());
       encoder_ = std::make_unique<MFAudioEncoder>(
           base::SequencedTaskRunner::GetCurrentDefault());
diff --git a/media/audio/win/audio_low_latency_input_win.cc b/media/audio/win/audio_low_latency_input_win.cc
index fc9ab281efe52..02fc1b8a73dc1 100644
--- a/media/audio/win/audio_low_latency_input_win.cc
+++ b/media/audio/win/audio_low_latency_input_win.cc
@@ -231,6 +231,10 @@ bool InitializeUWPSupport() {
   static const bool initialization_result = []() {
     // Windows.Media.Effects and Windows.Media.Devices requires Windows 10 build
     // 10.0.10240.0.
+    if (base::win::GetVersion() < base::win::Version::WIN10) {
+      DLOG(WARNING) << "AudioCaptureEffectsManager requires Windows 10";
+      return false;
+    }
     DCHECK_GE(base::win::OSInfo::GetInstance()->version_number().build, 10240u);
 
     // Provide access to Core WinRT/UWP functions and load all required HSTRING
diff --git a/media/audio/win/core_audio_util_win.cc b/media/audio/win/core_audio_util_win.cc
index d4c94d3c060f3..b6020263733d7 100644
--- a/media/audio/win/core_audio_util_win.cc
+++ b/media/audio/win/core_audio_util_win.cc
@@ -208,7 +208,8 @@ ChannelConfig GuessChannelConfig(WORD channels) {
 }
 
 bool IAudioClient3IsSupported() {
-  return base::FeatureList::IsEnabled(features::kAllowIAudioClient3);
+  return base::FeatureList::IsEnabled(features::kAllowIAudioClient3) &&
+         CoreAudioUtil::GetIAudioClientVersion() >= 3;
 }
 
 std::string GetDeviceID(IMMDevice* device) {
@@ -599,6 +600,19 @@ base::TimeDelta CoreAudioUtil::ReferenceTimeToTimeDelta(REFERENCE_TIME time) {
   return base::Microseconds(0.1 * time + 0.5);
 }
 
+uint32_t CoreAudioUtil::GetIAudioClientVersion() {
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    // Minimum supported client: Windows 10.
+    // Minimum supported server: Windows Server 2016
+    return 3;
+  } else if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    // Minimum supported client: Windows 8.
+    // Minimum supported server: Windows Server 2012.
+    return 2;
+  }
+  return 1;
+}
+
 AUDCLNT_SHAREMODE CoreAudioUtil::GetShareMode() {
   const base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
   if (cmd_line->HasSwitch(switches::kEnableExclusiveAudio))
diff --git a/media/audio/win/core_audio_util_win.h b/media/audio/win/core_audio_util_win.h
index 223e7e957e9da..34c07cbcc8304 100644
--- a/media/audio/win/core_audio_util_win.h
+++ b/media/audio/win/core_audio_util_win.h
@@ -79,6 +79,10 @@ class MEDIA_EXPORT CoreAudioUtil {
   // Example: double s = RefererenceTimeToTimeDelta(t).InMillisecondsF();
   static base::TimeDelta ReferenceTimeToTimeDelta(REFERENCE_TIME time);
 
+  // Returns 1, 2, or 3 corresponding to the highest version of IAudioClient
+  // the platform supports.
+  static uint32_t GetIAudioClientVersion();
+
   // Returns AUDCLNT_SHAREMODE_EXCLUSIVE if --enable-exclusive-mode is used
   // as command-line flag and AUDCLNT_SHAREMODE_SHARED otherwise (default).
   static AUDCLNT_SHAREMODE GetShareMode();
diff --git a/media/audio/win/core_audio_util_win_unittest.cc b/media/audio/win/core_audio_util_win_unittest.cc
index cd88148d8b540..d1d5b4702506b 100644
--- a/media/audio/win/core_audio_util_win_unittest.cc
+++ b/media/audio/win/core_audio_util_win_unittest.cc
@@ -104,6 +104,12 @@ TEST_F(CoreAudioUtilWinTest, WaveFormatWrapperExtended) {
   EXPECT_TRUE(wave_format_ex.IsFloat());
 }
 
+TEST_F(CoreAudioUtilWinTest, GetIAudioClientVersion) {
+  uint32_t client_version = CoreAudioUtil::GetIAudioClientVersion();
+  EXPECT_GE(client_version, 1u);
+  EXPECT_LE(client_version, 3u);
+}
+
 TEST_F(CoreAudioUtilWinTest, NumberOfActiveDevices) {
   ABORT_AUDIO_TEST_IF_NOT(DevicesAvailable());
 
@@ -280,7 +286,8 @@ TEST_F(CoreAudioUtilWinTest, CreateClient) {
 }
 
 TEST_F(CoreAudioUtilWinTest, CreateClient3) {
-  ABORT_AUDIO_TEST_IF_NOT(DevicesAvailable());
+  ABORT_AUDIO_TEST_IF_NOT(DevicesAvailable() &&
+                          CoreAudioUtil::GetIAudioClientVersion() >= 3);
 
   EDataFlow data[] = {eRender, eCapture};
 
diff --git a/media/base/win/dxgi_device_manager.cc b/media/base/win/dxgi_device_manager.cc
index 30876d22752ed..1e953a4e40e45 100644
--- a/media/base/win/dxgi_device_manager.cc
+++ b/media/base/win/dxgi_device_manager.cc
@@ -8,10 +8,9 @@
 #include <mferror.h>
 #include <mfreadwrite.h>
 
-#include <utility>
-
 #include "base/check.h"
 #include "base/logging.h"
+#include "base/win/windows_version.h"
 #include "media/base/win/mf_helpers.h"
 
 namespace media {
@@ -60,10 +59,12 @@ Microsoft::WRL::ComPtr<ID3D11Device> DXGIDeviceScopedHandle::GetDevice() {
 }
 
 scoped_refptr<DXGIDeviceManager> DXGIDeviceManager::Create(CHROME_LUID luid) {
-  if (!::GetModuleHandle(L"mfplat.dll") && !::LoadLibrary(L"mfplat.dll")) {
-    // The MF DXGI Device manager is not supported when mfplat.dll isn't
-    // available.
-    DLOG(ERROR) << "MF DXGI Device Manager is not available";
+  if (base::win::GetVersion() < base::win::Version::WIN8 ||
+      (!::GetModuleHandle(L"mfplat.dll") && !::LoadLibrary(L"mfplat.dll"))) {
+    // The MF DXGI Device manager is only supported on Win8 or later
+    // Additionally, it is not supported when mfplat.dll isn't available
+    DLOG(ERROR)
+        << "MF DXGI Device Manager not supported on current version of Windows";
     return nullptr;
   }
   Microsoft::WRL::ComPtr<IMFDXGIDeviceManager> mf_dxgi_device_manager;
diff --git a/media/base/win/dxgi_device_scope_handle_unittest.cc b/media/base/win/dxgi_device_scope_handle_unittest.cc
index bbd6d2fc793b1..64716c161a624 100644
--- a/media/base/win/dxgi_device_scope_handle_unittest.cc
+++ b/media/base/win/dxgi_device_scope_handle_unittest.cc
@@ -5,6 +5,7 @@
 #include <d3d11.h>
 #include <mfapi.h>
 
+#include "base/win/windows_version.h"
 #include "media/base/test_helpers.h"
 #include "media/base/win/dxgi_device_manager.h"
 #include "media/base/win/mf_initializer.h"
@@ -15,11 +16,15 @@ using Microsoft::WRL::ComPtr;
 
 class DXGIDeviceScopedHandleTest : public testing::Test {
  public:
-  DXGIDeviceScopedHandleTest() = default;
+  DXGIDeviceScopedHandleTest()
+      : test_supported_(base::win::GetVersion() >= base::win::Version::WIN10) {}
   ~DXGIDeviceScopedHandleTest() override = default;
 
  protected:
   void SetUp() override {
+    if (!test_supported_)
+      return;
+
     ASSERT_TRUE(InitializeMediaFoundation());
 
     // Get a shared DXGI Device Manager from Media Foundation.
@@ -50,14 +55,20 @@ class DXGIDeviceScopedHandleTest : public testing::Test {
   }
 
   void TearDown() override {
-    ASSERT_HRESULT_SUCCEEDED(MFUnlockDXGIDeviceManager());
+    if (test_supported_) {
+      ASSERT_HRESULT_SUCCEEDED(MFUnlockDXGIDeviceManager());
+    }
   }
 
   Microsoft::WRL::ComPtr<IMFDXGIDeviceManager> dxgi_device_man_ = nullptr;
   UINT device_reset_token_ = 0;
+  const bool test_supported_;
 };
 
 TEST_F(DXGIDeviceScopedHandleTest, LockDevice) {
+  if (!test_supported_)
+    return;
+
   {
     // Create DXGIDeviceScopedHandle in an inner scope without LockDevice
     // call.
@@ -77,6 +88,9 @@ TEST_F(DXGIDeviceScopedHandleTest, LockDevice) {
 }
 
 TEST_F(DXGIDeviceScopedHandleTest, GetDevice) {
+  if (!test_supported_)
+    return;
+
   {
     // Create DXGIDeviceScopedHandle in an inner scope.
     DXGIDeviceScopedHandle device_handle_1(dxgi_device_man_.Get());
@@ -93,4 +107,4 @@ TEST_F(DXGIDeviceScopedHandleTest, GetDevice) {
   EXPECT_NE(device3, nullptr);
 }
 
-}  // namespace media
+}  // namespace media
\ No newline at end of file
diff --git a/media/capture/video/video_capture_device_unittest.cc b/media/capture/video/video_capture_device_unittest.cc
index 30a6f265b021f..87df730a31ab8 100644
--- a/media/capture/video/video_capture_device_unittest.cc
+++ b/media/capture/video/video_capture_device_unittest.cc
@@ -34,6 +34,7 @@
 #if BUILDFLAG(IS_WIN)
 #include <mfcaptureengine.h>
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"  // For fine-grained suppression.
 #include "media/capture/video/win/video_capture_device_factory_win.h"
 #include "media/capture/video/win/video_capture_device_mf_win.h"
 #endif
@@ -686,13 +687,18 @@ void VideoCaptureDeviceTest::RunCaptureMjpegTestCase() {
         << "Skipped on Chrome OS device where HAL v3 camera service is used";
     return;
   }
-#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+#endif
   auto device_info = GetFirstDeviceSupportingPixelFormat(PIXEL_FORMAT_MJPEG);
   ASSERT_TRUE(device_info);
 
 #if BUILDFLAG(IS_WIN)
-  GTEST_SKIP() << "Skipped on Windows:  https://crbug.com/570604";
-#else
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10) {
+    VLOG(1) << "Skipped on Win10: http://crbug.com/570604, current: "
+            << static_cast<int>(version);
+    return;
+  }
+#endif
   VideoCaptureErrorOrDevice device_status =
       video_capture_device_factory_->CreateDevice(device_info->descriptor);
   ASSERT_TRUE(device_status.ok());
@@ -715,7 +721,6 @@ void VideoCaptureDeviceTest::RunCaptureMjpegTestCase() {
             media::VideoFrame::AllocationSize(last_format().pixel_format,
                                               last_format().frame_size));
   device->StopAndDeAllocate();
-#endif  // BUILDFLAG(IS_WIN)
 }
 
 #define MAYBE_UsingRealWebcam_NoCameraSupportsPixelFormatMax \
diff --git a/media/capture/video/win/gpu_memory_buffer_tracker_unittest.cc b/media/capture/video/win/gpu_memory_buffer_tracker_unittest.cc
index be462ca53d6d1..2a92715425215 100644
--- a/media/capture/video/win/gpu_memory_buffer_tracker_unittest.cc
+++ b/media/capture/video/win/gpu_memory_buffer_tracker_unittest.cc
@@ -12,6 +12,7 @@
 
 #include "base/memory/scoped_refptr.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
 #include "media/capture/video/win/d3d_capture_test_utils.h"
 #include "media/capture/video/win/gpu_memory_buffer_tracker.h"
 #include "media/capture/video/win/video_capture_device_factory_win.h"
@@ -64,12 +65,29 @@ class MockDXGIDeviceManager : public DXGIDeviceManager {
 
 class GpuMemoryBufferTrackerTest : public ::testing::Test {
  protected:
-  GpuMemoryBufferTrackerTest() = default;
+  GpuMemoryBufferTrackerTest()
+      : media_foundation_supported_(
+            VideoCaptureDeviceFactoryWin::PlatformSupportsMediaFoundation()) {}
+
+  bool ShouldSkipTest() {
+    if (!media_foundation_supported_) {
+      DVLOG(1) << "Media foundation is not supported by the current platform. "
+                  "Skipping test.";
+      return true;
+    }
+    // D3D11 is only supported with Media Foundation on Windows 8 or later
+    if (base::win::GetVersion() < base::win::Version::WIN8) {
+      DVLOG(1) << "D3D11 with Media foundation is not supported by the current "
+                  "platform. "
+                  "Skipping test.";
+      return true;
+    }
+    return false;
+  }
 
   void SetUp() override {
-    if (!VideoCaptureDeviceFactoryWin::PlatformSupportsMediaFoundation()) {
-      GTEST_SKIP()
-          << "Media foundation is not supported by the current platform.";
+    if (ShouldSkipTest()) {
+      GTEST_SKIP();
     }
 
     dxgi_device_manager_ =
@@ -77,6 +95,7 @@ class GpuMemoryBufferTrackerTest : public ::testing::Test {
   }
 
   base::test::TaskEnvironment task_environment_;
+  const bool media_foundation_supported_;
   scoped_refptr<MockDXGIDeviceManager> dxgi_device_manager_;
 };
 
diff --git a/media/capture/video/win/video_capture_device_factory_win.cc b/media/capture/video/win/video_capture_device_factory_win.cc
index d2a7e743bf8cc..1146c04fb8ed2 100644
--- a/media/capture/video/win/video_capture_device_factory_win.cc
+++ b/media/capture/video/win/video_capture_device_factory_win.cc
@@ -13,11 +13,7 @@
 #include <wrl.h>
 #include <wrl/client.h>
 
-#include <algorithm>
-#include <memory>
-#include <string>
 #include <utility>
-#include <vector>
 
 #include "base/command_line.h"
 #include "base/containers/contains.h"
@@ -284,6 +280,12 @@ DevicesInfo::const_iterator FindNonDirectShowDeviceInfoByNameAndModel(
 }
 
 bool IsEnclosureLocationSupported() {
+  // DeviceInformation class is only available in Win10 onwards (v10.0.10240.0).
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    DVLOG(1) << "DeviceInformation not supported before Windows 10";
+    return false;
+  }
+
   if (!(base::win::ResolveCoreWinRTDelayload() &&
         ScopedHString::ResolveCoreWinRTStringDelayload())) {
     DLOG(ERROR) << "Failed loading functions from combase.dll";
diff --git a/media/capture/video/win/video_capture_device_factory_win_unittest.cc b/media/capture/video/win/video_capture_device_factory_win_unittest.cc
index 766b11fe47059..be82fdb9fc69e 100644
--- a/media/capture/video/win/video_capture_device_factory_win_unittest.cc
+++ b/media/capture/video/win/video_capture_device_factory_win_unittest.cc
@@ -14,12 +14,7 @@
 #include <wrl.h>
 #include <wrl/client.h>
 
-#include <map>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/functional/bind.h"
+#include "base/bind.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/ranges/algorithm.h"
 #include "base/run_loop.h"
@@ -27,6 +22,7 @@
 #include "base/test/bind.h"
 #include "base/test/scoped_feature_list.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
 #include "media/base/media_switches.h"
 #include "media/capture/video/win/video_capture_device_factory_win.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -1338,6 +1334,16 @@ class VideoCaptureDeviceFactoryWinTest : public ::testing::Test {
     return true;
   }
 
+  bool ShouldSkipD3D11Test() {
+    // D3D11 is only supported with Media Foundation on Windows 8 or later
+    if (base::win::GetVersion() >= base::win::Version::WIN8)
+      return false;
+    DVLOG(1) << "D3D11 with Media foundation is not supported by the current "
+                "platform. "
+                "Skipping test.";
+    return true;
+  }
+
   base::test::TaskEnvironment task_environment_;
   FakeVideoCaptureDeviceFactoryWin factory_;
   const bool media_foundation_supported_;
@@ -1357,6 +1363,8 @@ TEST_P(VideoCaptureDeviceFactoryMFWinTest, GetDevicesInfo) {
     return;
 
   const bool use_d3d11 = GetParam();
+  if (use_d3d11 && ShouldSkipD3D11Test())
+    return;
   factory_.set_use_d3d11_with_media_foundation_for_testing(use_d3d11);
 
   std::vector<VideoCaptureDeviceInfo> devices_info;
@@ -1453,6 +1461,8 @@ TEST_P(VideoCaptureDeviceFactoryMFWinTest, GetDevicesInfo_IncludeIRCameras) {
     return;
 
   const bool use_d3d11 = GetParam();
+  if (use_d3d11 && ShouldSkipD3D11Test())
+    return;
   factory_.set_use_d3d11_with_media_foundation_for_testing(use_d3d11);
 
   std::vector<VideoCaptureDeviceInfo> devices_info;
@@ -1556,6 +1566,9 @@ TEST_P(VideoCaptureDeviceFactoryMFWinTest,
   if (ShouldSkipMFTest())
     return;
 
+  if (ShouldSkipD3D11Test())
+    return;
+
   // Test whether the VideoCaptureDeviceFactory passes through NV12 as the
   // output pixel format when D3D11 support is enabled
 
diff --git a/media/capture/video/win/video_capture_device_mf_win_unittest.cc b/media/capture/video/win/video_capture_device_mf_win_unittest.cc
index c114098e777eb..a0a8bbb544e74 100644
--- a/media/capture/video/win/video_capture_device_mf_win_unittest.cc
+++ b/media/capture/video/win/video_capture_device_mf_win_unittest.cc
@@ -11,9 +11,6 @@
 #include <wincodec.h>
 
 #include <cmath>
-#include <memory>
-#include <string>
-#include <utility>
 
 #include "base/functional/bind.h"
 #include "base/functional/callback_helpers.h"
@@ -23,6 +20,7 @@
 #include "base/test/bind.h"
 #include "base/test/task_environment.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "media/base/win/mf_helpers.h"
 #include "media/capture/video/win/d3d_capture_test_utils.h"
 #include "media/capture/video/win/sink_filter_win.h"
@@ -1205,6 +1203,16 @@ class VideoCaptureDeviceMFWinTest : public ::testing::Test {
     return true;
   }
 
+  bool ShouldSkipD3D11Test() {
+    // D3D11 is only supported with Media Foundation on Windows 8 or later
+    if (base::win::GetVersion() >= base::win::Version::WIN8)
+      return false;
+    DVLOG(1) << "D3D11 with Media foundation is not supported by the current "
+                "platform. "
+                "Skipping test.";
+    return true;
+  }
+
   void PrepareMFDeviceWithOneVideoStream(GUID mf_video_subtype) {
     EXPECT_CALL(*capture_source_, DoGetDeviceStreamCount(_))
         .WillRepeatedly(Invoke([](DWORD* stream_count) {
@@ -2088,6 +2096,9 @@ TEST_P(DepthCameraDeviceMFWinTest, AllocateAndStartDepthCamera) {
 class VideoCaptureDeviceMFWinTestWithDXGI : public VideoCaptureDeviceMFWinTest {
  protected:
   void SetUp() override {
+    if (ShouldSkipD3D11Test())
+      GTEST_SKIP();
+
     Microsoft::WRL::ComPtr<IMFDXGIDeviceManager> mf_dxgi_device_manager;
     UINT d3d_device_reset_token = 0;
     HRESULT hr = MFCreateDXGIDeviceManager(&d3d_device_reset_token,
diff --git a/media/capture/video/win/video_capture_device_utils_win.cc b/media/capture/video/win/video_capture_device_utils_win.cc
index 53d314378af02..e2fd2b0c14f6c 100644
--- a/media/capture/video/win/video_capture_device_utils_win.cc
+++ b/media/capture/video/win/video_capture_device_utils_win.cc
@@ -7,8 +7,8 @@
 #include <cmath>
 #include <iostream>
 
-#include "base/check_op.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 
 namespace media {
 
@@ -82,6 +82,9 @@ double PlatformExposureTimeToCaptureStep(long log_step,
 int GetCameraRotation(VideoFacingMode facing) {
   int rotation = 0;
 
+  // Before Win10, we can't distinguish if the selected camera is an internal or
+  // external one. So we assume it's internal and do the frame rotation if the
+  // auto rotation is enabled to cover most user cases.
   if (!IsInternalCamera(facing)) {
     return rotation;
   }
@@ -95,9 +98,13 @@ int GetCameraRotation(VideoFacingMode facing) {
     return rotation;
   }
 
-  // Windows cameras with VideoFacingMode::MEDIA_VIDEO_FACING_NONE should early
-  // exit as part of the IsInternalCamera(facing) check above.
-  DCHECK_NE(facing, VideoFacingMode::MEDIA_VIDEO_FACING_NONE);
+  if (facing == VideoFacingMode::MEDIA_VIDEO_FACING_NONE) {
+    // We set camera facing using Win10 only DeviceInformation API. So pre-Win10
+    // cameras always have a facing of VideoFacingMode::MEDIA_VIDEO_FACING_NONE.
+    // Win10 cameras with VideoFacingMode::MEDIA_VIDEO_FACING_NONE should early
+    // exit as part of the IsInternalCamera(facing) check above.
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN10);
+  }
 
   DEVMODE mode;
   ::ZeroMemory(&mode, sizeof(mode));
@@ -175,8 +182,16 @@ bool IsAutoRotationEnabled() {
 }
 
 bool IsInternalCamera(VideoFacingMode facing) {
-  return facing == MEDIA_VIDEO_FACING_USER ||
-         facing == MEDIA_VIDEO_FACING_ENVIRONMENT;
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    return true;
+  }
+
+  if (facing == MEDIA_VIDEO_FACING_USER ||
+      facing == MEDIA_VIDEO_FACING_ENVIRONMENT) {
+    return true;
+  }
+
+  return false;
 }
 
 bool HasActiveInternalDisplayDevice(DISPLAY_DEVICE* internal_display_device) {
diff --git a/media/gpu/windows/d3d11_texture_wrapper_unittest.cc b/media/gpu/windows/d3d11_texture_wrapper_unittest.cc
index ad32cd3c67e6f..41d49157e79a6 100644
--- a/media/gpu/windows/d3d11_texture_wrapper_unittest.cc
+++ b/media/gpu/windows/d3d11_texture_wrapper_unittest.cc
@@ -11,6 +11,7 @@
 #include "base/memory/raw_ptr.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
 #include "media/gpu/test/fake_command_buffer_helper.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -29,9 +30,18 @@ using ::testing::Values;
 
 namespace media {
 
+#define STOP_IF_WIN7()                                       \
+  do {                                                       \
+    if (base::win::GetVersion() <= base::win::Version::WIN7) \
+      return;                                                \
+  } while (0);
+
 class D3D11TextureWrapperUnittest : public ::testing::Test {
  public:
   void SetUp() override {
+    // Surface creation fails sometimes on win7, mostly.  Just skip the test.
+    STOP_IF_WIN7();
+
     task_runner_ = task_environment_.GetMainThreadTaskRunner();
 
     display_ = gl::GLSurfaceTestSupport::InitializeOneOffImplementation(
@@ -51,6 +61,7 @@ class D3D11TextureWrapperUnittest : public ::testing::Test {
   }
 
   void TearDown() override {
+    STOP_IF_WIN7();
     context_->ReleaseCurrent(surface_.get());
     context_ = nullptr;
     share_group_ = nullptr;
@@ -77,6 +88,7 @@ class D3D11TextureWrapperUnittest : public ::testing::Test {
 };
 
 TEST_F(D3D11TextureWrapperUnittest, NV12InitSucceeds) {
+  STOP_IF_WIN7();
   const DXGI_FORMAT dxgi_format = DXGI_FORMAT_NV12;
 
   auto wrapper = std::make_unique<DefaultTexture2DWrapper>(size_, dxgi_format);
@@ -88,6 +100,7 @@ TEST_F(D3D11TextureWrapperUnittest, NV12InitSucceeds) {
 }
 
 TEST_F(D3D11TextureWrapperUnittest, BGRA8InitSucceeds) {
+  STOP_IF_WIN7();
   const DXGI_FORMAT dxgi_format = DXGI_FORMAT_B8G8R8A8_UNORM;
 
   auto wrapper = std::make_unique<DefaultTexture2DWrapper>(size_, dxgi_format);
@@ -97,6 +110,7 @@ TEST_F(D3D11TextureWrapperUnittest, BGRA8InitSucceeds) {
 }
 
 TEST_F(D3D11TextureWrapperUnittest, FP16InitSucceeds) {
+  STOP_IF_WIN7();
   const DXGI_FORMAT dxgi_format = DXGI_FORMAT_R16G16B16A16_FLOAT;
 
   auto wrapper = std::make_unique<DefaultTexture2DWrapper>(size_, dxgi_format);
@@ -106,6 +120,7 @@ TEST_F(D3D11TextureWrapperUnittest, FP16InitSucceeds) {
 }
 
 TEST_F(D3D11TextureWrapperUnittest, P010InitSucceeds) {
+  STOP_IF_WIN7();
   const DXGI_FORMAT dxgi_format = DXGI_FORMAT_P010;
 
   auto wrapper = std::make_unique<DefaultTexture2DWrapper>(size_, dxgi_format);
@@ -115,6 +130,7 @@ TEST_F(D3D11TextureWrapperUnittest, P010InitSucceeds) {
 }
 
 TEST_F(D3D11TextureWrapperUnittest, UnknownInitFails) {
+  STOP_IF_WIN7();
   const DXGI_FORMAT dxgi_format = DXGI_FORMAT_UNKNOWN;
 
   auto wrapper = std::make_unique<DefaultTexture2DWrapper>(size_, dxgi_format);
diff --git a/media/gpu/windows/d3d11_video_decoder_unittest.cc b/media/gpu/windows/d3d11_video_decoder_unittest.cc
index a38caf9e5bd32..25ae66f0246bf 100644
--- a/media/gpu/windows/d3d11_video_decoder_unittest.cc
+++ b/media/gpu/windows/d3d11_video_decoder_unittest.cc
@@ -8,11 +8,8 @@
 #include <d3d11_1.h>
 #include <initguid.h>
 
-#include <memory>
-#include <utility>
-
-#include "base/functional/bind.h"
-#include "base/functional/callback_helpers.h"
+#include "base/bind.h"
+#include "base/callback_helpers.h"
 #include "base/memory/ptr_util.h"
 #include "base/memory/raw_ptr.h"
 #include "base/run_loop.h"
@@ -20,6 +17,7 @@
 #include "base/test/scoped_feature_list.h"
 #include "base/test/task_environment.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "media/base/decoder_buffer.h"
 #include "media/base/media_log.h"
 #include "media/base/media_switches.h"
@@ -266,7 +264,12 @@ TEST_F(D3D11VideoDecoderTest, SupportsVP9Profile0WithDecoderEnabled) {
 
   EnableDecoder(D3D11_DECODER_PROFILE_VP9_VLD_PROFILE0);
   CreateDecoder();
-  InitializeDecoder(configuration, /*expectSuccess=*/true);
+  // We don't support vp9 on windows 7 and below.
+  if (base::win::GetVersion() <= base::win::Version::WIN7) {
+    InitializeDecoder(configuration, false);
+  } else {
+    InitializeDecoder(configuration, true);
+  }
 }
 
 TEST_F(D3D11VideoDecoderTest, DoesNotSupportVP9WithGPUWorkaroundDisableVPX) {
@@ -276,7 +279,7 @@ TEST_F(D3D11VideoDecoderTest, DoesNotSupportVP9WithGPUWorkaroundDisableVPX) {
 
   EnableDecoder(D3D11_DECODER_PROFILE_VP9_VLD_PROFILE0);
   CreateDecoder();
-  InitializeDecoder(configuration, /*expectSuccess=*/false);
+  InitializeDecoder(configuration, false);
 }
 
 TEST_F(D3D11VideoDecoderTest, DoesNotSupportVP9WithoutDecoderEnabled) {
diff --git a/media/gpu/windows/dxva_video_decode_accelerator_win.cc b/media/gpu/windows/dxva_video_decode_accelerator_win.cc
index eaf93b8a0acb8..222c2e7a59ab6 100644
--- a/media/gpu/windows/dxva_video_decode_accelerator_win.cc
+++ b/media/gpu/windows/dxva_video_decode_accelerator_win.cc
@@ -17,8 +17,6 @@
 
 #include <algorithm>
 #include <memory>
-#include <string>
-#include <utility>
 
 #include "base/atomicops.h"
 #include "base/base_paths_win.h"
@@ -38,6 +36,7 @@
 #include "base/threading/thread_local_storage.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/scoped_co_mem.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "components/viz/common/resources/resource_format_utils.h"
 #include "gpu/command_buffer/common/shared_image_usage.h"
@@ -764,8 +763,23 @@ bool DXVAVideoDecodeAccelerator::Initialize(const Config& config,
     return false;
   }
 
-  // mfplat.dll provides the MFCreateDXGIDeviceManager API.
+// On Windows 8+ mfplat.dll provides the MFCreateDXGIDeviceManager API.
+// On Windows 7 mshtmlmedia.dll provides it.
 
+// TODO(ananta)
+// The code below works, as in we can create the DX11 device manager for
+// Windows 7. However the IMFTransform we use for texture conversion and
+// copy does not exist on Windows 7. Look into an alternate approach
+// and enable the code below.
+#if defined(ENABLE_DX11_FOR_WIN7)
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    dxgi_manager_dll = ::GetModuleHandle(L"mshtmlmedia.dll");
+    if (!dxgi_manager_dll) {
+      LOG(ERROR) << "DXVAVDA fatal error: Could not load mshtmlmedia.dll";
+      return false;
+    }
+  }
+#endif
   // If we don't find the MFCreateDXGIDeviceManager API we fallback to D3D9
   // decoding.
   if (dxgi_manager_dll && !create_dxgi_device_manager_) {
@@ -1429,8 +1443,15 @@ void DXVAVideoDecodeAccelerator::PreSandboxInitialization() {
   if (!::LoadLibrary(L"dxva2.dll"))
     PLOG(ERROR) << "DXVAVDA fatal error: could not LoadLibrary: dxva2.dll";
 
-  if (!LoadLibrary(L"msvproc.dll")) {
-    PLOG(ERROR) << "DXVAVDA fatal error: could not LoadLibrary: msvproc.dll";
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    if (!LoadLibrary(L"msvproc.dll"))
+      PLOG(ERROR) << "DXVAVDA fatal error: could not LoadLibrary: msvproc.dll";
+  } else {
+#if defined(ENABLE_DX11_FOR_WIN7)
+    if (!LoadLibrary(L"mshtmlmedia.dll"))
+      PLOG(ERROR)
+          << "DXVAVDA fatal error: could not LoadLibrary: mshtmlmedia.dll";
+#endif
   }
 }
 
diff --git a/media/gpu/windows/media_foundation_video_encode_accelerator_win.cc b/media/gpu/windows/media_foundation_video_encode_accelerator_win.cc
index 88ef5754c140c..064f0e5a06fb6 100644
--- a/media/gpu/windows/media_foundation_video_encode_accelerator_win.cc
+++ b/media/gpu/windows/media_foundation_video_encode_accelerator_win.cc
@@ -27,6 +27,7 @@
 #include "base/trace_event/trace_event.h"
 #include "base/win/scoped_co_mem.h"
 #include "base/win/scoped_variant.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "gpu/ipc/common/dxgi_helpers.h"
 #include "media/base/bitstream_buffer.h"
@@ -37,13 +38,13 @@
 #include "media/base/win/mf_helpers.h"
 #include "media/base/win/mf_initializer.h"
 #include "media/gpu/gpu_video_encode_accelerator_helpers.h"
-#include "media/gpu/windows/vp9_video_rate_control_wrapper.h"
 #include "third_party/libvpx/source/libvpx/vp9/ratectrl_rtc.h"
 #include "third_party/libyuv/include/libyuv.h"
 #include "ui/gfx/color_space_win.h"
 #include "ui/gfx/gpu_memory_buffer.h"
+#include "vp9_video_rate_control_wrapper.h"
 #if BUILDFLAG(ENABLE_LIBAOM)
-#include "media/gpu/windows/av1_video_rate_control_wrapper.h"
+#include "av1_video_rate_control_wrapper.h"
 #include "third_party/libaom/source/libaom/av1/ratectrl_rtc.h"
 #endif
 
@@ -112,8 +113,13 @@ eAVEncH264VProfile GetH264VProfile(VideoCodecProfile profile,
                                  : eAVEncH264VProfile_Base;
     case H264PROFILE_MAIN:
       return eAVEncH264VProfile_Main;
-    case H264PROFILE_HIGH:
+    case H264PROFILE_HIGH: {
+      // eAVEncH264VProfile_High requires Windows 8.
+      if (base::win::GetVersion() < base::win::Version::WIN8) {
+        return eAVEncH264VProfile_unknown;
+      }
       return eAVEncH264VProfile_High;
+    }
     default:
       return eAVEncH264VProfile_unknown;
   }
@@ -249,9 +255,15 @@ MediaFoundationVideoEncodeAccelerator::DriverVendor GetDriverVendor(
 }
 
 uint32_t EnumerateHardwareEncoders(VideoCodec codec,
-                                   IMFActivate*** pp_activate) {
+                                   IMFActivate*** pp_activate,
+                                   bool compatible_with_win7) {
   DVLOG(3) << __func__;
 
+  if (!compatible_with_win7 &&
+      base::win::GetVersion() < base::win::Version::WIN8) {
+    return 0;
+  }
+
   if (codec != VideoCodec::kH264 && codec != VideoCodec::kVP9 &&
       codec != VideoCodec::kAV1
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC)
@@ -405,11 +417,16 @@ struct MediaFoundationVideoEncodeAccelerator::BitstreamBufferRef {
   const size_t size;
 };
 
+// TODO(zijiehe): Respect |compatible_with_win7_| in the implementation. Some
+// attributes are not supported by Windows 7, setting them will return errors.
+// See bug: http://crbug.com/777659.
 MediaFoundationVideoEncodeAccelerator::MediaFoundationVideoEncodeAccelerator(
     const gpu::GpuPreferences& gpu_preferences,
     const gpu::GpuDriverBugWorkarounds& gpu_workarounds,
     CHROME_LUID luid)
-    : frame_rate_(kMaxFrameRateNumerator / kMaxFrameRateDenominator),
+    : compatible_with_win7_(
+          gpu_preferences.enable_media_foundation_vea_on_windows7),
+      frame_rate_(kMaxFrameRateNumerator / kMaxFrameRateDenominator),
       bitrate_allocation_(Bitrate::Mode::kConstant),
       input_required_(false),
       main_client_task_runner_(base::SequencedTaskRunner::GetCurrentDefault()),
@@ -466,7 +483,8 @@ MediaFoundationVideoEncodeAccelerator::GetSupportedProfilesForCodec(
   }
 
   IMFActivate** pp_activate = nullptr;
-  uint32_t encoder_count = EnumerateHardwareEncoders(codec, &pp_activate);
+  uint32_t encoder_count =
+      EnumerateHardwareEncoders(codec, &pp_activate, compatible_with_win7_);
   if (!encoder_count) {
     DVLOG(1)
         << "Hardware encode acceleration is not available on this platform for "
@@ -643,7 +661,8 @@ void MediaFoundationVideoEncodeAccelerator::EncoderInitializeTask(
   HRESULT hr = S_OK;
   IMFActivate** pp_activates = nullptr;
 
-  uint32_t encoder_count = EnumerateHardwareEncoders(codec_, &pp_activates);
+  uint32_t encoder_count =
+      EnumerateHardwareEncoders(codec_, &pp_activates, compatible_with_win7_);
   NOTIFY_RETURN_ON_FAILURE(encoder_count == 0,
                            "Failed finding a hardware encoder MFT.", );
 
@@ -1059,7 +1078,13 @@ bool MediaFoundationVideoEncodeAccelerator::SetEncoderModes() {
     }
   }
   hr = codec_api_->SetValue(&CODECAPI_AVEncCommonRateControlMode, &var);
-  RETURN_ON_HR_FAILURE(hr, "Couldn't set CommonRateControlMode", false);
+  if (!compatible_with_win7_) {
+    // Though CODECAPI_AVEncCommonRateControlMode is supported by Windows 7, but
+    // according to a discussion on MSDN,
+    // https://social.msdn.microsoft.com/Forums/windowsdesktop/en-US/6da521e9-7bb3-4b79-a2b6-b31509224638/win7-h264-encoder-imfsinkwriter-cant-use-quality-vbr-encoding?forum=mediafoundationdevelopment
+    // setting it on Windows 7 returns error.
+    RETURN_ON_HR_FAILURE(hr, "Couldn't set CommonRateControlMode", false);
+  }
 
   // Intel drivers want the layer count to be set explicitly for H.264/HEVC,
   // even if it's one.
@@ -1070,27 +1095,35 @@ bool MediaFoundationVideoEncodeAccelerator::SetEncoderModes() {
   if (set_svc_layer_count) {
     var.ulVal = num_temporal_layers_;
     hr = codec_api_->SetValue(&CODECAPI_AVEncVideoTemporalLayerCount, &var);
-    RETURN_ON_HR_FAILURE(hr, "Couldn't set temporal layer count", false);
+    if (!compatible_with_win7_) {
+      RETURN_ON_HR_FAILURE(hr, "Couldn't set temporal layer count", false);
+    }
   }
 
   if (!rate_ctrl_) {
     var.ulVal = AdjustBitrateToFrameRate(bitrate_allocation_.GetSumBps(),
                                          configured_frame_rate_, frame_rate_);
     hr = codec_api_->SetValue(&CODECAPI_AVEncCommonMeanBitRate, &var);
-    RETURN_ON_HR_FAILURE(hr, "Couldn't set bitrate", false);
+    if (!compatible_with_win7_) {
+      RETURN_ON_HR_FAILURE(hr, "Couldn't set bitrate", false);
+    }
   }
 
   if (bitrate_allocation_.GetMode() == Bitrate::Mode::kVariable) {
     var.ulVal = AdjustBitrateToFrameRate(bitrate_allocation_.GetPeakBps(),
                                          configured_frame_rate_, frame_rate_);
     hr = codec_api_->SetValue(&CODECAPI_AVEncCommonMaxBitRate, &var);
-    RETURN_ON_HR_FAILURE(hr, "Couldn't set bitrate", false);
+    if (!compatible_with_win7_) {
+      RETURN_ON_HR_FAILURE(hr, "Couldn't set bitrate", false);
+    }
   }
 
   if (S_OK == codec_api_->IsModifiable(&CODECAPI_AVEncAdaptiveMode)) {
     var.ulVal = eAVEncAdaptiveMode_Resolution;
     hr = codec_api_->SetValue(&CODECAPI_AVEncAdaptiveMode, &var);
-    RETURN_ON_HR_FAILURE(hr, "Couldn't set adaptive mode", false);
+    if (!compatible_with_win7_) {
+      RETURN_ON_HR_FAILURE(hr, "Couldn't set adaptive mode", false);
+    }
   }
 
   var.ulVal = gop_length_;
@@ -1101,7 +1134,9 @@ bool MediaFoundationVideoEncodeAccelerator::SetEncoderModes() {
     var.vt = VT_BOOL;
     var.boolVal = low_latency_mode_ ? VARIANT_TRUE : VARIANT_FALSE;
     hr = codec_api_->SetValue(&CODECAPI_AVLowLatencyMode, &var);
-    RETURN_ON_HR_FAILURE(hr, "Couldn't set low latency mode", false);
+    if (!compatible_with_win7_) {
+      RETURN_ON_HR_FAILURE(hr, "Couldn't set low latency mode", false);
+    }
   }
 
   return true;
@@ -1193,7 +1228,7 @@ HRESULT MediaFoundationVideoEncodeAccelerator::ProcessInput(
     var.vt = VT_UI4;
     var.ulVal = 1;
     hr = codec_api_->SetValue(&CODECAPI_AVEncVideoForceKeyFrame, &var);
-    if (FAILED(hr)) {
+    if (!compatible_with_win7_ && FAILED(hr)) {
       LOG(WARNING) << "Failed to set CODECAPI_AVEncVideoForceKeyFrame, "
                       "HRESULT: 0x"
                    << std::hex << hr;
@@ -1836,13 +1871,17 @@ void MediaFoundationVideoEncodeAccelerator::RequestEncodingParametersChangeTask(
   var.ulVal = AdjustBitrateToFrameRate(bitrate_allocation_.GetSumBps(),
                                        configured_frame_rate_, framerate);
   HRESULT hr = codec_api_->SetValue(&CODECAPI_AVEncCommonMeanBitRate, &var);
-  RETURN_ON_HR_FAILURE(hr, "Couldn't update mean bitrate", );
+  if (!compatible_with_win7_) {
+    RETURN_ON_HR_FAILURE(hr, "Couldn't update mean bitrate", );
+  }
 
   if (bitrate_allocation_.GetMode() == Bitrate::Mode::kVariable) {
     var.ulVal = AdjustBitrateToFrameRate(bitrate_allocation_.GetPeakBps(),
                                          configured_frame_rate_, framerate);
     hr = codec_api_->SetValue(&CODECAPI_AVEncCommonMaxBitRate, &var);
-    RETURN_ON_HR_FAILURE(hr, "Couldn't set max bitrate", );
+    if (!compatible_with_win7_) {
+      RETURN_ON_HR_FAILURE(hr, "Couldn't set max bitrate", );
+    }
   }
 }
 
diff --git a/media/gpu/windows/media_foundation_video_encode_accelerator_win.h b/media/gpu/windows/media_foundation_video_encode_accelerator_win.h
index 1ac8e2d52a2b3..9fa4d517e10cd 100644
--- a/media/gpu/windows/media_foundation_video_encode_accelerator_win.h
+++ b/media/gpu/windows/media_foundation_video_encode_accelerator_win.h
@@ -165,6 +165,8 @@ class MEDIA_GPU_EXPORT MediaFoundationVideoEncodeAccelerator
   // Perform D3D11 scaling operation
   HRESULT PerformD3DScaling(ID3D11Texture2D* input_texture);
 
+  const bool compatible_with_win7_;
+
   // Bitstream buffers ready to be used to return encoded output as a FIFO.
   base::circular_deque<std::unique_ptr<BitstreamBufferRef>>
       bitstream_buffer_queue_;
diff --git a/media/gpu/windows/mf_audio_encoder.cc b/media/gpu/windows/mf_audio_encoder.cc
index aa54a0a573edf..d87c9a8301f75 100644
--- a/media/gpu/windows/mf_audio_encoder.cc
+++ b/media/gpu/windows/mf_audio_encoder.cc
@@ -13,7 +13,6 @@
 #include <wmcodecdsp.h>
 #include <wrl/client.h>
 
-#include <algorithm>
 #include <utility>
 
 #include "base/containers/contains.h"
@@ -27,6 +26,7 @@
 #include "base/win/com_init_util.h"
 #include "base/win/scoped_co_mem.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "media/base/audio_buffer.h"
 #include "media/base/audio_parameters.h"
 #include "media/base/audio_timestamp_helper.h"
@@ -92,8 +92,12 @@ EncoderStatus::Codes ValidateInputOptions(const AudioEncoder::Options& options,
       *channel_layout = CHANNEL_LAYOUT_STEREO;
       break;
     case 6:
-      *channel_layout = CHANNEL_LAYOUT_5_1;
-      break;
+      // 5.1 is only supported by the MF AAC encoder on Win10+.
+      if (base::win::GetVersion() >= base::win::Version::WIN10) {
+        *channel_layout = CHANNEL_LAYOUT_5_1;
+        break;
+      }
+      [[fallthrough]];
     default:
       return EncoderStatus::Codes::kEncoderUnsupportedConfig;
   }
@@ -173,9 +177,12 @@ HRESULT CreateOutputMediaType(const int sample_rate,
   RETURN_IF_FAILED(media_type->SetUINT32(MF_MT_AUDIO_AVG_BYTES_PER_SECOND,
                                          adjusted_bitrate / 8));
 
-  // The encoder can produce ADTS headers for us if we set the payload
-  // type to 1.
-  RETURN_IF_FAILED(media_type->SetUINT32(MF_MT_AAC_PAYLOAD_TYPE, 1));
+  // On Win8+, the encoder can produce ADTS headers for us if we set the payload
+  // type to 1. On Win7, only raw AAC frames are produced.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    RETURN_IF_FAILED(media_type->SetUINT32(MF_MT_AAC_PAYLOAD_TYPE, 1));
+  else
+    RETURN_IF_FAILED(media_type->SetUINT32(MF_MT_AAC_PAYLOAD_TYPE, 0));
 
   *output_media_type = std::move(media_type);
   return S_OK;
diff --git a/media/gpu/windows/supported_profile_helpers.cc b/media/gpu/windows/supported_profile_helpers.cc
index fc08fb786b066..a95e4b778e512 100644
--- a/media/gpu/windows/supported_profile_helpers.cc
+++ b/media/gpu/windows/supported_profile_helpers.cc
@@ -120,6 +120,9 @@ SupportedResolutionRangeMap GetSupportedD3D11VideoDecoderResolutions(
   for (const auto profile : kSupportedH264Profiles)
     supported_resolutions[profile] = h264_profile;
 
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return supported_resolutions;
+
   if (!device)
     return supported_resolutions;
 
diff --git a/media/gpu/windows/supported_profile_helpers_unittest.cc b/media/gpu/windows/supported_profile_helpers_unittest.cc
index 2470088d66db0..e127d6785ffe1 100644
--- a/media/gpu/windows/supported_profile_helpers_unittest.cc
+++ b/media/gpu/windows/supported_profile_helpers_unittest.cc
@@ -9,9 +9,9 @@
 #include <initguid.h>
 #include <map>
 #include <utility>
-#include <vector>
 
 #include "base/test/scoped_feature_list.h"
+#include "base/win/windows_version.h"
 #include "media/base/media_switches.h"
 #include "media/base/test_helpers.h"
 #include "media/base/win/d3d11_mocks.h"
@@ -26,6 +26,12 @@ using ::testing::Return;
 using ::testing::SetArgPointee;
 using ::testing::WithArgs;
 
+#define DONT_RUN_ON_WIN_7()                                  \
+  do {                                                       \
+    if (base::win::GetVersion() <= base::win::Version::WIN7) \
+      return;                                                \
+  } while (0)
+
 namespace {
 
 using PciId = std::pair<uint16_t, uint16_t>;
@@ -165,6 +171,8 @@ class SupportedResolutionResolverTest : public ::testing::Test {
 };
 
 TEST_F(SupportedResolutionResolverTest, WorkaroundsDisableAv1) {
+  DONT_RUN_ON_WIN_7();
+
   // Enable the av1 decoder.
   EnableDecoders({DXVA_ModeAV1_VLD_Profile0});
   SetMaxResolution(DXVA_ModeAV1_VLD_Profile0, kSquare8k);
@@ -179,6 +187,7 @@ TEST_F(SupportedResolutionResolverTest, WorkaroundsDisableAv1) {
 }
 
 TEST_F(SupportedResolutionResolverTest, HasH264SupportByDefault) {
+  DONT_RUN_ON_WIN_7();
   AssertDefaultSupport(
       GetSupportedD3D11VideoDecoderResolutions(nullptr, gpu_workarounds_));
 
@@ -192,6 +201,8 @@ TEST_F(SupportedResolutionResolverTest, HasH264SupportByDefault) {
 }
 
 TEST_F(SupportedResolutionResolverTest, WorkaroundsDisableVpx) {
+  DONT_RUN_ON_WIN_7();
+
   gpu_workarounds_.disable_accelerated_vp8_decode = true;
   gpu_workarounds_.disable_accelerated_vp9_decode = true;
   EnableDecoders({D3D11_DECODER_PROFILE_VP8_VLD,
@@ -203,6 +214,8 @@ TEST_F(SupportedResolutionResolverTest, WorkaroundsDisableVpx) {
 }
 
 TEST_F(SupportedResolutionResolverTest, WorkaroundsDisableVp92) {
+  DONT_RUN_ON_WIN_7();
+
   gpu_workarounds_.disable_accelerated_vp9_profile2_decode = true;
   EnableDecoders({D3D11_DECODER_PROFILE_VP8_VLD,
                   D3D11_DECODER_PROFILE_VP9_VLD_PROFILE0,
@@ -220,6 +233,8 @@ TEST_F(SupportedResolutionResolverTest, WorkaroundsDisableVp92) {
 }
 
 TEST_F(SupportedResolutionResolverTest, H264Supports4k) {
+  DONT_RUN_ON_WIN_7();
+
   EnableDecoders({D3D11_DECODER_PROFILE_H264_VLD_NOFGT});
   const auto supported_resolutions = GetSupportedD3D11VideoDecoderResolutions(
       mock_d3d11_device_, gpu_workarounds_);
@@ -235,6 +250,8 @@ TEST_F(SupportedResolutionResolverTest, H264Supports4k) {
 }
 
 TEST_F(SupportedResolutionResolverTest, VP8Supports4k) {
+  DONT_RUN_ON_WIN_7();
+
   base::test::ScopedFeatureList scoped_feature_list;
   scoped_feature_list.InitAndEnableFeature(kMediaFoundationVP8Decoding);
 
@@ -253,16 +270,20 @@ TEST_F(SupportedResolutionResolverTest, VP8Supports4k) {
 }
 
 TEST_F(SupportedResolutionResolverTest, VP9Profile0Supports8k) {
+  DONT_RUN_ON_WIN_7();
   TestDecoderSupport(D3D11_DECODER_PROFILE_VP9_VLD_PROFILE0,
                      VP9PROFILE_PROFILE0, kSquare8k, kSquare8k, kSquare8k);
 }
 
 TEST_F(SupportedResolutionResolverTest, VP9Profile2Supports8k) {
+  DONT_RUN_ON_WIN_7();
   TestDecoderSupport(D3D11_DECODER_PROFILE_VP9_VLD_10BIT_PROFILE2,
                      VP9PROFILE_PROFILE2, kSquare8k, kSquare8k, kSquare8k);
 }
 
 TEST_F(SupportedResolutionResolverTest, MultipleCodecs) {
+  DONT_RUN_ON_WIN_7();
+
   SetGpuProfile(kRecentAmdGpu);
 
   // H.264 and VP9.0 are the most common supported codecs.
@@ -291,22 +312,26 @@ TEST_F(SupportedResolutionResolverTest, MultipleCodecs) {
 }
 
 TEST_F(SupportedResolutionResolverTest, AV1ProfileMainSupports8k) {
+  DONT_RUN_ON_WIN_7();
   TestDecoderSupport(DXVA_ModeAV1_VLD_Profile0, AV1PROFILE_PROFILE_MAIN,
                      kSquare8k, kSquare8k, kSquare8k);
 }
 
 TEST_F(SupportedResolutionResolverTest, AV1ProfileHighSupports8k) {
+  DONT_RUN_ON_WIN_7();
   TestDecoderSupport(DXVA_ModeAV1_VLD_Profile1, AV1PROFILE_PROFILE_HIGH,
                      kSquare8k, kSquare8k, kSquare8k);
 }
 
 TEST_F(SupportedResolutionResolverTest, AV1ProfileProSupports8k) {
+  DONT_RUN_ON_WIN_7();
   TestDecoderSupport(DXVA_ModeAV1_VLD_Profile2, AV1PROFILE_PROFILE_PRO,
                      kSquare8k, kSquare8k, kSquare8k);
 }
 
 #if BUILDFLAG(ENABLE_HEVC_PARSER_AND_HW_DECODER)
 TEST_F(SupportedResolutionResolverTest, H265Supports8kIfEnabled) {
+  DONT_RUN_ON_WIN_7();
   EnableDecoders({D3D11_DECODER_PROFILE_HEVC_VLD_MAIN});
   SetMaxResolution(D3D11_DECODER_PROFILE_HEVC_VLD_MAIN, kSquare8k);
   const auto resolutions_for_feature = GetSupportedD3D11VideoDecoderResolutions(
diff --git a/media/midi/midi_manager_win.cc b/media/midi/midi_manager_win.cc
index b11d74cd70956..b1f037a687181 100644
--- a/media/midi/midi_manager_win.cc
+++ b/media/midi/midi_manager_win.cc
@@ -30,6 +30,7 @@
 #include "base/synchronization/lock.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/time/time.h"
+#include "base/win/windows_version.h"
 #include "media/midi/message_util.h"
 #include "media/midi/midi_manager_winrt.h"
 #include "media/midi/midi_service.h"
@@ -892,7 +893,8 @@ void MidiManagerWin::SendOnTaskRunner(MidiManagerClient* client,
 }
 
 MidiManager* MidiManager::Create(MidiService* service) {
-  if (base::FeatureList::IsEnabled(features::kMidiManagerWinrt)) {
+  if (base::FeatureList::IsEnabled(features::kMidiManagerWinrt) &&
+      base::win::GetVersion() >= base::win::Version::WIN10) {
     return new MidiManagerWinrt(service);
   }
   return new MidiManagerWin(service);
diff --git a/media/mojo/services/gpu_mojo_media_client_win.cc b/media/mojo/services/gpu_mojo_media_client_win.cc
index 624f1950e4cc5..c0cadd497120e 100644
--- a/media/mojo/services/gpu_mojo_media_client_win.cc
+++ b/media/mojo/services/gpu_mojo_media_client_win.cc
@@ -7,6 +7,7 @@
 #include "base/task/sequenced_task_runner.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/thread_pool.h"
+#include "base/win/windows_version.h"
 #include "media/base/audio_decoder.h"
 #include "media/base/media_switches.h"
 #include "media/base/offloading_audio_encoder.h"
@@ -28,11 +29,17 @@ D3D11VideoDecoder::GetD3D11DeviceCB GetD3D11DeviceCallback() {
       []() { return gl::QueryD3D11DeviceObjectFromANGLE(); });
 }
 
+bool ShouldUseD3D11VideoDecoder(
+    const gpu::GpuDriverBugWorkarounds& gpu_workarounds) {
+  return !gpu_workarounds.disable_d3d11_video_decoder &&
+         base::win::GetVersion() > base::win::Version::WIN7;
+}
+
 }  // namespace
 
 std::unique_ptr<VideoDecoder> CreatePlatformVideoDecoder(
     VideoDecoderTraits& traits) {
-  if (traits.gpu_workarounds->disable_d3d11_video_decoder) {
+  if (!ShouldUseD3D11VideoDecoder(*traits.gpu_workarounds)) {
     if (traits.gpu_workarounds->disable_dxva_video_decoder)
       return nullptr;
     return VdaVideoDecoder::Create(
@@ -71,7 +78,7 @@ GetPlatformSupportedVideoDecoderConfigs(
   SupportedVideoDecoderConfigs supported_configs;
   if (gpu_preferences.disable_accelerated_video_decode)
     return supported_configs;
-  if (!gpu_workarounds.disable_d3d11_video_decoder) {
+  if (ShouldUseD3D11VideoDecoder(gpu_workarounds)) {
     supported_configs = D3D11VideoDecoder::GetSupportedVideoDecoderConfigs(
         gpu_preferences, gpu_workarounds, GetD3D11DeviceCallback());
   } else if (!gpu_workarounds.disable_dxva_video_decoder) {
@@ -93,8 +100,8 @@ VideoDecoderType GetPlatformDecoderImplementationType(
     gpu::GpuDriverBugWorkarounds gpu_workarounds,
     gpu::GpuPreferences gpu_preferences,
     const gpu::GPUInfo& gpu_info) {
-  return gpu_workarounds.disable_d3d11_video_decoder ? VideoDecoderType::kVda
-                                                     : VideoDecoderType::kD3D11;
+  return ShouldUseD3D11VideoDecoder(gpu_workarounds) ? VideoDecoderType::kD3D11
+                                                     : VideoDecoderType::kVda;
 }
 
 // There is no CdmFactory on windows, so just stub it out.
diff --git a/media/renderers/win/media_foundation_renderer.cc b/media/renderers/win/media_foundation_renderer.cc
index 6d659c6fc3fda..caf9ef8b367ae 100644
--- a/media/renderers/win/media_foundation_renderer.cc
+++ b/media/renderers/win/media_foundation_renderer.cc
@@ -10,7 +10,6 @@
 #include <memory>
 #include <string>
 #include <tuple>
-#include <utility>
 
 #include "base/functional/callback_helpers.h"
 #include "base/guid.h"
@@ -24,6 +23,7 @@
 #include "base/win/scoped_bstr.h"
 #include "base/win/scoped_hdc.h"
 #include "base/win/scoped_propvariant.h"
+#include "base/win/windows_version.h"
 #include "base/win/wrapped_window_proc.h"
 #include "media/base/bind_to_current_loop.h"
 #include "media/base/cdm_context.h"
@@ -110,6 +110,11 @@ void MediaFoundationRenderer::ReportErrorReason(ErrorReason reason) {
                                 reason);
 }
 
+// static
+bool MediaFoundationRenderer::IsSupported() {
+  return base::win::GetVersion() >= base::win::Version::WIN10;
+}
+
 MediaFoundationRenderer::MediaFoundationRenderer(
     scoped_refptr<base::SequencedTaskRunner> task_runner,
     std::unique_ptr<MediaLog> media_log,
@@ -516,7 +521,7 @@ void MediaFoundationRenderer::SetMediaFoundationRenderingMode(
                << " is unsupported";
       MEDIA_LOG(ERROR, media_log_)
           << "MediaFoundationRenderer SetMediaFoundationRenderingMode: "
-          << static_cast<int>(render_mode)
+          << (int)render_mode
           << " is not defined. No change to the rendering mode.";
       hr = E_NOT_SET;
     }
diff --git a/media/renderers/win/media_foundation_renderer.h b/media/renderers/win/media_foundation_renderer.h
index e3e3f544f1197..ef9e364ed9757 100644
--- a/media/renderers/win/media_foundation_renderer.h
+++ b/media/renderers/win/media_foundation_renderer.h
@@ -11,7 +11,6 @@
 #include <wrl.h>
 
 #include <memory>
-
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
@@ -69,6 +68,9 @@ class MEDIA_EXPORT MediaFoundationRenderer
   // Report `reason` to UMA.
   static void ReportErrorReason(ErrorReason reason);
 
+  // Whether MediaFoundationRenderer() is supported on the current device.
+  static bool IsSupported();
+
   MediaFoundationRenderer(scoped_refptr<base::SequencedTaskRunner> task_runner,
                           std::unique_ptr<MediaLog> media_log,
                           LUID gpu_process_adapter_luid,
diff --git a/media/renderers/win/media_foundation_renderer_integration_test.cc b/media/renderers/win/media_foundation_renderer_integration_test.cc
index bc4e1a3b4f2be..fa6c37f06e004 100644
--- a/media/renderers/win/media_foundation_renderer_integration_test.cc
+++ b/media/renderers/win/media_foundation_renderer_integration_test.cc
@@ -4,10 +4,10 @@
 
 #include "media/renderers/win/media_foundation_renderer.h"
 
-#include <mfapi.h>
-
 #include <memory>
 
+#include <mfapi.h>
+
 #include "base/win/windows_version.h"
 #include "media/base/media_util.h"
 #include "media/test/pipeline_integration_test_base.h"
@@ -20,6 +20,11 @@ namespace {
 // TODO(xhwang): Generalize this to support more codecs, or use CanPlay() or
 // IsTypeSupported() which can take mime types directly.
 bool CanDecodeVp9() {
+  if (!MediaFoundationRenderer::IsSupported()) {
+    LOG(WARNING) << "MediaFoundationRenderer not supported";
+    return false;
+  }
+
   MFT_REGISTER_TYPE_INFO input_type = {MFMediaType_Video, MFVideoFormat_VP90};
   IMFActivate** activates = nullptr;
   UINT32 count = 0;
@@ -32,9 +37,8 @@ bool CanDecodeVp9() {
     return false;
   }
 
-  for (UINT32 i = 0; i < count; ++i) {
+  for (UINT32 i = 0; i < count; ++i)
     activates[i]->Release();
-  }
   CoTaskMemFree(activates);
 
   if (count == 0) {
diff --git a/media/renderers/win/media_foundation_renderer_unittest.cc b/media/renderers/win/media_foundation_renderer_unittest.cc
index 80f8a5c98e5f9..a2dbc4515bf45 100644
--- a/media/renderers/win/media_foundation_renderer_unittest.cc
+++ b/media/renderers/win/media_foundation_renderer_unittest.cc
@@ -6,11 +6,8 @@
 
 #include <windows.media.protection.h>
 
-#include <memory>
-#include <vector>
-
-#include "base/functional/bind.h"
-#include "base/functional/callback_helpers.h"
+#include "base/bind.h"
+#include "base/callback_helpers.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/test/mock_callback.h"
@@ -97,6 +94,9 @@ class MockMediaProtectionPMPServer
 class MediaFoundationRendererTest : public testing::Test {
  public:
   MediaFoundationRendererTest() {
+    if (!MediaFoundationRenderer::IsSupported())
+      return;
+
     mf_cdm_proxy_ =
         base::MakeRefCounted<NiceMock<MockMediaFoundationCdmProxy>>();
 
@@ -172,6 +172,9 @@ class MediaFoundationRendererTest : public testing::Test {
 };
 
 TEST_F(MediaFoundationRendererTest, VerifyInitWithoutSetCdm) {
+  if (!MediaFoundationRenderer::IsSupported())
+    return;
+
   AddStream(DemuxerStream::AUDIO, /*encrypted=*/false);
   AddStream(DemuxerStream::VIDEO, /*encrypted=*/true);
 
@@ -184,6 +187,9 @@ TEST_F(MediaFoundationRendererTest, VerifyInitWithoutSetCdm) {
 }
 
 TEST_F(MediaFoundationRendererTest, SetCdmThenInit) {
+  if (!MediaFoundationRenderer::IsSupported())
+    return;
+
   AddStream(DemuxerStream::AUDIO, /*encrypted=*/true);
   AddStream(DemuxerStream::VIDEO, /*encrypted=*/true);
 
@@ -198,6 +204,9 @@ TEST_F(MediaFoundationRendererTest, SetCdmThenInit) {
 }
 
 TEST_F(MediaFoundationRendererTest, InitThenSetCdm) {
+  if (!MediaFoundationRenderer::IsSupported())
+    return;
+
   AddStream(DemuxerStream::AUDIO, /*encrypted=*/true);
   AddStream(DemuxerStream::VIDEO, /*encrypted=*/true);
 
@@ -212,6 +221,9 @@ TEST_F(MediaFoundationRendererTest, InitThenSetCdm) {
 }
 
 TEST_F(MediaFoundationRendererTest, DirectCompositionHandle) {
+  if (!MediaFoundationRenderer::IsSupported())
+    return;
+
   base::MockCallback<MediaFoundationRendererExtension::GetDCompSurfaceCB>
       get_dcomp_surface_cb;
 
@@ -233,9 +245,13 @@ TEST_F(MediaFoundationRendererTest, DirectCompositionHandle) {
 }
 
 TEST_F(MediaFoundationRendererTest, ClearStartsInFrameServer) {
+  if (!MediaFoundationRenderer::IsSupported())
+    return;
+
   base::test::ScopedFeatureList feature_list;
   feature_list.InitAndEnableFeatureWithParameters(
       media::kMediaFoundationClearRendering, {{"strategy", "dynamic"}});
+  ;
 
   AddStream(DemuxerStream::AUDIO, /*encrypted=*/false);
   AddStream(DemuxerStream::VIDEO, /*encrypted=*/false);
@@ -247,6 +263,9 @@ TEST_F(MediaFoundationRendererTest, ClearStartsInFrameServer) {
 }
 
 TEST_F(MediaFoundationRendererTest, EncryptedStaysInDirectComposition) {
+  if (!MediaFoundationRenderer::IsSupported())
+    return;
+
   AddStream(DemuxerStream::AUDIO, /*encrypted=*/true);
   AddStream(DemuxerStream::VIDEO, /*encrypted=*/true);
 
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
index b8e39cc233157..59f34a5fcee7d 100644
--- a/mojo/core/embedder/embedder.cc
+++ b/mojo/core/embedder/embedder.cc
@@ -34,7 +34,12 @@
         // BUILDFLAG(IS_ANDROID)
 #endif  // !BUILDFLAG(IS_NACL)
 
-namespace mojo::core {
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
+namespace mojo {
+namespace core {
 
 namespace {
 
@@ -75,12 +80,23 @@ void InitFeatures() {
       base::FeatureList::IsEnabled(kMojoAvoidRandomPipeId));
 
   if (base::FeatureList::IsEnabled(kMojoIpcz)) {
-    EnableMojoIpcz();
+    EnableMojoIpczIfSupported();
   }
 }
 
-void EnableMojoIpcz() {
-  g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+void EnableMojoIpczIfSupported() {
+#if BUILDFLAG(IS_WIN)
+  // TODO(https://crbug.com/1299283): Sandboxed processes on Windows versions
+  // older than 8.1 require some extra (not yet implemented) setup for ipcz to
+  // work properly. This is omitted for early experimentation.
+  const bool kIsIpczSupported =
+      base::win::GetVersion() >= base::win::Version::WIN8_1;
+#else
+  const bool kIsIpczSupported = true;
+#endif
+  if (kIsIpczSupported) {
+    g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+  }
 }
 
 void Init(const Configuration& configuration) {
@@ -161,4 +177,5 @@ IpczDriverHandle CreateIpczTransportFromEndpoint(
   return ipcz_driver::ObjectBase::ReleaseAsHandle(std::move(transport));
 }
 
-}  // namespace mojo::core
+}  // namespace core
+}  // namespace mojo
diff --git a/mojo/core/embedder/embedder.h b/mojo/core/embedder/embedder.h
index 2d31ced82a815..88645eff1b4e5 100644
--- a/mojo/core/embedder/embedder.h
+++ b/mojo/core/embedder/embedder.h
@@ -17,7 +17,8 @@
 #include "mojo/public/cpp/platform/platform_channel_endpoint.h"
 #include "third_party/ipcz/include/ipcz/ipcz.h"
 
-namespace mojo::core {
+namespace mojo {
+namespace core {
 
 // Basic configuration/initialization ------------------------------------------
 
@@ -50,13 +51,14 @@ scoped_refptr<base::SingleThreadTaskRunner> GetIOTaskRunner();
 // base::Features inside of Mojo.
 COMPONENT_EXPORT(MOJO_CORE_EMBEDDER) void InitFeatures();
 
-// Enables MojoIpcz. Called before Init() is called. Only call this if the
-// current program doesn't have base::FeatureList integration, since otherwise
-// InitFeatures() will do the work.
+// Enables MojoIpcz if it is supported on the current platform. Called before
+// Init() is called. Only call this if the current program doesn't have
+// base::FeatureList integration, since otherwise InitFeatures() will do the
+// work.
 //
 // TODO(crbug.com/1299283): Remove once MojoIpcz becomes the default
 // implementation.
-COMPONENT_EXPORT(MOJO_CORE_EMBEDDER) void EnableMojoIpcz();
+COMPONENT_EXPORT(MOJO_CORE_EMBEDDER) void EnableMojoIpczIfSupported();
 
 // Indicates whether the ipcz-based Mojo implementation is enabled. This can be
 // done by enabling the MojoIpcz feature.
@@ -88,6 +90,7 @@ IpczDriverHandle CreateIpczTransportFromEndpoint(
     const TransportEndpointTypes& endpoint_types,
     base::Process remote_process = base::Process());
 
-}  // namespace mojo::core
+}  // namespace core
+}  // namespace mojo
 
 #endif  // MOJO_CORE_EMBEDDER_EMBEDDER_H_
diff --git a/net/base/network_change_notifier_win.cc b/net/base/network_change_notifier_win.cc
index 17fffeff9cd0c..2ab1d1fbf8c9b 100644
--- a/net/base/network_change_notifier_win.cc
+++ b/net/base/network_change_notifier_win.cc
@@ -19,6 +19,7 @@
 #include "base/task/thread_pool.h"
 #include "base/threading/thread.h"
 #include "base/time/time.h"
+#include "base/win/windows_version.h"
 #include "net/base/winsock_init.h"
 #include "net/base/winsock_util.h"
 
@@ -280,6 +281,10 @@ NetworkChangeNotifier::ConnectionCost
 NetworkChangeNotifierWin::GetCurrentConnectionCost() {
   InitializeConnectionCost();
 
+  // Pre-Win10 use the default logic.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return NetworkChangeNotifier::GetCurrentConnectionCost();
+
   // If we don't have the event sink we aren't registered for automatic updates.
   // In that case, we need to update the value at the time it is requested.
   if (!network_cost_manager_event_sink_)
@@ -289,6 +294,12 @@ NetworkChangeNotifierWin::GetCurrentConnectionCost() {
 }
 
 bool NetworkChangeNotifierWin::InitializeConnectionCostOnce() {
+  // Pre-Win10 this information cannot be retrieved and cached.
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    SetCurrentConnectionCost(CONNECTION_COST_UNKNOWN);
+    return true;
+  }
+
   HRESULT hr =
       ::CoCreateInstance(CLSID_NetworkListManager, nullptr, CLSCTX_ALL,
                          IID_INetworkCostManager, &network_cost_manager_);
diff --git a/net/base/network_change_notifier_win_unittest.cc b/net/base/network_change_notifier_win_unittest.cc
index b9c6df949fb0a..e50202ea22f57 100644
--- a/net/base/network_change_notifier_win_unittest.cc
+++ b/net/base/network_change_notifier_win_unittest.cc
@@ -10,6 +10,7 @@
 #include "base/run_loop.h"
 #include "base/task/sequenced_task_runner.h"
 #include "base/task/single_thread_task_runner.h"
+#include "base/win/windows_version.h"
 #include "net/base/network_change_notifier.h"
 #include "net/base/network_change_notifier_factory.h"
 #include "net/test/test_with_task_environment.h"
@@ -307,6 +308,10 @@ class TestConnectionCostObserver
 };
 
 TEST_F(NetworkChangeNotifierWinTest, NetworkCostManagerIntegration) {
+  // NetworkCostManager integration only exist on Win10+.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   // Upon creation, none of the NetworkCostManager integration should be
   // initialized yet.
   ASSERT_FALSE(HasNetworkCostManager());
diff --git a/net/cert/cert_verify_proc.cc b/net/cert/cert_verify_proc.cc
index c1c3a60b009e4..c49c82226481b 100644
--- a/net/cert/cert_verify_proc.cc
+++ b/net/cert/cert_verify_proc.cc
@@ -67,6 +67,7 @@
 #elif BUILDFLAG(IS_MAC)
 #include "net/cert/cert_verify_proc_mac.h"
 #elif BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "net/cert/cert_verify_proc_win.h"
 #endif
 
@@ -352,6 +353,17 @@ void RecordEkuHistogram(const CertVerifyResult& verify_result) {
       eku_status);
 }
 
+bool AreSHA1IntermediatesAllowed() {
+#if BUILDFLAG(IS_WIN)
+  // TODO(rsleevi): Remove this once https://crbug.com/588789 is resolved
+  // for Windows 7/2008 users.
+  // Note: This must be kept in sync with cert_verify_proc_unittest.cc
+  return base::win::GetVersion() < base::win::Version::WIN8;
+#else
+  return false;
+#endif
+}
+
 // Inspects the signature algorithms in a single certificate |cert|.
 //
 //   * Sets |verify_result->has_sha1| to true if the certificate uses SHA1.
@@ -643,10 +655,13 @@ int CertVerifyProc::Verify(X509Certificate* cert,
   // Current SHA-1 behaviour:
   // - Reject all SHA-1
   // - ... unless it's not publicly trusted and SHA-1 is allowed
+  // - ... or SHA-1 is in the intermediate and SHA-1 intermediates are
+  //   allowed for that platform. See https://crbug.com/588789
   bool current_sha1_issue =
       (verify_result->is_issued_by_known_root ||
        !(flags & VERIFY_ENABLE_SHA1_LOCAL_ANCHORS)) &&
-      (verify_result->has_sha1_leaf || verify_result->has_sha1);
+      (verify_result->has_sha1_leaf ||
+       (verify_result->has_sha1 && !AreSHA1IntermediatesAllowed()));
 
   if (current_sha1_issue) {
     verify_result->cert_status |= CERT_STATUS_WEAK_SIGNATURE_ALGORITHM;
diff --git a/net/cert/cert_verify_proc_unittest.cc b/net/cert/cert_verify_proc_unittest.cc
index 1fb8e3c18d3a4..483d07316695b 100644
--- a/net/cert/cert_verify_proc_unittest.cc
+++ b/net/cert/cert_verify_proc_unittest.cc
@@ -298,6 +298,20 @@ bool ScopedTestRootCanTrustIntermediateCert(
          verify_proc_type == CERT_VERIFY_PROC_ANDROID;
 }
 
+// TODO(crbug.com/649017): This is not parameterized by the CertVerifyProc
+// because the CertVerifyProc::Verify() does this unconditionally based on the
+// platform.
+bool AreSHA1IntermediatesAllowed() {
+#if BUILDFLAG(IS_WIN)
+  // TODO(rsleevi): Remove this once https://crbug.com/588789 is resolved
+  // for Windows 7/2008 users.
+  // Note: This must be kept in sync with cert_verify_proc.cc
+  return base::win::GetVersion() < base::win::Version::WIN8;
+#else
+  return false;
+#endif
+}
+
 std::string MakeRandomHexString(size_t num_bytes) {
   std::vector<char> rand_bytes;
   rand_bytes.resize(num_bytes);
@@ -1740,9 +1754,15 @@ TEST_P(CertVerifyProcInternalTest, Sha1IntermediateUsesServerGatedCrypto) {
                      "www.example.com", flags, CRLSet::BuiltinCRLSet().get(),
                      CertificateList(), &verify_result);
 
-  EXPECT_NE(error, OK);
-  EXPECT_TRUE(verify_result.cert_status & CERT_STATUS_WEAK_SIGNATURE_ALGORITHM);
-  EXPECT_TRUE(verify_result.cert_status & CERT_STATUS_SHA1_SIGNATURE_PRESENT);
+  if (AreSHA1IntermediatesAllowed()) {
+    EXPECT_THAT(error, IsOk());
+    EXPECT_TRUE(verify_result.cert_status & CERT_STATUS_SHA1_SIGNATURE_PRESENT);
+  } else {
+    EXPECT_NE(error, OK);
+    EXPECT_TRUE(verify_result.cert_status &
+                CERT_STATUS_WEAK_SIGNATURE_ALGORITHM);
+    EXPECT_TRUE(verify_result.cert_status & CERT_STATUS_SHA1_SIGNATURE_PRESENT);
+  }
 }
 
 // Basic test for returning the chain in CertVerifyResult. Note that the
@@ -5845,7 +5865,7 @@ TEST(CertVerifyProcTest, RejectsPublicSHA1Leaves) {
   EXPECT_TRUE(verify_result.cert_status & CERT_STATUS_WEAK_SIGNATURE_ALGORITHM);
 }
 
-TEST(CertVerifyProcTest, RejectsPublicSHA1Intermediates) {
+TEST(CertVerifyProcTest, RejectsPublicSHA1IntermediatesUnlessAllowed) {
   scoped_refptr<X509Certificate> cert(ImportCertFromFile(
       GetTestCertsDirectory(), "39_months_after_2015_04.pem"));
   ASSERT_TRUE(cert);
@@ -5862,8 +5882,14 @@ TEST(CertVerifyProcTest, RejectsPublicSHA1Intermediates) {
       cert.get(), "127.0.0.1", /*ocsp_response=*/std::string(),
       /*sct_list=*/std::string(), flags, CRLSet::BuiltinCRLSet().get(),
       CertificateList(), &verify_result, NetLogWithSource());
-  EXPECT_THAT(error, IsError(ERR_CERT_WEAK_SIGNATURE_ALGORITHM));
-  EXPECT_TRUE(verify_result.cert_status & CERT_STATUS_WEAK_SIGNATURE_ALGORITHM);
+  if (AreSHA1IntermediatesAllowed()) {
+    EXPECT_THAT(error, IsOk());
+    EXPECT_TRUE(verify_result.cert_status & CERT_STATUS_SHA1_SIGNATURE_PRESENT);
+  } else {
+    EXPECT_THAT(error, IsError(ERR_CERT_WEAK_SIGNATURE_ALGORITHM));
+    EXPECT_TRUE(verify_result.cert_status &
+                CERT_STATUS_WEAK_SIGNATURE_ALGORITHM);
+  }
 }
 
 TEST(CertVerifyProcTest, RejectsPrivateSHA1UnlessFlag) {
diff --git a/net/cert/cert_verify_proc_win.cc b/net/cert/cert_verify_proc_win.cc
index 3ab9e88386bef..91b1d9ce02296 100644
--- a/net/cert/cert_verify_proc_win.cc
+++ b/net/cert/cert_verify_proc_win.cc
@@ -18,6 +18,7 @@
 #include "base/task/thread_pool.h"
 #include "base/threading/thread_local.h"
 #include "base/win/registry.h"
+#include "base/win/windows_version.h"
 #include "crypto/capi_util.h"
 #include "crypto/scoped_capi_types.h"
 #include "crypto/sha2.h"
@@ -268,23 +269,26 @@ void GetCertChainInfo(PCCERT_CHAIN_CONTEXT chain_context,
   PCCERT_CONTEXT verified_cert = nullptr;
   std::vector<PCCERT_CONTEXT> verified_chain;
 
-  // Recheck signatures in the event junk data was provided.
-  for (DWORD i = 0; i < num_elements - 1; ++i) {
-    PCCERT_CONTEXT issuer = element[i + 1]->pCertContext;
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    // Recheck signatures in the event junk data was provided.
+    for (DWORD i = 0; i < num_elements - 1; ++i) {
+      PCCERT_CONTEXT issuer = element[i + 1]->pCertContext;
 
-    // If Issuer isn't ECC, skip this certificate.
-    if (strcmp(issuer->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
-               szOID_ECC_PUBLIC_KEY)) {
-      continue;
-    }
+      // If Issuer isn't ECC, skip this certificate.
+      if (strcmp(issuer->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
+                 szOID_ECC_PUBLIC_KEY)) {
+        continue;
+      }
 
-    PCCERT_CONTEXT cert = element[i]->pCertContext;
-    if (!CryptVerifyCertificateSignatureEx(
-            NULL, X509_ASN_ENCODING, CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
-            const_cast<PCERT_CONTEXT>(cert), CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
-            const_cast<PCERT_CONTEXT>(issuer), 0, nullptr)) {
-      verify_result->cert_status |= CERT_STATUS_AUTHORITY_INVALID;
-      break;
+      PCCERT_CONTEXT cert = element[i]->pCertContext;
+      if (!CryptVerifyCertificateSignatureEx(
+              NULL, X509_ASN_ENCODING, CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
+              const_cast<PCERT_CONTEXT>(cert),
+              CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
+              const_cast<PCERT_CONTEXT>(issuer), 0, nullptr)) {
+        verify_result->cert_status |= CERT_STATUS_AUTHORITY_INVALID;
+        break;
+      }
     }
   }
 
@@ -929,8 +933,16 @@ void AuthRootVersionChecker::RefreshWatch() {
   if (!key_.Valid())
     return;
 
-  // On Windows, any thread can monitor the registry for changes, and monitoring
-  // is not abandoned if the thread ends.
+  if (base::win::GetVersion() < base::win::Version::WIN8) {
+    // On Windows 7 and earlier, using RegNotifyChangeKeyValue from a worker
+    // thread will abandon the notification if that thread ends. Rather than
+    // marshalling to a persistent thread, on these versions, `ShouldUpdate()`
+    // just takes a less-optimized path.
+    return;
+  }
+
+  // On Windows 8 or later, any thread can monitor the registry for changes,
+  // and monitoring is not abandoned if the thread ends.
   DWORD flags = REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_THREAD_AGNOSTIC;
   RegNotifyChangeKeyValue(key_.Handle(), FALSE, flags, event_.Get(), TRUE);
 }
@@ -942,8 +954,30 @@ bool AuthRootVersionChecker::ShouldUpdate() {
   if (!key_.Valid())
     return false;
 
-  // Check if the event is signaled.
-  return WaitForSingleObject(event_.Get(), 0) == WAIT_OBJECT_0;
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    // On Win 8+, just check if the event is signaled.
+    return WaitForSingleObject(event_.Get(), 0) == WAIT_OBJECT_0;
+  }
+
+  // On Win 7 and earlier, check the last modification time of the registry.
+  // This is less efficient than using the event, but a simpler implementation
+  // than needing to marshal RegNotifyChangeKeyValue to a persistent thread.
+  FILETIME current_timestamp = {0, 0};
+  LSTATUS result = RegQueryInfoKeyW(key_.Handle(), nullptr, nullptr, nullptr,
+                                    nullptr, nullptr, nullptr, nullptr, nullptr,
+                                    nullptr, nullptr, &current_timestamp);
+
+  // If for some reason things failed, rather than constantly querying the
+  // registry every time, fail closed and just use the stale value.
+  if (result != ERROR_SUCCESS)
+    return false;
+
+  base::Time update_time = base::Time::FromFileTime(current_timestamp);
+  if (update_time > last_update_) {
+    last_update_ = update_time;
+    return true;
+  }
+  return false;
 }
 
 void AuthRootVersionChecker::UpdateAuthRootVersion() {
diff --git a/remoting/base/url_request_context_getter.cc b/remoting/base/url_request_context_getter.cc
index 5f1339d22a9dd..ab2bcb1856ad1 100644
--- a/remoting/base/url_request_context_getter.cc
+++ b/remoting/base/url_request_context_getter.cc
@@ -15,6 +15,11 @@
 #include "net/url_request/url_request_context_builder.h"
 #include "remoting/base/vlog_net_log.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#include "net/log/net_log.h"
+#endif  // BUILDFLAG(IS_WIN)
+
 namespace remoting {
 
 URLRequestContextGetter::URLRequestContextGetter(
@@ -30,6 +35,19 @@ net::URLRequestContext* URLRequestContextGetter::GetURLRequestContext() {
     net::URLRequestContextBuilder builder;
     builder.DisableHttpCache();
 
+#if BUILDFLAG(IS_WIN)
+    if (base::win::GetVersion() <= base::win::Version::WIN7) {
+      // The network stack of Windows 7 and older systems has a bug such that
+      // proxy resolution always fails and blocks each request for ~10-30
+      // seconds. We don't support proxied connection right now, so just disable
+      // it on Windows 7 HTTP requests.
+      auto proxy_resolution_service =
+          net::ConfiguredProxyResolutionService::CreateWithoutProxyResolver(
+              std::move(proxy_config_service_), net::NetLog::Get());
+      builder.set_proxy_resolution_service(std::move(proxy_resolution_service));
+    }
+#endif  // BUILDFLAG(IS_WIN)
+
     if (proxy_config_service_) {
       builder.set_proxy_config_service(std::move(proxy_config_service_));
     }
diff --git a/remoting/host/desktop_session_win.cc b/remoting/host/desktop_session_win.cc
index 009ed467fc0af..5316a47b3e258 100644
--- a/remoting/host/desktop_session_win.cc
+++ b/remoting/host/desktop_session_win.cc
@@ -10,7 +10,6 @@
 
 #include <limits>
 #include <memory>
-#include <string>
 #include <utility>
 
 #include "base/base_switches.h"
@@ -28,6 +27,7 @@
 #include "base/win/registry.h"
 #include "base/win/scoped_bstr.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "remoting/base/auto_thread_task_runner.h"
 #include "remoting/host/base/screen_resolution.h"
 #include "remoting/host/base/switches.h"
@@ -73,9 +73,29 @@ const int kDefaultRdpScreenHeight = 768;
 const int kMinRdpScreenWidth = 800;
 const int kMinRdpScreenHeight = 600;
 
-// Windows supports dimensions up to 8192x8192.
-const int kMaxRdpScreenWidth = 8192;
-const int kMaxRdpScreenHeight = 8192;
+// Win7 SP1 (and Vista) supports dimensions up to 4096x2048.
+const int kMaxRdpScreenWidthForWin7 = 4096;
+const int kMaxRdpScreenHeightForWin7 = 2048;
+
+// Win8+ supports dimensions up to 8192x8192.
+const int kMaxRdpScreenWidthForWin8AndLater = 8192;
+const int kMaxRdpScreenHeightForWin8AndLater = 8192;
+
+int GetMaxRdpScreenWidth() {
+  static int max_rdp_screen_width =
+      base::win::GetVersion() >= base::win::Version::WIN8
+          ? kMaxRdpScreenWidthForWin8AndLater
+          : kMaxRdpScreenWidthForWin7;
+  return max_rdp_screen_width;
+}
+
+int GetMaxRdpScreenHeight() {
+  static int max_rdp_screen_height =
+      base::win::GetVersion() >= base::win::Version::WIN8
+          ? kMaxRdpScreenHeightForWin8AndLater
+          : kMaxRdpScreenHeightForWin7;
+  return max_rdp_screen_height;
+}
 
 // Default dots per inch used by RDP is 96 DPI.
 const int kDefaultRdpDpi = 96;
@@ -104,8 +124,8 @@ const wchar_t kSecurityLayerValueName[] = L"SecurityLayer";
 
 webrtc::DesktopSize GetBoundedRdpDesktopSize(int width, int height) {
   return webrtc::DesktopSize(
-      base::clamp(width, kMinRdpScreenWidth, kMaxRdpScreenWidth),
-      base::clamp(height, kMinRdpScreenHeight, kMaxRdpScreenHeight));
+      base::clamp(width, kMinRdpScreenWidth, GetMaxRdpScreenWidth()),
+      base::clamp(height, kMinRdpScreenHeight, GetMaxRdpScreenHeight()));
 }
 
 // DesktopSession implementation which attaches to the host's physical console.
@@ -479,7 +499,7 @@ STDMETHODIMP RdpSession::EventHandler::OnRdpClosed() {
   return S_OK;
 }
 
-}  // namespace
+} // namespace
 
 // static
 std::unique_ptr<DesktopSession> DesktopSessionWin::CreateForConsole(
@@ -625,12 +645,17 @@ void DesktopSessionWin::OnSessionAttached(uint32_t session_id) {
 
   ReportElapsedTime("attached");
 
-  // Get the name of the executable to run. `kDesktopBinaryName` specifies
-  // uiAccess="true" in its manifest.  Prefer kDesktopBinaryName but fall back
-  // to kHostBinaryName if there is a problem loading it.
-  base::FilePath desktop_binary;
-  bool result = GetInstalledBinaryPath(kDesktopBinaryName, &desktop_binary);
+  // Launch elevated on Win8+ to enable injection of Alt+Tab and Ctrl+Alt+Del.
+  bool launch_elevated = base::win::GetVersion() >= base::win::Version::WIN8;
 
+  // Get the name of the executable to run. |kDesktopBinaryName| specifies
+  // uiAccess="true" in its manifest.  Prefer kDesktopBinaryName for Win8+ but
+  // fall back to kHostBinaryName if there is a problem loading it.
+  base::FilePath desktop_binary;
+  bool result = false;
+  if (launch_elevated) {
+    result = GetInstalledBinaryPath(kDesktopBinaryName, &desktop_binary);
+  }
   if (!result || !IsBinaryTrusted(desktop_binary)) {
     result = GetInstalledBinaryPath(kHostBinaryName, &desktop_binary);
   }
@@ -650,10 +675,9 @@ void DesktopSessionWin::OnSessionAttached(uint32_t session_id) {
                            kCopiedSwitchNames, std::size(kCopiedSwitchNames));
 
   // Create a delegate capable of launching a process in a different session.
-  // Launch elevated to enable injection of Alt+Tab and Ctrl+Alt+Del.
   std::unique_ptr<WtsSessionProcessDelegate> delegate(
       new WtsSessionProcessDelegate(
-          io_task_runner_, std::move(target), /*launch_elevated=*/true,
+          io_task_runner_, std::move(target), launch_elevated,
           base::WideToUTF8(kDaemonIpcSecurityDescriptor)));
   if (!delegate->Initialize(session_id)) {
     TerminateSession();
diff --git a/remoting/host/host_attributes.cc b/remoting/host/host_attributes.cc
index 3cf9ffcacfc36..bcfb3106ccf37 100644
--- a/remoting/host/host_attributes.cc
+++ b/remoting/host/host_attributes.cc
@@ -16,6 +16,7 @@
 #include "build/build_config.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "media/base/win/mf_initializer.h"
 #include "media/gpu/windows/media_foundation_video_encode_accelerator_win.h"
 #include "remoting/host/win/evaluate_3d_display_mode.h"
@@ -98,8 +99,20 @@ std::string GetHostAttributes() {
     }
   }
 #if BUILDFLAG(IS_WIN)
-  GetD3DCapabilities(&result);
-  result.push_back("Win10+");
+  {
+    GetD3DCapabilities(&result);
+
+    auto version = base::win::GetVersion();
+    if (version >= base::win::Version::WIN8) {
+      result.push_back("Win8+");
+    }
+    if (version >= base::win::Version::WIN8_1) {
+      result.push_back("Win81+");
+    }
+    if (version >= base::win::Version::WIN10) {
+      result.push_back("Win10+");
+    }
+  }
 
   // TODO(crbug.com/1184041): Remove this and/or the entire HostAttributes class
   // so we can remove //remoting/host:common from //media/gpu's visibility list.
diff --git a/remoting/host/input_injector_win.cc b/remoting/host/input_injector_win.cc
index 18efb29b7436b..858d46c55ef3c 100644
--- a/remoting/host/input_injector_win.cc
+++ b/remoting/host/input_injector_win.cc
@@ -20,6 +20,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/task/single_thread_task_runner.h"
+#include "base/win/windows_version.h"
 #include "remoting/base/util.h"
 #include "remoting/host/clipboard.h"
 #include "remoting/host/touch_injector_win.h"
@@ -474,7 +475,7 @@ std::unique_ptr<InputInjector> InputInjector::Create(
 
 // static
 bool InputInjector::SupportsTouchEvents() {
-  return true;
+  return base::win::GetVersion() >= base::win::Version::WIN8;
 }
 
 }  // namespace remoting
diff --git a/remoting/host/remote_open_url/remote_open_url_util.cc b/remoting/host/remote_open_url/remote_open_url_util.cc
index 0e1628446c3f2..09931445eba16 100644
--- a/remoting/host/remote_open_url/remote_open_url_util.cc
+++ b/remoting/host/remote_open_url/remote_open_url_util.cc
@@ -10,6 +10,7 @@
 #if BUILDFLAG(IS_WIN)
 #include "base/win/registry.h"
 #include "base/win/windows_types.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace remoting {
@@ -32,6 +33,12 @@ bool IsRemoteOpenUrlSupported() {
 #if BUILDFLAG(IS_LINUX)
   return true;
 #elif BUILDFLAG(IS_WIN)
+  // The modern default apps settings dialog is only available to Windows 8+.
+  // Given older Windows versions are EOL, we only advertise the feature on
+  // Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8) {
+    return false;
+  }
   // The MSI installs the ProgID and capabilities into registry, but not the
   // entry in RegisteredApplications, which must be applied out of band to
   // enable the feature.
diff --git a/remoting/host/win/evaluate_3d_display_mode.cc b/remoting/host/win/evaluate_3d_display_mode.cc
index e52f5eb818814..dd93ac20bbccc 100644
--- a/remoting/host/win/evaluate_3d_display_mode.cc
+++ b/remoting/host/win/evaluate_3d_display_mode.cc
@@ -16,6 +16,7 @@
 #include "base/native_library.h"
 #include "base/scoped_native_library.h"
 #include "base/strings/string_util.h"
+#include "base/win/windows_version.h"
 #include "remoting/host/base/host_exit_codes.h"
 #include "remoting/host/base/switches.h"
 #include "remoting/host/evaluate_capability.h"
@@ -33,6 +34,11 @@ typedef HRESULT(WINAPI* CreateDXGIFactory2Function)(UINT Flags,
 }  // namespace
 
 int Evaluate3dDisplayMode() {
+  // CreateDXGIFactory2 does not exist prior to Win 8.1 but neither does 3D
+  // display mode.
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return kSuccessExitCode;
+
   // We can't directly reference CreateDXGIFactory2 is it does not exist on
   // earlier Windows builds.  Therefore we need a LoadLibrary / GetProcAddress
   // dance.
diff --git a/sandbox/features.cc b/sandbox/features.cc
index 1ed46ef1522d8..2053968b8442a 100644
--- a/sandbox/features.cc
+++ b/sandbox/features.cc
@@ -4,10 +4,6 @@
 
 #include "sandbox/features.h"
 
-#if BUILDFLAG(IS_WIN)
-#include "base/win/windows_version.h"
-#endif
-
 namespace sandbox::features {
 #if BUILDFLAG(IS_WIN)
 bool IsAppContainerSandboxSupported() {
diff --git a/sandbox/features.h b/sandbox/features.h
index c2f8e4af53229..8c0cd7cd9185e 100644
--- a/sandbox/features.h
+++ b/sandbox/features.h
@@ -7,6 +7,10 @@
 
 #include "build/build_config.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace sandbox::features {
 #if BUILDFLAG(IS_WIN)
 // Returns whether the App Container Sandbox is supported by the current
diff --git a/sandbox/policy/switches.cc b/sandbox/policy/switches.cc
index 5ae90503390fd..2c8081e8bdf26 100644
--- a/sandbox/policy/switches.cc
+++ b/sandbox/policy/switches.cc
@@ -10,6 +10,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/command_line.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace sandbox {
diff --git a/sandbox/policy/win/sandbox_policy_feature_test.cc b/sandbox/policy/win/sandbox_policy_feature_test.cc
index de7381f0d377f..f643dc32115d6 100644
--- a/sandbox/policy/win/sandbox_policy_feature_test.cc
+++ b/sandbox/policy/win/sandbox_policy_feature_test.cc
@@ -46,7 +46,9 @@ MitigationFlags SandboxFeatureTest::GetExpectedMitigationFlags() {
       ::sandbox::MITIGATION_KTM_COMPONENT;
 
 #if !defined(NACL_WIN64)
-  flags = flags | ::sandbox::MITIGATION_WIN32K_DISABLE;
+  // Win32k mitigation is only set on the operating systems it's available on
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    flags = flags | ::sandbox::MITIGATION_WIN32K_DISABLE;
 #endif
 
   return flags;
diff --git a/sandbox/policy/win/sandbox_policy_feature_test.h b/sandbox/policy/win/sandbox_policy_feature_test.h
index 39b15f7670d02..35c90acfedcce 100644
--- a/sandbox/policy/win/sandbox_policy_feature_test.h
+++ b/sandbox/policy/win/sandbox_policy_feature_test.h
@@ -13,6 +13,8 @@
 #include "testing/gtest/include/gtest/gtest.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#include "sandbox/policy/win/sandbox_test_utils.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/app_container_base.h"
 #include "sandbox/win/src/sandbox_factory.h"
@@ -40,6 +42,7 @@ class SandboxFeatureTest
   virtual MitigationFlags GetExpectedMitigationFlags();
   virtual MitigationFlags GetExpectedDelayedMitigationFlags();
 
+  // App Containers are only available in Windows 8 and up
   virtual AppContainerType GetExpectedAppContainerType();
   virtual std::vector<base::win::Sid> GetExpectedCapabilities();
 
diff --git a/sandbox/policy/win/sandbox_win.cc b/sandbox/policy/win/sandbox_win.cc
index cf16e2e25fec6..e5441b9b83b96 100644
--- a/sandbox/policy/win/sandbox_win.cc
+++ b/sandbox/policy/win/sandbox_win.cc
@@ -262,6 +262,50 @@ std::wstring PrependWindowsSessionPath(const wchar_t* object) {
   return base::StringPrintf(L"\\Sessions\\%lu%ls", s_session_id, object);
 }
 
+// Checks if the sandbox can be let to run without a job object assigned.
+// Returns true if the job object has to be applied to the sandbox and false
+// otherwise.
+bool ShouldSetJobLevel(bool allow_no_sandbox_job) {
+  // Windows 8 allows nested jobs so we don't need to check if we are in other
+  // job.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    return true;
+
+  BOOL in_job = true;
+  // Either there is no job yet associated so we must add our job,
+  if (!::IsProcessInJob(::GetCurrentProcess(), NULL, &in_job))
+    NOTREACHED() << "IsProcessInJob failed. " << GetLastError();
+  if (!in_job)
+    return true;
+
+  // ...or there is a job but the JOB_OBJECT_LIMIT_BREAKAWAY_OK limit is set.
+  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_info = {};
+  if (!::QueryInformationJobObject(NULL, JobObjectExtendedLimitInformation,
+                                   &job_info, sizeof(job_info), NULL)) {
+    NOTREACHED() << "QueryInformationJobObject failed. " << GetLastError();
+    return true;
+  }
+  if (job_info.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_BREAKAWAY_OK)
+    return true;
+
+  // Lastly in place of the flag which was supposed to be used only for running
+  // Chrome in remote sessions we do this check explicitly here.
+  // According to MS this flag can be false for a remote session only on Windows
+  // Server 2012 and newer so if we do the check last we should be on the safe
+  // side. See: https://msdn.microsoft.com/en-us/library/aa380798.aspx.
+  if (!::GetSystemMetrics(SM_REMOTESESSION)) {
+    // TODO(pastarmovj): Even though the number are low, this flag is still
+    // necessary in some limited set of cases. Remove it once Windows 7 is no
+    // longer supported together with the rest of the checks in this function.
+    return !allow_no_sandbox_job;
+  }
+
+  // Allow running without the sandbox in this case. This slightly reduces the
+  // ability of the sandbox to protect its children from spawning new processes
+  // or preventing them from shutting down Windows or accessing the clipboard.
+  return false;
+}
+
 // Adds the generic config rules to a sandbox TargetConfig.
 ResultCode AddGenericConfig(sandbox::TargetConfig* config) {
   DCHECK(!config->IsConfigured());
@@ -329,6 +373,12 @@ ResultCode AddGenericConfig(sandbox::TargetConfig* config) {
   return SBOX_ALL_OK;
 }
 
+void LogLaunchWarning(ResultCode last_warning, DWORD last_error) {
+  base::UmaHistogramSparse("Process.Sandbox.Launch.WarningResultCode",
+                           last_warning);
+  base::UmaHistogramSparse("Process.Sandbox.Launch.Warning", last_error);
+}
+
 ResultCode AddDefaultConfigForSandboxedProcess(TargetConfig* config) {
   // Prevents the renderers from manipulating low-integrity processes.
   config->SetDelayedIntegrityLevel(INTEGRITY_LEVEL_UNTRUSTED);
@@ -343,7 +393,9 @@ ResultCode AddDefaultConfigForSandboxedProcess(TargetConfig* config) {
 
   config->SetLockdownDefaultDacl();
 
-  result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
+  // Win8+ adds a device DeviceApi that we don't need.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
   if (result != SBOX_ALL_OK)
     return result;
 
@@ -752,13 +804,22 @@ ResultCode LaunchWithoutSandbox(
   // on process shutdown, in which case TerminateProcess can fail. See
   // https://crbug.com/820996.
   if (delegate->ShouldUnsandboxedRunInJob()) {
-    static base::NoDestructor<Job> job_object;
-    if (!job_object->IsValid()) {
-      DWORD result = job_object->Init(JobLevel::kUnprotected, 0, 0);
-      if (result != ERROR_SUCCESS)
-        return SBOX_ERROR_CANNOT_INIT_JOB;
+    BOOL in_job = true;
+    // Prior to Windows 8 nested jobs aren't possible.
+    if (base::win::GetVersion() >= base::win::Version::WIN8 ||
+        (::IsProcessInJob(::GetCurrentProcess(), nullptr, &in_job) &&
+         !in_job)) {
+      static Job* job_object = nullptr;
+      if (!job_object) {
+        job_object = new Job;
+        DWORD result = job_object->Init(JobLevel::kUnprotected, nullptr, 0, 0);
+        if (result != ERROR_SUCCESS) {
+          job_object = nullptr;
+          return SBOX_ERROR_CANNOT_INIT_JOB;
+        }
+      }
+      options.job_handle = job_object->GetHandle();
     }
-    options.job_handle = job_object->GetHandle();
   }
 
   // Chromium binaries are marked as CET Compatible but some processes
@@ -799,6 +860,8 @@ ResultCode SandboxWin::SetJobLevel(Sandbox sandbox_type,
                                    uint32_t ui_exceptions,
                                    TargetConfig* config) {
   DCHECK(!config->IsConfigured());
+  if (!ShouldSetJobLevel(config->GetAllowNoSandboxJob()))
+    return config->SetJobLevel(JobLevel::kNone, 0);
 
   ResultCode ret = config->SetJobLevel(job_level, ui_exceptions);
   if (ret != SBOX_ALL_OK)
@@ -846,6 +909,10 @@ ResultCode SandboxWin::AddAppContainerPolicy(TargetConfig* config,
 ResultCode SandboxWin::AddWin32kLockdownPolicy(TargetConfig* config) {
   DCHECK(!config->IsConfigured());
 #if !defined(NACL_WIN64)
+  // Win32k Lockdown is supported on Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return SBOX_ALL_OK;
+
   MitigationFlags flags = config->GetProcessMitigations();
   // Check not enabling twice. Should not happen.
   DCHECK_EQ(0U, flags & MITIGATION_WIN32K_DISABLE);
@@ -1041,11 +1108,12 @@ ResultCode SandboxWin::StartSandboxedProcess(
   TRACE_EVENT_BEGIN0("startup", "StartProcessWithAccess::LAUNCHPROCESS");
 
   PROCESS_INFORMATION temp_process_info = {};
+  ResultCode last_warning = sandbox::SBOX_ALL_OK;
   DWORD last_error = ERROR_SUCCESS;
   result = g_broker_services->SpawnTarget(
       cmd_line.GetProgram().value().c_str(),
-      cmd_line.GetCommandLineString().c_str(), std::move(policy), &last_error,
-      &temp_process_info);
+      cmd_line.GetCommandLineString().c_str(), std::move(policy), &last_warning,
+      &last_error, &temp_process_info);
   auto time_process_spawned = timer.Elapsed();
 
   base::win::ScopedProcessInformation target(temp_process_info);
@@ -1068,6 +1136,9 @@ ResultCode SandboxWin::StartSandboxedProcess(
                                  cmd_line.GetCommandLineString());
   }
 
+  if (SBOX_ALL_OK != last_warning)
+    LogLaunchWarning(last_warning, last_error);
+
   delegate->PostSpawnTarget(target.process_handle());
   CHECK(ResumeThread(target.thread_handle()) != static_cast<DWORD>(-1));
   auto time_process_resumed = timer.Elapsed();
diff --git a/sandbox/win/src/address_sanitizer_test.cc b/sandbox/win/src/address_sanitizer_test.cc
index 7f437d40d2da8..47466cbbe9376 100644
--- a/sandbox/win/src/address_sanitizer_test.cc
+++ b/sandbox/win/src/address_sanitizer_test.cc
@@ -13,6 +13,7 @@
 #include "base/logging.h"
 #include "base/path_service.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/tests/common/controller.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
diff --git a/sandbox/win/src/app_container_base.cc b/sandbox/win/src/app_container_base.cc
index 61c453ec54825..ca91d2d1f2ab8 100644
--- a/sandbox/win/src/app_container_base.cc
+++ b/sandbox/win/src/app_container_base.cc
@@ -22,6 +22,18 @@ namespace sandbox {
 
 namespace {
 
+typedef decltype(::CreateAppContainerProfile) CreateAppContainerProfileFunc;
+
+typedef decltype(::DeriveAppContainerSidFromAppContainerName)
+    DeriveAppContainerSidFromAppContainerNameFunc;
+
+typedef decltype(::DeleteAppContainerProfile) DeleteAppContainerProfileFunc;
+
+typedef decltype(::GetAppContainerFolderPath) GetAppContainerFolderPathFunc;
+
+typedef decltype(
+    ::GetAppContainerRegistryLocation) GetAppContainerRegistryLocationFunc;
+
 struct FreeSidDeleter {
   inline void operator()(void* ptr) const { ::FreeSid(ptr); }
 };
@@ -45,8 +57,14 @@ class ScopedImpersonation {
 AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
                                                   const wchar_t* display_name,
                                                   const wchar_t* description) {
+  static auto create_app_container_profile =
+      reinterpret_cast<CreateAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "CreateAppContainerProfile"));
+  if (!create_app_container_profile)
+    return nullptr;
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::CreateAppContainerProfile(
+  HRESULT hr = create_app_container_profile(
       package_name, display_name, description, nullptr, 0, &package_sid_ptr);
   if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
     return Open(package_name);
@@ -62,9 +80,15 @@ AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
 
 // static
 AppContainerBase* AppContainerBase::Open(const wchar_t* package_name) {
+  static auto derive_app_container_sid =
+      reinterpret_cast<DeriveAppContainerSidFromAppContainerNameFunc*>(
+          GetProcAddress(GetModuleHandle(L"userenv"),
+                         "DeriveAppContainerSidFromAppContainerName"));
+  if (!derive_app_container_sid)
+    return nullptr;
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::DeriveAppContainerSidFromAppContainerName(package_name,
-                                                           &package_sid_ptr);
+  HRESULT hr = derive_app_container_sid(package_name, &package_sid_ptr);
   if (FAILED(hr))
     return nullptr;
 
@@ -86,7 +110,13 @@ AppContainerBase* AppContainerBase::CreateLowbox(const wchar_t* sid) {
 
 // static
 bool AppContainerBase::Delete(const wchar_t* package_name) {
-  return SUCCEEDED(::DeleteAppContainerProfile(package_name));
+  static auto delete_app_container_profile =
+      reinterpret_cast<DeleteAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "DeleteAppContainerProfile"));
+  if (!delete_app_container_profile)
+    return false;
+
+  return SUCCEEDED(delete_app_container_profile(package_name));
 }
 
 AppContainerBase::AppContainerBase(base::win::Sid& package_sid,
@@ -113,24 +143,36 @@ void AppContainerBase::Release() {
 
 bool AppContainerBase::GetRegistryLocation(REGSAM desired_access,
                                            base::win::ScopedHandle* key) {
+  static GetAppContainerRegistryLocationFunc*
+      get_app_container_registry_location =
+          reinterpret_cast<GetAppContainerRegistryLocationFunc*>(GetProcAddress(
+              GetModuleHandle(L"userenv"), "GetAppContainerRegistryLocation"));
+  if (!get_app_container_registry_location)
+    return false;
+
   base::win::ScopedHandle token;
   if (BuildLowBoxToken(&token) != SBOX_ALL_OK)
     return false;
 
   ScopedImpersonation impersonation(token);
   HKEY key_handle;
-  if (FAILED(::GetAppContainerRegistryLocation(desired_access, &key_handle)))
+  if (FAILED(get_app_container_registry_location(desired_access, &key_handle)))
     return false;
   key->Set(key_handle);
   return true;
 }
 
 bool AppContainerBase::GetFolderPath(base::FilePath* file_path) {
+  static GetAppContainerFolderPathFunc* get_app_container_folder_path =
+      reinterpret_cast<GetAppContainerFolderPathFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "GetAppContainerFolderPath"));
+  if (!get_app_container_folder_path)
+    return false;
   auto sddl_str = package_sid_.ToSddlString();
   if (!sddl_str)
     return false;
   base::win::ScopedCoMem<wchar_t> path_str;
-  if (FAILED(::GetAppContainerFolderPath(sddl_str->c_str(), &path_str)))
+  if (FAILED(get_app_container_folder_path(sddl_str->c_str(), &path_str)))
     return false;
   *file_path = base::FilePath(path_str.get());
   return true;
@@ -262,10 +304,13 @@ AppContainerBase::GetSecurityCapabilities() {
   return std::make_unique<SecurityCapabilities>(package_sid_, capabilities_);
 }
 
-ResultCode AppContainerBase::BuildLowBoxToken(base::win::ScopedHandle* token) {
+ResultCode AppContainerBase::BuildLowBoxToken(
+    base::win::ScopedHandle* token,
+    base::win::ScopedHandle* lockdown) {
   if (type_ == AppContainerType::kLowbox) {
-    if (!CreateLowBoxToken(token->get(), TokenType::kPrimary, package_sid_,
-                           capabilities_, token)) {
+    if (CreateLowBoxToken(lockdown->get(), TokenType::kPrimary,
+                          package_sid_, GetSecurityCapabilities().get(),
+                          token) != ERROR_SUCCESS) {
       return SBOX_ERROR_CANNOT_CREATE_LOWBOX_TOKEN;
     }
 
@@ -275,7 +320,7 @@ ResultCode AppContainerBase::BuildLowBoxToken(base::win::ScopedHandle* token) {
       return SBOX_ERROR_CANNOT_MODIFY_LOWBOX_TOKEN_DACL;
     }
   } else if (!CreateLowBoxToken(nullptr, TokenType::kImpersonation,
-                                package_sid_, capabilities_, token)) {
+                                package_sid_, GetSecurityCapabilities().get(), token)) {
     return SBOX_ERROR_CANNOT_CREATE_LOWBOX_IMPERSONATION_TOKEN;
   }
 
diff --git a/sandbox/win/src/app_container_base.h b/sandbox/win/src/app_container_base.h
index 54207ec415ece..65589af9736ec 100644
--- a/sandbox/win/src/app_container_base.h
+++ b/sandbox/win/src/app_container_base.h
@@ -72,7 +72,8 @@ class AppContainerBase final : public AppContainer {
   static bool Delete(const wchar_t* package_name);
 
   // Build the token for the lowbox
-  ResultCode BuildLowBoxToken(base::win::ScopedHandle* token);
+  ResultCode BuildLowBoxToken(base::win::ScopedHandle* token,
+                              base::win::ScopedHandle* lockdown = nullptr);
 
  private:
   AppContainerBase(base::win::Sid& package_sid, AppContainerType type);
diff --git a/sandbox/win/src/app_container_test.cc b/sandbox/win/src/app_container_test.cc
index bd13ecad3adec..afd5ab8ea052b 100644
--- a/sandbox/win/src/app_container_test.cc
+++ b/sandbox/win/src/app_container_test.cc
@@ -13,7 +13,6 @@
 #include "base/hash/sha1.h"
 #include "base/logging.h"
 #include "base/memory/raw_ptr.h"
-#include "base/path_service.h"
 #include "base/process/process_info.h"
 #include "base/rand_util.h"
 #include "base/scoped_native_library.h"
@@ -212,9 +211,11 @@ class AppContainerTest : public ::testing::Test {
     ASSERT_NE(DWORD{0}, ::GetModuleFileNameW(nullptr, prog_name, MAX_PATH));
 
     PROCESS_INFORMATION process_info = {};
+    ResultCode last_warning = SBOX_ALL_OK;
     DWORD last_error = 0;
     ResultCode result = broker_services_->SpawnTarget(
-        prog_name, prog_name, std::move(policy_), &last_error, &process_info);
+        prog_name, prog_name, std::move(policy_), &last_warning, &last_error,
+        &process_info);
     ASSERT_EQ(SBOX_ALL_OK, result) << "Last Error: " << last_error;
     scoped_process_info_.Set(process_info);
   }
@@ -450,29 +451,4 @@ TEST(AppContainerLaunchTest, IsNotAppContainer) {
   EXPECT_EQ(SBOX_TEST_FAILED, runner.RunTest(L"CheckIsAppContainer"));
 }
 
-TEST_F(AppContainerTest, ChildProcessMitigationLowBox) {
-  if (!features::IsAppContainerSandboxSupported()) {
-    return;
-  }
-
-  TestRunner runner(JobLevel::kUnprotected, USER_UNPROTECTED, USER_UNPROTECTED);
-  EXPECT_EQ(SBOX_ALL_OK,
-            runner.GetPolicy()->GetConfig()->SetLowBox(kAppContainerSid));
-
-  // Now set the job level to be <= JobLevel::kLimitedUser
-  // and ensure we can no longer create a child process.
-  EXPECT_EQ(SBOX_ALL_OK, runner.GetPolicy()->GetConfig()->SetJobLevel(
-                             JobLevel::kLimitedUser, 0));
-
-  base::FilePath cmd;
-  EXPECT_TRUE(base::PathService::Get(base::DIR_SYSTEM, &cmd));
-  cmd = cmd.Append(L"calc.exe");
-
-  std::wstring test_command = L"TestChildProcess \"";
-  test_command += cmd.value().c_str();
-  test_command += L"\" false";
-
-  EXPECT_EQ(SBOX_TEST_SECOND_ERROR, runner.RunTest(test_command.c_str()));
-}
-
 }  // namespace sandbox
diff --git a/sandbox/win/src/app_container_unittest.cc b/sandbox/win/src/app_container_unittest.cc
index aa5ce2e2658b3..eb8b6af8d0d2c 100644
--- a/sandbox/win/src/app_container_unittest.cc
+++ b/sandbox/win/src/app_container_unittest.cc
@@ -15,6 +15,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/win/security_descriptor.h"
 #include "base/win/sid.h"
+#include "base/win/windows_version.h"
 #include "sandbox/features.h"
 #include "sandbox/win/src/app_container_base.h"
 #include "sandbox/win/src/security_capabilities.h"
diff --git a/sandbox/win/src/broker_services.cc b/sandbox/win/src/broker_services.cc
index 67854195695c8..572bece038752 100644
--- a/sandbox/win/src/broker_services.cc
+++ b/sandbox/win/src/broker_services.cc
@@ -446,6 +446,7 @@ std::unique_ptr<TargetPolicy> BrokerServicesBase::CreatePolicy(
 ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
                                            const wchar_t* command_line,
                                            std::unique_ptr<TargetPolicy> policy,
+                                           ResultCode* last_warning,
                                            DWORD* last_error,
                                            PROCESS_INFORMATION* target_info) {
   if (!exe_path)
@@ -479,6 +480,7 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   // correctly.
   static DWORD thread_id = ::GetCurrentThreadId();
   DCHECK(thread_id == ::GetCurrentThreadId());
+  *last_warning = SBOX_ALL_OK;
 
   // Launcher thread only needs to be opted out of ACG once. Do this on the
   // first child process being spawned.
@@ -495,11 +497,18 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   // with the soon to be created target process.
   base::win::ScopedHandle initial_token;
   base::win::ScopedHandle lockdown_token;
+  base::win::ScopedHandle lowbox_token;
   ResultCode result = SBOX_ALL_OK;
 
-  result = policy_base->MakeTokens(&initial_token, &lockdown_token);
+  result =
+      policy_base->MakeTokens(&initial_token, &lockdown_token, &lowbox_token);
   if (SBOX_ALL_OK != result)
     return result;
+  if (lowbox_token.IsValid() &&
+      base::win::GetVersion() < base::win::Version::WIN8) {
+    // We don't allow lowbox_token below Windows 8.
+    return SBOX_ERROR_BAD_PARAMS;
+  }
 
   result = UpdateDesktopIntegrity(config_base->desktop(),
                                   config_base->integrity_level());
@@ -536,8 +545,11 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   if (container)
     startup_info->SetAppContainer(container);
 
-  if (policy_base->HasJob())
+  // On Win10, jobs are associated via startup_info.
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      policy_base->HasJob()) {
     startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  }
 
   if (!startup_info->BuildStartupInformation())
     return SBOX_ERROR_PROC_THREAD_ATTRIBUTES;
@@ -553,8 +565,8 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
     }
   }
   std::unique_ptr<TargetProcess> target = std::make_unique<TargetProcess>(
-      std::move(initial_token), std::move(lockdown_token), thread_pool_,
-      imp_caps);
+      std::move(initial_token), std::move(lockdown_token),
+      policy_base->GetJobHandle(), thread_pool_, imp_caps);
 
   result = target->Create(exe_path, command_line, std::move(startup_info),
                           &process_info, last_error);
@@ -576,6 +588,15 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
     }
   }
 
+  if (lowbox_token.IsValid()) {
+    *last_warning = target->AssignLowBoxToken(lowbox_token);
+    // If this fails we continue, but report the error as a warning.
+    // This is due to certain configurations causing the setting of the
+    // token to fail post creation, and we'd rather continue if possible.
+    if (*last_warning != SBOX_ALL_OK)
+      *last_error = ::GetLastError();
+  }
+
   // Now the policy is the owner of the target. TargetProcess will terminate
   // the process if it has not completed when it is destroyed.
   result = policy_base->ApplyToTarget(std::move(target));
diff --git a/sandbox/win/src/broker_services.h b/sandbox/win/src/broker_services.h
index bed8ae6b68943..88c4e3ba1d48b 100644
--- a/sandbox/win/src/broker_services.h
+++ b/sandbox/win/src/broker_services.h
@@ -18,6 +18,7 @@
 #include "base/win/scoped_handle.h"
 #include "sandbox/win/src/alternate_desktop.h"
 #include "sandbox/win/src/crosscall_server.h"
+#include "sandbox/win/src/job.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_policy_base.h"
 #include "sandbox/win/src/sharedmem_ipc_server.h"
@@ -53,6 +54,7 @@ class BrokerServicesBase final : public BrokerServices,
   ResultCode SpawnTarget(const wchar_t* exe_path,
                          const wchar_t* command_line,
                          std::unique_ptr<TargetPolicy> policy,
+                         ResultCode* last_warning,
                          DWORD* last_error,
                          PROCESS_INFORMATION* target) override;
   ResultCode WaitForAllTargets() override;
diff --git a/sandbox/win/src/file_policy_test.cc b/sandbox/win/src/file_policy_test.cc
index a28f5bd33a7f1..656be76a2de0b 100644
--- a/sandbox/win/src/file_policy_test.cc
+++ b/sandbox/win/src/file_policy_test.cc
@@ -11,6 +11,7 @@
 #include <winternl.h>
 
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/filesystem_policy.h"
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/sandbox.h"
@@ -717,6 +718,11 @@ TEST(FilePolicyTest, CheckMissingNTPrefixEscape) {
 }
 
 TEST(FilePolicyTest, TestCopyFile) {
+  // Check if the test is running Win8 or newer since
+  // MITIGATION_STRICT_HANDLE_CHECKS is not supported on older systems.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   TestRunner runner;
   runner.SetTimeout(2000);
 
diff --git a/sandbox/win/src/filesystem_policy.cc b/sandbox/win/src/filesystem_policy.cc
index 1685cf59f265a..78435aac85a25 100644
--- a/sandbox/win/src/filesystem_policy.cc
+++ b/sandbox/win/src/filesystem_policy.cc
@@ -15,6 +15,7 @@
 #include "base/notreached.h"
 #include "base/win/scoped_handle.h"
 #include "sandbox/win/src/internal_types.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/ipc_tags.h"
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/policy_engine_opcodes.h"
diff --git a/sandbox/win/src/handle_closer.cc b/sandbox/win/src/handle_closer.cc
index 3a60272f0c509..19403ed5460f6 100644
--- a/sandbox/win/src/handle_closer.cc
+++ b/sandbox/win/src/handle_closer.cc
@@ -12,6 +12,7 @@
 #include "base/memory/free_deleter.h"
 #include "base/numerics/checked_math.h"
 #include "base/ranges/algorithm.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/win_utils.h"
 
 namespace {
diff --git a/sandbox/win/src/handle_closer_agent.cc b/sandbox/win/src/handle_closer_agent.cc
index 11f19502adc0f..5dcb278917dc0 100644
--- a/sandbox/win/src/handle_closer_agent.cc
+++ b/sandbox/win/src/handle_closer_agent.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/win/static_constants.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/win_utils.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
@@ -149,6 +150,11 @@ bool HandleCloserAgent::CloseHandles() {
     return true;
 
   absl::optional<ProcessHandleMap> handle_map = GetCurrentProcessHandles();
+  if (!handle_map) {
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN8_1);
+    handle_map = GetCurrentProcessHandlesWin7();
+  }
+
   if (!handle_map)
     return false;
 
diff --git a/sandbox/win/src/handle_inheritance_test.cc b/sandbox/win/src/handle_inheritance_test.cc
index 9b7e3ba0d9592..44c3608e11036 100644
--- a/sandbox/win/src/handle_inheritance_test.cc
+++ b/sandbox/win/src/handle_inheritance_test.cc
@@ -7,6 +7,7 @@
 #include "base/files/file_util.h"
 #include "base/files/scoped_temp_dir.h"
 #include "base/win/scoped_handle.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/tests/common/controller.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
diff --git a/sandbox/win/src/heap_helper.cc b/sandbox/win/src/heap_helper.cc
index 2ac0928f9b6c7..907249f71765f 100644
--- a/sandbox/win/src/heap_helper.cc
+++ b/sandbox/win/src/heap_helper.cc
@@ -9,6 +9,7 @@
 #include "base/logging.h"
 #include "base/memory/raw_ptr_exclusion.h"
 #include "base/memory/ref_counted.h"
+#include "base/win/windows_version.h"
 
 namespace sandbox {
 namespace {
@@ -97,6 +98,10 @@ bool HeapFlags(HANDLE handle, DWORD* flags) {
 }
 
 HANDLE FindCsrPortHeap() {
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    // This functionality has not been verified on versions before Win10.
+    return nullptr;
+  }
   DWORD number_of_heaps = ::GetProcessHeaps(0, nullptr);
   std::unique_ptr<HANDLE[]> all_heaps(new HANDLE[number_of_heaps]);
   if (::GetProcessHeaps(number_of_heaps, all_heaps.get()) != number_of_heaps)
diff --git a/sandbox/win/src/integrity_level_test.cc b/sandbox/win/src/integrity_level_test.cc
index 5f79e53588ae7..046f0aff059dc 100644
--- a/sandbox/win/src/integrity_level_test.cc
+++ b/sandbox/win/src/integrity_level_test.cc
@@ -8,6 +8,7 @@
 
 #include "base/process/process_info.h"
 #include "base/win/access_token.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_factory.h"
 #include "sandbox/win/src/sandbox_policy.h"
diff --git a/sandbox/win/src/interception.cc b/sandbox/win/src/interception.cc
index a6fdb99719b9f..ec9dfc0590cb7 100644
--- a/sandbox/win/src/interception.cc
+++ b/sandbox/win/src/interception.cc
@@ -18,6 +18,7 @@
 #include "base/notreached.h"
 #include "base/scoped_native_library.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/internal_types.h"
@@ -431,7 +432,25 @@ ResultCode InterceptionManager::PatchClientFunctions(
   if (!ntdll_base)
     return SBOX_ERROR_NO_HANDLE;
 
-  ServiceResolverThunk thunk(child_->Process(), /*relaxed=*/true);
+  std::unique_ptr<ServiceResolverThunk> thunk;
+#if defined(_WIN64)
+  thunk = std::make_unique<ServiceResolverThunk>(child_->Process(), true);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  base::win::Version real_os_version = os_info->Kernel32Version();
+  if (os_info->IsWowX86OnAMD64()) {
+    if (real_os_version >= base::win::Version::WIN10)
+      thunk.reset(new Wow64W10ResolverThunk(child_->Process(), true));
+    else if (real_os_version >= base::win::Version::WIN8)
+      thunk.reset(new Wow64W8ResolverThunk(child_->Process(), true));
+    else
+      thunk.reset(new Wow64ResolverThunk(child_->Process(), true));
+  } else if (real_os_version >= base::win::Version::WIN8) {
+    thunk.reset(new Win8ResolverThunk(child_->Process(), true));
+  } else {
+    thunk.reset(new ServiceResolverThunk(child_->Process(), true));
+  }
+#endif
 
   for (auto interception : interceptions_) {
     const std::wstring ntdll(kNtdllName);
@@ -441,7 +460,7 @@ ResultCode InterceptionManager::PatchClientFunctions(
     if (INTERCEPTION_SERVICE_CALL != interception.type)
       return SBOX_ERROR_BAD_PARAMS;
 
-    NTSTATUS ret = thunk.Setup(
+    NTSTATUS ret = thunk->Setup(
         ntdll_base, nullptr, interception.function.c_str(),
         interception.interceptor.c_str(), interception.interceptor_address,
         &thunks->thunks[dll_data->num_thunks],
diff --git a/sandbox/win/src/job.cc b/sandbox/win/src/job.cc
index 6e1cccd11abab..36c28b20205ac 100644
--- a/sandbox/win/src/job.cc
+++ b/sandbox/win/src/job.cc
@@ -9,21 +9,25 @@
 #include <stddef.h>
 #include <utility>
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/restricted_token.h"
 
 namespace sandbox {
 
-Job::Job() = default;
-Job::~Job() = default;
+Job::Job() : job_handle_(nullptr) {}
+
+Job::~Job() {}
 
 DWORD Job::Init(JobLevel security_level,
+                const wchar_t* job_name,
                 DWORD ui_exceptions,
                 size_t memory_limit) {
-  if (job_handle_.is_valid())
+  if (job_handle_.IsValid())
     return ERROR_ALREADY_INITIALIZED;
 
-  job_handle_.Set(::CreateJobObject(nullptr, nullptr));
-  if (!job_handle_.is_valid())
+  job_handle_.Set(::CreateJobObject(nullptr,  // No security attribute
+                                    job_name));
+  if (!job_handle_.IsValid())
     return ::GetLastError();
 
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
@@ -86,20 +90,42 @@ DWORD Job::Init(JobLevel security_level,
 }
 
 bool Job::IsValid() {
-  return job_handle_.is_valid();
+  return job_handle_.IsValid();
 }
 
 HANDLE Job::GetHandle() {
-  return job_handle_.get();
+  return job_handle_.Get();
+}
+
+DWORD Job::UserHandleGrantAccess(HANDLE handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::UserHandleGrantAccess(handle, job_handle_.Get(),
+                               true)) {  // Access allowed.
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
+DWORD Job::AssignProcessToJob(HANDLE process_handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::AssignProcessToJobObject(job_handle_.Get(), process_handle))
+    return ::GetLastError();
+
+  return ERROR_SUCCESS;
 }
 
 DWORD Job::SetActiveProcessLimit(DWORD processes) {
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
 
-  if (!job_handle_.is_valid())
+  if (!job_handle_.IsValid())
     return ERROR_NO_DATA;
 
-  if (!::QueryInformationJobObject(job_handle_.get(),
+  if (!::QueryInformationJobObject(job_handle_.Get(),
                                    JobObjectExtendedLimitInformation, &jeli,
                                    sizeof(jeli), nullptr)) {
     return ::GetLastError();
@@ -107,7 +133,7 @@ DWORD Job::SetActiveProcessLimit(DWORD processes) {
   jeli.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
   jeli.BasicLimitInformation.ActiveProcessLimit = processes;
 
-  if (!::SetInformationJobObject(job_handle_.get(),
+  if (!::SetInformationJobObject(job_handle_.Get(),
                                  JobObjectExtendedLimitInformation, &jeli,
                                  sizeof(jeli))) {
     return ::GetLastError();
diff --git a/sandbox/win/src/job.h b/sandbox/win/src/job.h
index 31037e1b7aff7..e4739cf83f4b1 100644
--- a/sandbox/win/src/job.h
+++ b/sandbox/win/src/job.h
@@ -15,7 +15,8 @@ enum class JobLevel;
 // Handles the creation of job objects based on a security profile.
 // Sample usage:
 //   Job job;
-//   job.Init(JobLevel::kLockdown, 0, 0);
+//   job.Init(JobLevel::kLockdown, nullptr);  //no job name
+//   job.AssignProcessToJob(process_handle);
 class Job {
  public:
   Job();
@@ -27,12 +28,29 @@ class Job {
 
   // Initializes and creates the job object. The security of the job is based
   // on the security_level parameter.
+  // job_name can be nullptr if the job is unnamed.
   // If the chosen profile has too many ui restrictions, you can disable some
   // by specifying them in the ui_exceptions parameters.
   // If the function succeeds, the return value is ERROR_SUCCESS. If the
   // function fails, the return value is the win32 error code corresponding to
   // the error.
-  DWORD Init(JobLevel security_level, DWORD ui_exceptions, size_t memory_limit);
+  DWORD Init(JobLevel security_level,
+             const wchar_t* job_name,
+             DWORD ui_exceptions,
+             size_t memory_limit);
+
+  // Assigns the process referenced by process_handle to the job.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD AssignProcessToJob(HANDLE process_handle);
+
+  // Grants access to "handle" to the job. All processes in the job can
+  // subsequently recognize and use the handle.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD UserHandleGrantAccess(HANDLE handle);
 
   // True if the job has been initialized and has a valid handle.
   bool IsValid();
diff --git a/sandbox/win/src/job_unittest.cc b/sandbox/win/src/job_unittest.cc
index 62142702240c8..78a42dff35551 100644
--- a/sandbox/win/src/job_unittest.cc
+++ b/sandbox/win/src/job_unittest.cc
@@ -14,14 +14,26 @@ namespace sandbox {
 
 // Tests the creation and destruction of the job.
 TEST(JobTest, TestCreation) {
-  // Create the job.
-  Job job;
-  ASSERT_FALSE(job.IsValid());
-  ASSERT_EQ(nullptr, job.GetHandle());
-  ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
-            job.Init(JobLevel::kLockdown, 0, 0));
-  EXPECT_TRUE(job.IsValid());
-  EXPECT_NE(nullptr, job.GetHandle());
+  // Scope the creation of Job.
+  {
+    // Create the job.
+    Job job;
+    ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
+              job.Init(JobLevel::kLockdown, L"my_test_job_name", 0, 0));
+
+    // check if the job exists.
+    HANDLE job_handle =
+        ::OpenJobObjectW(GENERIC_ALL, false, L"my_test_job_name");
+    ASSERT_TRUE(job_handle);
+
+    if (job_handle)
+      CloseHandle(job_handle);
+  }
+
+  // Check if the job is destroyed when the object goes out of scope.
+  HANDLE job_handle = ::OpenJobObjectW(GENERIC_ALL, false, L"my_test_job_name");
+  ASSERT_TRUE(!job_handle);
+  ASSERT_EQ(static_cast<DWORD>(ERROR_FILE_NOT_FOUND), ::GetLastError());
 }
 
 // Tests the ui exceptions
@@ -31,12 +43,12 @@ TEST(JobTest, TestExceptions) {
   {
     // Create the job.
     Job job;
-    ASSERT_EQ(
-        static_cast<DWORD>(ERROR_SUCCESS),
-        job.Init(JobLevel::kLockdown, JOB_OBJECT_UILIMIT_READCLIPBOARD, 0));
+    ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
+              job.Init(JobLevel::kLockdown, L"my_test_job_name",
+                       JOB_OBJECT_UILIMIT_READCLIPBOARD, 0));
 
     job_handle = job.GetHandle();
-    ASSERT_NE(nullptr, job_handle);
+    ASSERT_TRUE(job_handle != INVALID_HANDLE_VALUE);
 
     JOBOBJECT_BASIC_UI_RESTRICTIONS jbur = {0};
     DWORD size = sizeof(jbur);
@@ -51,10 +63,10 @@ TEST(JobTest, TestExceptions) {
     // Create the job.
     Job job;
     ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
-              job.Init(JobLevel::kLockdown, 0, 0));
+              job.Init(JobLevel::kLockdown, L"my_test_job_name", 0, 0));
 
     job_handle = job.GetHandle();
-    ASSERT_NE(nullptr, job_handle);
+    ASSERT_TRUE(job_handle != INVALID_HANDLE_VALUE);
 
     JOBOBJECT_BASIC_UI_RESTRICTIONS jbur = {0};
     DWORD size = sizeof(jbur);
@@ -71,33 +83,78 @@ TEST(JobTest, DoubleInit) {
   // Create the job.
   Job job;
   ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
-            job.Init(JobLevel::kLockdown, 0, 0));
+            job.Init(JobLevel::kLockdown, L"my_test_job_name", 0, 0));
   ASSERT_EQ(static_cast<DWORD>(ERROR_ALREADY_INITIALIZED),
-            job.Init(JobLevel::kLockdown, 0, 0));
+            job.Init(JobLevel::kLockdown, L"test", 0, 0));
+}
+
+// Tests the error case when we use a method and the object is not yet
+// initialized.
+TEST(JobTest, NoInit) {
+  Job job;
+  ASSERT_EQ(static_cast<DWORD>(ERROR_NO_DATA),
+            job.UserHandleGrantAccess(nullptr));
+  ASSERT_EQ(static_cast<DWORD>(ERROR_NO_DATA), job.AssignProcessToJob(nullptr));
+  ASSERT_FALSE(job.GetHandle() == INVALID_HANDLE_VALUE);
 }
 
 // Tests the initialization of the job with different security levels.
 TEST(JobTest, SecurityLevel) {
   Job job_lockdown;
   ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
-            job_lockdown.Init(JobLevel::kLockdown, 0, 0));
+            job_lockdown.Init(JobLevel::kLockdown, L"job_lockdown", 0, 0));
 
   Job job_limited_user;
-  ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
-            job_limited_user.Init(JobLevel::kLimitedUser, 0, 0));
+  ASSERT_EQ(
+      static_cast<DWORD>(ERROR_SUCCESS),
+      job_limited_user.Init(JobLevel::kLimitedUser, L"job_limited_user", 0, 0));
 
   Job job_interactive;
-  ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
-            job_interactive.Init(JobLevel::kInteractive, 0, 0));
+  ASSERT_EQ(
+      static_cast<DWORD>(ERROR_SUCCESS),
+      job_interactive.Init(JobLevel::kInteractive, L"job_interactive", 0, 0));
 
   Job job_unprotected;
-  ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
-            job_unprotected.Init(JobLevel::kUnprotected, 0, 0));
+  ASSERT_EQ(
+      static_cast<DWORD>(ERROR_SUCCESS),
+      job_unprotected.Init(JobLevel::kUnprotected, L"job_unprotected", 0, 0));
 
   // JobLevel::kNone means we run without a job object so Init should fail.
   Job job_none;
   ASSERT_EQ(static_cast<DWORD>(ERROR_BAD_ARGUMENTS),
-            job_none.Init(JobLevel::kNone, 0, 0));
+            job_none.Init(JobLevel::kNone, L"job_none", 0, 0));
+}
+
+// Tests the method "AssignProcessToJob".
+TEST(JobTest, ProcessInJob) {
+  // Create the job.
+  Job job;
+  ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
+            job.Init(JobLevel::kUnprotected, L"job_test_process", 0, 0));
+
+  wchar_t notepad[] = L"notepad";
+  STARTUPINFO si = {sizeof(si)};
+  PROCESS_INFORMATION temp_process_info = {};
+  ASSERT_TRUE(::CreateProcess(nullptr, notepad, nullptr, nullptr, false, 0,
+                              nullptr, nullptr, &si, &temp_process_info));
+  base::win::ScopedProcessInformation pi(temp_process_info);
+  ASSERT_EQ(static_cast<DWORD>(ERROR_SUCCESS),
+            job.AssignProcessToJob(pi.process_handle()));
+
+  // Get the job handle.
+  HANDLE job_handle = job.GetHandle();
+
+  // Check if the process is in the job.
+  JOBOBJECT_BASIC_PROCESS_ID_LIST jbpidl = {0};
+  DWORD size = sizeof(jbpidl);
+  EXPECT_TRUE(::QueryInformationJobObject(
+      job_handle, JobObjectBasicProcessIdList, &jbpidl, size, &size));
+
+  EXPECT_EQ(1u, jbpidl.NumberOfAssignedProcesses);
+  EXPECT_EQ(1u, jbpidl.NumberOfProcessIdsInList);
+  EXPECT_EQ(pi.process_id(), jbpidl.ProcessIdList[0]);
+
+  EXPECT_TRUE(::TerminateProcess(pi.process_handle(), 0));
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/lpc_policy_test.cc b/sandbox/win/src/lpc_policy_test.cc
index 2c21632fbbdea..fb317d594a2bd 100644
--- a/sandbox/win/src/lpc_policy_test.cc
+++ b/sandbox/win/src/lpc_policy_test.cc
@@ -11,6 +11,7 @@
 #include <windows.h>
 #include <winioctl.h>
 
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "sandbox/win/src/heap_helper.h"
 #include "sandbox/win/src/sandbox.h"
@@ -25,11 +26,12 @@ namespace sandbox {
 namespace {
 
 bool CsrssDisconnectSupported() {
-#if defined(_WIN64) && !defined(ADDRESS_SANITIZER)
-  return true;
-#else
-  return false;
-#endif  // defined(_WIN64) && !defined(ADDRESS_SANITIZER)
+  // This functionality has not been verified on versions before Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return false;
+
+  // Does not work on 32-bit on x64 (ie Wow64).
+  return (!base::win::OSInfo::GetInstance()->IsWowX86OnAMD64());
 }
 
 }  // namespace
@@ -97,13 +99,35 @@ TEST(LpcPolicyTest, GetUserDefaultLCID) {
   EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(cmd.c_str()));
 }
 
+// GetUserDefaultLocaleName is not available on WIN XP.  So we'll
+// load it on-the-fly.
+const wchar_t kKernel32DllName[] = L"kernel32.dll";
+typedef int(WINAPI* GetUserDefaultLocaleNameFunction)(LPWSTR lpLocaleName,
+                                                      int cchLocaleName);
+
 SBOX_TESTS_COMMAND int Lpc_GetUserDefaultLocaleName(int argc, wchar_t** argv) {
   if (argc != 1)
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
   std::wstring expected_locale_name(argv[0]);
+  static GetUserDefaultLocaleNameFunction GetUserDefaultLocaleName_func =
+      nullptr;
+  if (!GetUserDefaultLocaleName_func) {
+    // GetUserDefaultLocaleName is not available on WIN XP.  So we'll
+    // load it on-the-fly.
+    HMODULE kernel32_dll = ::GetModuleHandle(kKernel32DllName);
+    if (!kernel32_dll) {
+      return SBOX_TEST_FAILED;
+    }
+    GetUserDefaultLocaleName_func =
+        reinterpret_cast<GetUserDefaultLocaleNameFunction>(
+            GetProcAddress(kernel32_dll, "GetUserDefaultLocaleName"));
+    if (!GetUserDefaultLocaleName_func) {
+      return SBOX_TEST_FAILED;
+    }
+  }
   wchar_t locale_name[LOCALE_NAME_MAX_LENGTH] = {0};
   // This will cause an exception if not warmed up suitably.
-  int ret = ::GetUserDefaultLocaleName(
+  int ret = GetUserDefaultLocaleName_func(
       locale_name, LOCALE_NAME_MAX_LENGTH * sizeof(wchar_t));
   if (!ret) {
     return SBOX_TEST_FAILED;
@@ -119,8 +143,20 @@ SBOX_TESTS_COMMAND int Lpc_GetUserDefaultLocaleName(int argc, wchar_t** argv) {
 }
 
 TEST(LpcPolicyTest, GetUserDefaultLocaleName) {
+  static GetUserDefaultLocaleNameFunction GetUserDefaultLocaleName_func =
+      nullptr;
+  if (!GetUserDefaultLocaleName_func) {
+    // GetUserDefaultLocaleName is not available on WIN XP.  So we'll
+    // load it on-the-fly.
+    HMODULE kernel32_dll = ::GetModuleHandle(kKernel32DllName);
+    EXPECT_NE(nullptr, kernel32_dll);
+    GetUserDefaultLocaleName_func =
+        reinterpret_cast<GetUserDefaultLocaleNameFunction>(
+            GetProcAddress(kernel32_dll, "GetUserDefaultLocaleName"));
+    EXPECT_NE(nullptr, GetUserDefaultLocaleName_func);
+  }
   wchar_t locale_name[LOCALE_NAME_MAX_LENGTH] = {0};
-  EXPECT_NE(0, ::GetUserDefaultLocaleName(
+  EXPECT_NE(0, GetUserDefaultLocaleName_func(
                    locale_name, LOCALE_NAME_MAX_LENGTH * sizeof(wchar_t)));
   EXPECT_NE(0U, wcsnlen(locale_name, LOCALE_NAME_MAX_LENGTH));
   std::wstring cmd =
@@ -180,10 +216,11 @@ TEST(LpcPolicyTest, TestCanFindCsrPortHeap) {
 #endif
 
 TEST(LpcPolicyTest, MAYBE_TestHeapFlags) {
-  if (!CsrssDisconnectSupported())
+  if (!CsrssDisconnectSupported()) {
+    // This functionality has not been verified on versions before Win10.
     return;
-
-  // Windows does not support callers supplying arbitrary flag values. So we
+  }
+  // Windows does not support callers supplying arbritary flag values. So we
   // write some non-trivial value to reduce the chance we match this in random
   // data.
   DWORD flags = 0x41007;
diff --git a/sandbox/win/src/named_pipe_policy_test.cc b/sandbox/win/src/named_pipe_policy_test.cc
index 373484bbdbe8e..d20b9d9943cb0 100644
--- a/sandbox/win/src/named_pipe_policy_test.cc
+++ b/sandbox/win/src/named_pipe_policy_test.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_factory.h"
 #include "sandbox/win/src/sandbox_policy.h"
diff --git a/sandbox/win/src/nt_internals.h b/sandbox/win/src/nt_internals.h
index 9a7c647254fab..b7ac166fee219 100644
--- a/sandbox/win/src/nt_internals.h
+++ b/sandbox/win/src/nt_internals.h
@@ -162,7 +162,13 @@ typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN PVOID ThreadInformation,
     IN ULONG ThreadInformationLength);
 
+typedef struct _PROCESS_ACCESS_TOKEN {
+  HANDLE token;
+  HANDLE thread;
+} PROCESS_ACCESS_TOKEN;
+
 // Partial definition only for values not in PROCESS_INFO_CLASS.
+constexpr auto ProcessInformationAccessToken = static_cast<PROCESSINFOCLASS>(9);
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
 constexpr auto ProcessHandleTable = static_cast<PROCESSINFOCLASS>(58);
diff --git a/sandbox/win/src/policy_broker.cc b/sandbox/win/src/policy_broker.cc
index e8226eea36fdd..180a34b5bc965 100644
--- a/sandbox/win/src/policy_broker.cc
+++ b/sandbox/win/src/policy_broker.cc
@@ -10,6 +10,7 @@
 
 #include "base/check.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/internal_types.h"
diff --git a/sandbox/win/src/policy_target_test.cc b/sandbox/win/src/policy_target_test.cc
index 969c4bac96478..a4ccd84fab15f 100644
--- a/sandbox/win/src/policy_target_test.cc
+++ b/sandbox/win/src/policy_target_test.cc
@@ -11,6 +11,8 @@
 #include "base/strings/string_util.h"
 #include "base/win/scoped_process_information.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
+#include "build/build_config.h"
 #include "sandbox/win/src/broker_services.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_factory.h"
@@ -271,6 +273,7 @@ TEST(PolicyTargetTest, InheritedDesktopPolicy) {
 
   // Launch the app.
   ResultCode result = SBOX_ALL_OK;
+  ResultCode warning_result = SBOX_ALL_OK;
   DWORD last_error = ERROR_SUCCESS;
   base::win::ScopedProcessInformation target;
 
@@ -279,8 +282,9 @@ TEST(PolicyTargetTest, InheritedDesktopPolicy) {
   EXPECT_EQ(SBOX_ALL_OK, policy->GetConfig()->SetTokenLevel(USER_INTERACTIVE,
                                                             USER_LOCKDOWN));
   PROCESS_INFORMATION temp_process_info = {};
-  result = broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
-                               &last_error, &temp_process_info);
+  result =
+      broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
+                          &warning_result, &last_error, &temp_process_info);
 
   EXPECT_EQ(SBOX_ALL_OK, result);
   if (result == SBOX_ALL_OK)
@@ -325,6 +329,7 @@ TEST(PolicyTargetTest, DesktopPolicy) {
 
   // Launch the app.
   ResultCode result = SBOX_ALL_OK;
+  ResultCode warning_result = SBOX_ALL_OK;
   DWORD last_error = ERROR_SUCCESS;
   base::win::ScopedProcessInformation target;
 
@@ -336,8 +341,9 @@ TEST(PolicyTargetTest, DesktopPolicy) {
   // Keep the desktop name to test against later (note - it was precreated).
   std::wstring desktop_name =
       broker->GetDesktopName(Desktop::kAlternateDesktop);
-  result = broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
-                               &last_error, &temp_process_info);
+  result =
+      broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
+                          &warning_result, &last_error, &temp_process_info);
 
   EXPECT_EQ(SBOX_ALL_OK, result);
   if (result == SBOX_ALL_OK)
@@ -389,6 +395,7 @@ TEST(PolicyTargetTest, WinstaPolicy) {
 
   // Launch the app.
   ResultCode result = SBOX_ALL_OK;
+  ResultCode warning_result = SBOX_ALL_OK;
   base::win::ScopedProcessInformation target;
 
   auto policy = broker->CreatePolicy();
@@ -400,8 +407,9 @@ TEST(PolicyTargetTest, WinstaPolicy) {
   // Keep the desktop name for later (note - it was precreated).
   std::wstring desktop_name =
       broker->GetDesktopName(Desktop::kAlternateWinstation);
-  result = broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
-                               &last_error, &temp_process_info);
+  result =
+      broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
+                          &warning_result, &last_error, &temp_process_info);
 
   EXPECT_EQ(SBOX_ALL_OK, result);
   if (result == SBOX_ALL_OK)
@@ -502,14 +510,16 @@ TEST(PolicyTargetTest, ShareHandleTest) {
 
   // Launch the app.
   ResultCode result = SBOX_ALL_OK;
+  ResultCode warning_result = SBOX_ALL_OK;
   base::win::ScopedProcessInformation target;
 
   EXPECT_EQ(SBOX_ALL_OK, policy->GetConfig()->SetTokenLevel(USER_INTERACTIVE,
                                                             USER_LOCKDOWN));
   PROCESS_INFORMATION temp_process_info = {};
   DWORD last_error = ERROR_SUCCESS;
-  result = broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
-                               &last_error, &temp_process_info);
+  result =
+      broker->SpawnTarget(prog_name, arguments.c_str(), std::move(policy),
+                          &warning_result, &last_error, &temp_process_info);
 
   EXPECT_EQ(SBOX_ALL_OK, result);
   if (result == SBOX_ALL_OK)
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index 9226fd41f058f..a23f05bee4ff3 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -37,22 +37,39 @@ namespace sandbox {
 
 namespace {
 
+// API defined in libloaderapi.h >= Win8.
+using SetDefaultDllDirectoriesFunction = decltype(&SetDefaultDllDirectories);
+
+// APIs defined in processthreadsapi.h >= Win8.
+using SetProcessMitigationPolicyFunction =
+    decltype(&SetProcessMitigationPolicy);
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+using SetThreadInformationFunction = decltype(&SetThreadInformation);
+
 // Returns a two-element array of mitigation flags supported on this machine.
+// - This function is only useful on >= base::win::Version::WIN8.
 const ULONG64* GetSupportedMitigations() {
   static ULONG64 mitigations[2] = {};
 
   // This static variable will only be initialized once.
   if (!mitigations[0] && !mitigations[1]) {
-    // NOTE: the two-element-sized input array is only supported on >= Win10
-    // RS2. If an earlier version, the second element will be left 0.
-    size_t mits_size =
-        (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
-            ? (sizeof(mitigations[0]) * 2)
-            : sizeof(mitigations[0]);
-    if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                      ProcessMitigationOptionsMask,
-                                      &mitigations, mits_size)) {
-      NOTREACHED();
+    GetProcessMitigationPolicyFunction get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+            ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (get_process_mitigation_policy) {
+      // NOTE: the two-element-sized input array is only supported on >= Win10
+      // RS2.
+      //       If an earlier version, the second element will be left 0.
+      size_t mits_size =
+          (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
+              ? (sizeof(mitigations[0]) * 2)
+              : sizeof(mitigations[0]);
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessMitigationOptionsMask,
+                                         &mitigations, mits_size)) {
+        NOTREACHED();
+      }
     }
   }
 
@@ -89,7 +106,14 @@ bool IsRunning32bitEmulatedOnArm64() {
 bool SetProcessMitigationPolicyInternal(PROCESS_MITIGATION_POLICY policy,
                                         PVOID lpBuffer,
                                         SIZE_T dwLength) {
-  PCHECK(::SetProcessMitigationPolicy(policy, lpBuffer, dwLength))
+  HMODULE module = ::GetModuleHandleA("kernel32.dll");
+  SetProcessMitigationPolicyFunction set_process_mitigation_policy_function =
+      reinterpret_cast<SetProcessMitigationPolicyFunction>(
+          ::GetProcAddress(module, "SetProcessMitigationPolicy"));
+  if (!set_process_mitigation_policy_function)
+    return false;
+
+  PCHECK(set_process_mitigation_policy_function(policy, lpBuffer, dwLength))
       << "SetProcessMitigationPolicy failed with Policy: " << policy;
 
   return true;
@@ -106,20 +130,28 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
   base::win::Version version = base::win::GetVersion();
 
   if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+    HMODULE module = ::GetModuleHandleA("kernel32.dll");
+    SetDefaultDllDirectoriesFunction set_default_dll_directories =
+        reinterpret_cast<SetDefaultDllDirectoriesFunction>(
+            ::GetProcAddress(module, "SetDefaultDllDirectories"));
+
+    // Check for SetDefaultDllDirectories since it requires KB2533623.
+    if (set_default_dll_directories) {
 #if defined(COMPONENT_BUILD)
-    const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
+      const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
 #else
-    // In a non-component build, all DLLs will be loaded manually, or via
-    // manifest definition, so these flags can be stronger. This prevents DLL
-    // planting in the application directory.
-    const DWORD directory_flags =
-        LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
+      // In a non-component build, all DLLs will be loaded manually, or via
+      // manifest definition, so these flags can be stronger. This prevents DLL
+      // planting in the application directory.
+      const DWORD directory_flags =
+          LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
 #endif
-    if (!::SetDefaultDllDirectories(directory_flags)) {
-      return false;
-    }
+      if (!set_default_dll_directories(directory_flags)) {
+        return false;
+      }
 
-    applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+      applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+    }
   }
 
   // Set the heap to terminate on corruption
@@ -162,6 +194,10 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
   }
 #endif
 
+  // This is all we can do in Win7 and below.
+  if (version < base::win::Version::WIN8)
+    return true;
+
   // Enable ASLR policies.
   if (flags & MITIGATION_RELOCATE_IMAGE) {
     PROCESS_MITIGATION_ASLR_POLICY policy = {};
@@ -225,6 +261,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_EXTENSION_POINT_DISABLE;
   }
 
+  if (version < base::win::Version::WIN8_1)
+    return true;
+
   // Enable dynamic code policies.
   if (!IsRunning32bitEmulatedOnArm64() &&
       (flags & MITIGATION_DYNAMIC_CODE_DISABLE)) {
@@ -241,6 +280,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_DYNAMIC_CODE_DISABLE;
   }
 
+  if (version < base::win::Version::WIN10)
+    return true;
+
   // Enable font policies.
   if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
     PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
@@ -355,16 +397,29 @@ bool ApplyMitigationsToCurrentThread(MitigationFlags flags) {
   if (!CanSetMitigationsPerThread(flags))
     return false;
 
-  if (base::win::GetVersion() < base::win::Version::WIN10_RS1)
+  base::win::Version version = base::win::GetVersion();
+
+  if (version < base::win::Version::WIN10_RS1)
     return true;
 
   // Enable dynamic code per-thread policies.
   if (flags & MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD) {
     DWORD thread_policy = THREAD_DYNAMIC_CODE_ALLOW;
 
+    // NOTE: SetThreadInformation API only exists on >= Win8.  Dynamically
+    //       get function handle.
+    base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+    if (!dll.is_valid())
+      return false;
+    SetThreadInformationFunction set_thread_info_function =
+        reinterpret_cast<SetThreadInformationFunction>(
+            dll.GetFunctionPointer("SetThreadInformation"));
+    if (!set_thread_info_function)
+      return false;
+
     // NOTE: Must use the pseudo-handle here, a thread HANDLE won't work.
-    if (!::SetThreadInformation(::GetCurrentThread(), ThreadDynamicCodePolicy,
-                                &thread_policy, sizeof(thread_policy))) {
+    if (!set_thread_info_function(::GetCurrentThread(), ThreadDynamicCodePolicy,
+                                  &thread_policy, sizeof(thread_policy))) {
       return false;
     }
   }
@@ -385,8 +440,14 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
   *policy_value_1 = 0;
   *policy_value_2 = 0;
 
-#if defined(_WIN64) || defined(_M_IX86)
+#if defined(_WIN64)
   *size = sizeof(*policy_flags);
+#elif defined(_M_IX86)
+  // A 64-bit flags attribute is illegal on 32-bit Win 7.
+  if (version < base::win::Version::WIN8)
+    *size = sizeof(DWORD);
+  else
+    *size = sizeof(*policy_flags);
 #else
 #error This platform is not supported.
 #endif
@@ -404,53 +465,73 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
     *policy_value_1 |= PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE;
 #endif
 
-  if (flags & MITIGATION_RELOCATE_IMAGE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
-    if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+  // Win 7
+  if (version < base::win::Version::WIN8)
+    return;
+
+  // Everything >= Win8, do not return before the end of the function where
+  // the final policy bitmap is sanity checked against what is supported on this
+  // machine.  The API required to do so is only available since Win8.
+
+  // Mitigations >= Win8:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8) {
+    if (flags & MITIGATION_RELOCATE_IMAGE) {
       *policy_value_1 |=
-          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
+      if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+        *policy_value_1 |=
+            PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+      }
     }
-  }
 
-  if (flags & MITIGATION_HEAP_TERMINATE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HEAP_TERMINATE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_BOTTOM_UP_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_BOTTOM_UP_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_WIN32K_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_WIN32K_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+  // Mitigations >= Win8.1:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8_1) {
+    if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+  // Mitigations >= Win10:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN10) {
+    if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+    }
   }
 
   // Mitigations >= Win10 TH2:
@@ -552,6 +633,15 @@ void ConvertProcessMitigationsToComponentFilter(MitigationFlags flags,
 }
 
 MitigationFlags FilterPostStartupProcessMitigations(MitigationFlags flags) {
+  base::win::Version version = base::win::GetVersion();
+
+  // Windows 7.
+  if (version < base::win::Version::WIN8) {
+    return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER |
+                    MITIGATION_HEAP_TERMINATE);
+  }
+
+  // Windows 8 and above.
   return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER);
 }
 
diff --git a/sandbox/win/src/process_mitigations_deathtest.cc b/sandbox/win/src/process_mitigations_deathtest.cc
index b00b748cedab8..1b08dfe9bffe7 100644
--- a/sandbox/win/src/process_mitigations_deathtest.cc
+++ b/sandbox/win/src/process_mitigations_deathtest.cc
@@ -8,6 +8,7 @@
 #include "base/strings/string_number_conversions_win.h"
 #include "base/strings/string_piece.h"
 #include "base/strings/string_piece_forward.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/tests/common/controller.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -57,6 +58,9 @@ SBOX_TESTS_COMMAND int CheckDeath(int argc, wchar_t** argv) {
 }
 
 TEST(ProcessMitigationsDeathTest, CheckRatchetDownOrderMatters) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    GTEST_SKIP() << "Skipping test due to unsupported Windows version";
+
   std::wstring test_command = L"CheckDeath ";
   test_command += base::NumberToWString(kRatchetDown);
   test_command += L" ";
@@ -69,6 +73,9 @@ TEST(ProcessMitigationsDeathTest, CheckRatchetDownOrderMatters) {
 }
 
 TEST(ProcessMitigationsDeathTest, CheckRatchetDownAndLockdownExclusive) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    GTEST_SKIP() << "Skipping test due to unsupported Windows version";
+
   std::wstring test_command = L"CheckDeath ";
   test_command += base::NumberToWString(kRatchetDown);
   test_command += L" ";
@@ -81,6 +88,9 @@ TEST(ProcessMitigationsDeathTest, CheckRatchetDownAndLockdownExclusive) {
 }
 
 TEST(ProcessMitigationsDeathTest, CheckRatchetDownAndLockdownExclusive2) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    GTEST_SKIP() << "Skipping test due to unsupported Windows version";
+
   std::wstring test_command = L"CheckDeath ";
   test_command += base::NumberToWString(kLockdown);
   test_command += L" ";
@@ -93,6 +103,9 @@ TEST(ProcessMitigationsDeathTest, CheckRatchetDownAndLockdownExclusive2) {
 }
 
 TEST(ProcessMitigationsDeathTest, CheckSetStartAndLockdownExclusive) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    GTEST_SKIP() << "Skipping test due to unsupported Windows version";
+
   std::wstring test_command = L"CheckDeath ";
   test_command += base::NumberToWString(kLockdown);
   test_command += L" ";
@@ -105,6 +118,9 @@ TEST(ProcessMitigationsDeathTest, CheckSetStartAndLockdownExclusive) {
 }
 
 TEST(ProcessMitigationsDeathTest, CheckSetStartAndLockdownExclusive2) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    GTEST_SKIP() << "Skipping test due to unsupported Windows version";
+
   std::wstring test_command = L"CheckDeath ";
   test_command += base::NumberToWString(kSetStart);
   test_command += L" ";
diff --git a/sandbox/win/src/process_mitigations_dyncode_unittest.cc b/sandbox/win/src/process_mitigations_dyncode_unittest.cc
index 5664a7bda233d..bbd17f691e642 100644
--- a/sandbox/win/src/process_mitigations_dyncode_unittest.cc
+++ b/sandbox/win/src/process_mitigations_dyncode_unittest.cc
@@ -413,6 +413,9 @@ SBOX_TESTS_COMMAND int TestWin10DynamicCodeWithOptOut(int argc,
 // This test validates that setting the MITIGATION_DYNAMIC_CODE_DISABLE
 // mitigation enables the setting on a process.
 TEST(ProcessMitigationsTest, CheckWin81DynamicCodePolicySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return;
+
 // TODO(crbug.com/805414): Windows ASan hotpatching requires dynamic code.
 #if !defined(ADDRESS_SANITIZER)
   std::wstring test_command = L"CheckPolicy ";
@@ -450,6 +453,9 @@ TEST(ProcessMitigationsTest, CheckWin81DynamicCodePolicySuccess) {
 // This test validates that we can meddle with dynamic code if the
 // MITIGATION_DYNAMIC_CODE_DISABLE mitigation is NOT set.
 TEST(ProcessMitigationsTest, CheckWin81DynamicCode_BaseCase) {
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return;
+
   ScopedTestMutex mutex(hooking_dll::g_hooking_dll_mutex);
 
   // Expect success, no mitigation.
@@ -461,6 +467,9 @@ TEST(ProcessMitigationsTest, CheckWin81DynamicCode_BaseCase) {
 // This test validates that setting the MITIGATION_DYNAMIC_CODE_DISABLE
 // mitigation prevents meddling with dynamic code.
 TEST(ProcessMitigationsTest, CheckWin81DynamicCode_TestMitigation) {
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return;
+
   ScopedTestMutex mutex(hooking_dll::g_hooking_dll_mutex);
 
   // Expect failure, with mitigation.
diff --git a/sandbox/win/src/process_mitigations_extensionpoints_unittest.cc b/sandbox/win/src/process_mitigations_extensionpoints_unittest.cc
index fef8581cb394b..83bdaba82aeb3 100644
--- a/sandbox/win/src/process_mitigations_extensionpoints_unittest.cc
+++ b/sandbox/win/src/process_mitigations_extensionpoints_unittest.cc
@@ -12,6 +12,7 @@
 #include "base/win/registry.h"
 #include "base/win/startup_information.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/tests/common/controller.h"
 #include "sandbox/win/tests/integration_tests/hooking_dll.h"
 #include "sandbox/win/tests/integration_tests/hooking_win_proc.h"
@@ -363,6 +364,9 @@ namespace sandbox {
 // This test validates that setting the MITIGATION_EXTENSION_POINT_DISABLE
 // mitigation enables the setting on a process.
 TEST(ProcessMitigationsTest, CheckWin8ExtensionPointPolicySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::wstring test_command = L"CheckPolicy ";
   test_command += std::to_wstring(sandbox::TESTPOLICY_EXTENSIONPOINT);
 
@@ -396,6 +400,9 @@ TEST(ProcessMitigationsTest, CheckWin8ExtensionPointPolicySuccess) {
 // MANUAL testing only.
 TEST(ProcessMitigationsTest,
      DISABLED_CheckWin8ExtensionPoint_GlobalHook_Success) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   ScopedTestMutex mutex(g_extension_point_test_mutex);
 
   TestWin8ExtensionPointHookWrapper(true /* is_success_test */,
@@ -408,6 +415,9 @@ TEST(ProcessMitigationsTest,
 // MANUAL testing only.
 TEST(ProcessMitigationsTest,
      DISABLED_CheckWin8ExtensionPoint_GlobalHook_Failure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   ScopedTestMutex mutex(g_extension_point_test_mutex);
 
   TestWin8ExtensionPointHookWrapper(false /* is_success_test */,
@@ -419,6 +429,9 @@ TEST(ProcessMitigationsTest,
 //
 // MANUAL testing only.
 TEST(ProcessMitigationsTest, DISABLED_CheckWin8ExtensionPoint_Hook_Success) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   ScopedTestMutex mutex(g_extension_point_test_mutex);
 
   TestWin8ExtensionPointHookWrapper(true /* is_success_test */,
@@ -433,6 +446,9 @@ TEST(ProcessMitigationsTest, DISABLED_CheckWin8ExtensionPoint_Hook_Success) {
 //
 // MANUAL testing only.
 TEST(ProcessMitigationsTest, DISABLED_CheckWin8ExtensionPoint_Hook_Failure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   ScopedTestMutex mutex(g_extension_point_test_mutex);
 
   TestWin8ExtensionPointHookWrapper(false /* is_success_test */,
@@ -445,6 +461,9 @@ TEST(ProcessMitigationsTest, DISABLED_CheckWin8ExtensionPoint_Hook_Failure) {
 // MANUAL testing only.
 // Must run this test as admin/elevated.
 TEST(ProcessMitigationsTest, DISABLED_CheckWin8ExtensionPoint_AppInit_Success) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   ScopedTestMutex mutex(g_extension_point_test_mutex);
 
   TestWin8ExtensionPointAppInitWrapper(true /* is_success_test */);
@@ -456,6 +475,9 @@ TEST(ProcessMitigationsTest, DISABLED_CheckWin8ExtensionPoint_AppInit_Success) {
 // MANUAL testing only.
 // Must run this test as admin/elevated.
 TEST(ProcessMitigationsTest, DISABLED_CheckWin8ExtensionPoint_AppInit_Failure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   ScopedTestMutex mutex(g_extension_point_test_mutex);
 
   TestWin8ExtensionPointAppInitWrapper(false /* is_success_test */);
diff --git a/sandbox/win/src/process_mitigations_unittest.cc b/sandbox/win/src/process_mitigations_unittest.cc
index 5da1243e64ada..38f332802dc2e 100644
--- a/sandbox/win/src/process_mitigations_unittest.cc
+++ b/sandbox/win/src/process_mitigations_unittest.cc
@@ -35,6 +35,22 @@
 
 namespace {
 
+//------------------------------------------------------------------------------
+// Internal Defines & Functions
+//------------------------------------------------------------------------------
+
+// API defined in winbase.h.
+using GetProcessDEPPolicyFunction = decltype(&GetProcessDEPPolicy);
+
+// API defined in processthreadsapi.h.
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+GetProcessMitigationPolicyFunction get_process_mitigation_policy;
+
+// APIs defined in wingdi.h.
+using AddFontMemResourceExFunction = decltype(&AddFontMemResourceEx);
+using RemoveFontMemResourceExFunction = decltype(&RemoveFontMemResourceEx);
+
 //------------------------------------------------------------------------------
 // NonSystemFont test helper function.
 //
@@ -158,6 +174,12 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
   if (!test)
     return SBOX_TEST_INVALID_PARAMETER;
 
+  get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
   switch (test) {
     //--------------------------------------------------
     // MITIGATION_DEP
@@ -167,8 +189,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
 #if !defined(_WIN64)
       // DEP - always enabled on 64-bit.
       PROCESS_MITIGATION_DEP_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(), ProcessDEPPolicy,
-                                        &policy, sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessDEPPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.Enable || !policy.Permanent)
@@ -182,9 +205,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_ASLR): {
       PROCESS_MITIGATION_ASLR_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessASLRPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessASLRPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.EnableForceRelocateImages || !policy.DisallowStrippedImages)
@@ -197,9 +220,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_STRICTHANDLE): {
       PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessStrictHandleCheckPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessStrictHandleCheckPolicy,
+                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.RaiseExceptionOnInvalidHandleReference ||
@@ -214,9 +237,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_WIN32K): {
       PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessSystemCallDisablePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessSystemCallDisablePolicy,
+                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.DisallowWin32kSystemCalls)
@@ -233,9 +256,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_EXTENSIONPOINT): {
       PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessExtensionPointDisablePolicy,
-                                        &policy, sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessExtensionPointDisablePolicy,
+                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.DisableExtensionPoints)
@@ -248,9 +271,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODE): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessDynamicCodePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessDynamicCodePolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.ProhibitDynamicCode)
@@ -263,9 +286,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_NONSYSFONT): {
       PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessFontDisablePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessFontDisablePolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.DisableNonSystemFonts)
@@ -278,9 +301,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_MSSIGNED): {
       PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessSignaturePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessSignaturePolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.MicrosoftSignedOnly)
@@ -293,9 +316,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOREMOTE): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessImageLoadPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessImageLoadPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.NoRemoteImages)
@@ -308,9 +331,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOLOW): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessImageLoadPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessImageLoadPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.NoLowMandatoryLabelImages)
@@ -323,9 +346,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODEOPTOUT): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessDynamicCodePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessDynamicCodePolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.ProhibitDynamicCode || !policy.AllowThreadOptOut)
@@ -338,9 +361,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADPREFERSYS32): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessImageLoadPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessImageLoadPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.PreferSystem32Images)
@@ -363,9 +386,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDISABLED): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessUserShadowStackPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessUserShadowStackPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       // We wish to disable the policy.
@@ -379,9 +402,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDYNAMICAPIS): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessUserShadowStackPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessUserShadowStackPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
 
@@ -402,9 +425,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETSTRICT): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessUserShadowStackPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessUserShadowStackPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
 
@@ -442,9 +465,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     case (TESTPOLICY_PREANDPOSTSTARTUP): {
       // Both policies should be set now.
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessImageLoadPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessImageLoadPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.NoLowMandatoryLabelImages)
@@ -463,6 +486,44 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
   return SBOX_TEST_SUCCEEDED;
 }
 
+SBOX_TESTS_COMMAND int CheckDep(int argc, wchar_t** argv) {
+  GetProcessDEPPolicyFunction get_process_dep_policy =
+      reinterpret_cast<GetProcessDEPPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessDEPPolicy"));
+  if (get_process_dep_policy) {
+    BOOL is_permanent = false;
+    DWORD dep_flags = 0;
+
+    if (!get_process_dep_policy(::GetCurrentProcess(), &dep_flags,
+                                &is_permanent)) {
+      return SBOX_TEST_FIRST_ERROR;
+    }
+
+    if (!(dep_flags & PROCESS_DEP_ENABLE) || !is_permanent)
+      return SBOX_TEST_SECOND_ERROR;
+
+  } else {
+    ULONG size = 0;
+    ULONG dep_flags = 0;
+    if (!SUCCEEDED(GetNtExports()->QueryInformationProcess(
+            ::GetCurrentProcess(), ProcessExecuteFlags, &dep_flags,
+            sizeof(dep_flags), &size))) {
+      return SBOX_TEST_THIRD_ERROR;
+    }
+
+    static const int MEM_EXECUTE_OPTION_DISABLE = 2;
+    static const int MEM_EXECUTE_OPTION_PERMANENT = 8;
+    dep_flags &= 0xff;
+
+    if (dep_flags !=
+        (MEM_EXECUTE_OPTION_DISABLE | MEM_EXECUTE_OPTION_PERMANENT)) {
+      return SBOX_TEST_FOURTH_ERROR;
+    }
+  }
+
+  return SBOX_TEST_SUCCEEDED;
+}
+
 // ForceMsSigned tests:
 // Try to load the DLL given in arg1.
 SBOX_TESTS_COMMAND int TestDllLoad(int argc, wchar_t** argv) {
@@ -481,11 +542,30 @@ SBOX_TESTS_COMMAND int TestDllLoad(int argc, wchar_t** argv) {
 
 // This test attempts a non-system font load.
 //
+// 1) Load gdi32.dll for required font APIs.
+// 2) Load file contents of font file passed in arg1 into memory.
+// 3) Call API to try loading a non-system font.
+//
 // Arg1: Full path to font file to try loading.
 SBOX_TESTS_COMMAND int CheckWin10FontLoad(int argc, wchar_t** argv) {
   if (argc < 1)
     return SBOX_TEST_INVALID_PARAMETER;
 
+  HMODULE gdi_module = ::LoadLibraryW(L"gdi32.dll");
+  if (!gdi_module)
+    return SBOX_TEST_NOT_FOUND;
+
+  AddFontMemResourceExFunction add_font_mem_resource =
+      reinterpret_cast<AddFontMemResourceExFunction>(
+          ::GetProcAddress(gdi_module, "AddFontMemResourceEx"));
+
+  RemoveFontMemResourceExFunction rem_font_mem_resource =
+      reinterpret_cast<RemoveFontMemResourceExFunction>(
+          ::GetProcAddress(gdi_module, "RemoveFontMemResourceEx"));
+
+  if (!add_font_mem_resource || !rem_font_mem_resource)
+    return SBOX_TEST_NOT_FOUND;
+
   // Open font file passed in as an argument.
   base::File file(base::FilePath(argv[0]),
                   base::File::FLAG_OPEN | base::File::FLAG_READ);
@@ -506,12 +586,12 @@ SBOX_TESTS_COMMAND int CheckWin10FontLoad(int argc, wchar_t** argv) {
     return SBOX_TEST_NOT_FOUND;
 
   DWORD font_count = 0;
-  HANDLE font_handle = ::AddFontMemResourceEx(
-      &font_data[0], static_cast<DWORD>(font_data.size()), nullptr,
-      &font_count);
+  HANDLE font_handle =
+      add_font_mem_resource(&font_data[0], static_cast<DWORD>(font_data.size()),
+                            nullptr, &font_count);
 
   if (font_handle) {
-    ::RemoveFontMemResourceEx(font_handle);
+    rem_font_mem_resource(font_handle);
     return SBOX_TEST_SUCCEEDED;
   }
 
@@ -571,24 +651,35 @@ SBOX_TESTS_COMMAND int TestChildProcess(int argc, wchar_t** argv) {
   }
   // Process failed to be created.
   // Note: GetLastError from CreateProcess returns 5, "ERROR_ACCESS_DENIED".
-  // Validate the NoChildProcessCreation policy is applied.
-  PROCESS_MITIGATION_CHILD_PROCESS_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                    ProcessChildProcessPolicy, &policy,
-                                    sizeof(policy))) {
-    return SBOX_TEST_NOT_FOUND;
-  }
-  if (!policy.NoChildProcessCreation) {
-    return SBOX_TEST_FIRST_ERROR;
-  } else {
-    return SBOX_TEST_SECOND_ERROR;
-  }
+  return SBOX_TEST_FAILED;
 }
 
 //------------------------------------------------------------------------------
 // Exported Mitigation Tests
 //------------------------------------------------------------------------------
 
+//------------------------------------------------------------------------------
+// DEP (MITIGATION_DEP and MITIGATION_DEP_NO_ATL_THUNK)
+// Win7 x86
+//------------------------------------------------------------------------------
+
+#if !defined(_WIN64)
+// DEP is always enabled on 64-bit.  Only test on x86.
+TEST(ProcessMitigationsTest, CheckDepWin7) {
+  if (base::win::GetVersion() > base::win::Version::WIN7)
+    return;
+
+  TestRunner runner;
+  sandbox::TargetConfig* config = runner.GetPolicy()->GetConfig();
+
+  EXPECT_EQ(config->SetProcessMitigations(MITIGATION_DEP |
+                                          MITIGATION_DEP_NO_ATL_THUNK |
+                                          MITIGATION_SEHOP),
+            SBOX_ALL_OK);
+  EXPECT_EQ(SBOX_TEST_SUCCEEDED, runner.RunTest(L"CheckDep"));
+}
+#endif  // !defined(_WIN64)
+
 //------------------------------------------------------------------------------
 // DEP (MITIGATION_DEP and MITIGATION_DEP_NO_ATL_THUNK)
 // >= Win8 x86
@@ -600,12 +691,7 @@ SBOX_TESTS_COMMAND int TestChildProcess(int argc, wchar_t** argv) {
 // This test validates that setting the MITIGATION_DEP*
 // mitigations enables the setting on a process.
 TEST(ProcessMitigationsTest, CheckDepWin8PolicySuccess) {
-  DWORD flags;
-  BOOL permanent;
-  ASSERT_TRUE(::GetProcessDEPPolicy(::GetCurrentProcess(), &flags, &permanent));
-  // If DEP is enabled permanently these tests are meaningless. Just ignore them
-  // for this system.
-  if (permanent)
+  if (base::win::GetVersion() < base::win::Version::WIN8)
     return;
 
   std::wstring test_command = L"CheckPolicy ";
@@ -646,6 +732,9 @@ TEST(ProcessMitigationsTest, CheckDepWin8PolicySuccess) {
 //------------------------------------------------------------------------------
 
 TEST(ProcessMitigationsTest, CheckWin8AslrPolicySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::wstring test_command = L"CheckPolicy ";
   test_command += std::to_wstring(TESTPOLICY_ASLR);
 
@@ -671,6 +760,9 @@ TEST(ProcessMitigationsTest, CheckWin8AslrPolicySuccess) {
 //------------------------------------------------------------------------------
 
 TEST(ProcessMitigationsTest, CheckWin8StrictHandlePolicySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::wstring test_command = L"CheckPolicy ";
   test_command += std::to_wstring(TESTPOLICY_STRICTHANDLE);
 
@@ -695,6 +787,9 @@ TEST(ProcessMitigationsTest, CheckWin8StrictHandlePolicySuccess) {
 // This test validates that setting the MITIGATION_NON_SYSTEM_FONTS_DISABLE
 // mitigation enables the setting on a process.
 TEST(ProcessMitigationsTest, CheckWin10NonSystemFontLockDownPolicySuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   std::wstring test_command = L"CheckPolicy ";
   test_command += std::to_wstring(TESTPOLICY_NONSYSFONT);
 
@@ -723,12 +818,18 @@ TEST(ProcessMitigationsTest, CheckWin10NonSystemFontLockDownPolicySuccess) {
 // This test validates that we can load a non-system font if the
 // MITIGATION_NON_SYSTEM_FONTS_DISABLE mitigation is NOT set.
 TEST(ProcessMitigationsTest, CheckWin10NonSystemFontLockDownLoadSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   TestWin10NonSystemFont(true /* is_success_test */);
 }
 
 // This test validates that setting the MITIGATION_NON_SYSTEM_FONTS_DISABLE
 // mitigation prevents the loading of a non-system font.
 TEST(ProcessMitigationsTest, CheckWin10NonSystemFontLockDownLoadFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   TestWin10NonSystemFont(false /* is_success_test */);
 }
 
@@ -1081,10 +1182,14 @@ TEST(ProcessMitigationsTest, CetDisablePolicy) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -1121,10 +1226,14 @@ TEST(ProcessMitigationsTest, CetAllowDynamicApis) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -1159,10 +1268,14 @@ TEST(ProcessMitigationsTest, CetStrictMode) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -1329,6 +1442,9 @@ TEST(ProcessMitigationsTest, SetPreAndPostStartupSamePolicy_ImageLoad) {
 // This test validates setting a pre-startup mitigation and a post startup
 // mitigation on the same windows policy works in release and crashes in debug.
 TEST(ProcessMitigationsTest, SetPreAndPostStartupSamePolicy_ProcessDep) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::wstring test_command = L"CheckPolicy ";
   test_command += base::NumberToWString(TESTPOLICY_DEP);
 
@@ -1351,6 +1467,9 @@ TEST(ProcessMitigationsTest, SetPreAndPostStartupSamePolicy_ProcessDep) {
 // This test validates setting a pre-startup mitigation and a post startup
 // mitigation on the same windows policy works in release and crashes in debug.
 TEST(ProcessMitigationsTest, SetPreAndPostStartupSamePolicy_ASLR) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::wstring test_command = L"CheckPolicy ";
   test_command += base::NumberToWString(TESTPOLICY_ASLR);
 
diff --git a/sandbox/win/src/process_mitigations_win32k_dispatcher.cc b/sandbox/win/src/process_mitigations_win32k_dispatcher.cc
index 4fb3b5b76bb65..d637e32a5b576 100644
--- a/sandbox/win/src/process_mitigations_win32k_dispatcher.cc
+++ b/sandbox/win/src/process_mitigations_win32k_dispatcher.cc
@@ -10,6 +10,7 @@
 #include "base/memory/platform_shared_memory_region.h"
 #include "base/memory/unsafe_shared_memory_region.h"
 #include "base/unguessable_token.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/ipc_tags.h"
diff --git a/sandbox/win/src/process_mitigations_win32k_unittest.cc b/sandbox/win/src/process_mitigations_win32k_unittest.cc
index 1895b900a8a99..18e37e3cf2a5c 100644
--- a/sandbox/win/src/process_mitigations_win32k_unittest.cc
+++ b/sandbox/win/src/process_mitigations_win32k_unittest.cc
@@ -7,6 +7,7 @@
 #include <windows.h>
 
 #include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/process_mitigations_win32k_policy.h"
 #include "sandbox/win/tests/common/controller.h"
@@ -23,6 +24,9 @@ namespace sandbox {
 // the target process causes the launch to fail in process initialization.
 // The test process itself links against user32/gdi32.
 TEST(ProcessMitigationsWin32kTest, CheckWin8LockDownFailure) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::wstring test_policy_command = L"CheckPolicy ";
   test_policy_command += std::to_wstring(TESTPOLICY_WIN32K);
 
@@ -40,6 +44,9 @@ TEST(ProcessMitigationsWin32kTest, CheckWin8LockDownFailure) {
 // The test process itself links against user32/gdi32.
 
 TEST(ProcessMitigationsWin32kTest, CheckWin8LockDownSuccess) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::wstring test_policy_command = L"CheckPolicy ";
   test_policy_command += std::to_wstring(TESTPOLICY_WIN32K);
 
diff --git a/sandbox/win/src/process_policy_test.cc b/sandbox/win/src/process_policy_test.cc
index 7cfbc00568bb9..2291fdc8898d0 100644
--- a/sandbox/win/src/process_policy_test.cc
+++ b/sandbox/win/src/process_policy_test.cc
@@ -9,6 +9,7 @@
 #include "base/strings/sys_string_conversions.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/scoped_process_information.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "sandbox/win/src/process_thread_interception.h"
 #include "sandbox/win/src/sandbox.h"
diff --git a/sandbox/win/src/process_thread_interception.cc b/sandbox/win/src/process_thread_interception.cc
index 1cbb219eb0164..7baeebd1d9e32 100644
--- a/sandbox/win/src/process_thread_interception.cc
+++ b/sandbox/win/src/process_thread_interception.cc
@@ -6,6 +6,7 @@
 
 #include <stdint.h>
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/ipc_tags.h"
 #include "sandbox/win/src/policy_params.h"
diff --git a/sandbox/win/src/restricted_token_unittest.cc b/sandbox/win/src/restricted_token_unittest.cc
index 6d34c8e785325..67983cd67808b 100644
--- a/sandbox/win/src/restricted_token_unittest.cc
+++ b/sandbox/win/src/restricted_token_unittest.cc
@@ -18,6 +18,7 @@
 #include "base/win/security_descriptor.h"
 #include "base/win/security_util.h"
 #include "base/win/sid.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/acl.h"
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -509,6 +510,8 @@ TEST(RestrictedTokenTest, LockdownDefaultDaclNoLogonSid) {
 }
 
 TEST(RestrictedTokenTest, LowBoxToken) {
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   base::win::ScopedHandle token;
 
   auto package_sid = *base::win::Sid::FromSddlString(L"S-1-15-2-1-2-3-4-5-6-7");
diff --git a/sandbox/win/src/restricted_token_utils.cc b/sandbox/win/src/restricted_token_utils.cc
index 72605d341781a..419dea57a5991 100644
--- a/sandbox/win/src/restricted_token_utils.cc
+++ b/sandbox/win/src/restricted_token_utils.cc
@@ -13,6 +13,8 @@
 #include "base/win/scoped_handle.h"
 #include "base/win/security_descriptor.h"
 #include "sandbox/win/src/acl.h"
+#include "base/win/windows_version.h"
+#include "sandbox/win/src/job.h"
 #include "sandbox/win/src/restricted_token.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/security_level.h"
@@ -23,11 +25,40 @@ namespace sandbox {
 
 namespace {
 
+DWORD GetObjectSecurityDescriptor(HANDLE handle,
+                                  SECURITY_INFORMATION security_info,
+                                  std::vector<char>* security_desc_buffer,
+                                  PSECURITY_DESCRIPTOR* security_desc) {
+  DWORD last_error = 0;
+  DWORD length_needed = 0;
+
+  ::GetKernelObjectSecurity(handle, security_info, nullptr, 0, &length_needed);
+  last_error = ::GetLastError();
+  if (last_error != ERROR_INSUFFICIENT_BUFFER)
+    return last_error;
+
+  security_desc_buffer->resize(length_needed);
+  *security_desc =
+      reinterpret_cast<PSECURITY_DESCRIPTOR>(security_desc_buffer->data());
+
+  if (!::GetKernelObjectSecurity(handle, security_info, *security_desc,
+                                 length_needed, &length_needed)) {
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
 void AddSidException(std::vector<base::win::Sid>& sids,
                      base::win::WellKnownSid known_sid) {
   sids.push_back(base::win::Sid::FromKnownSid(known_sid));
 }
 
+typedef BOOL(WINAPI* CreateAppContainerTokenFunction)(
+    HANDLE TokenHandle,
+    PSECURITY_CAPABILITIES SecurityCapabilities,
+    PHANDLE OutToken);
+
 }  // namespace
 
 absl::optional<base::win::AccessToken> CreateRestrictedToken(
@@ -191,64 +222,77 @@ DWORD HardenTokenIntegrityLevelPolicy(const base::win::AccessToken& token) {
   return ERROR_SUCCESS;
 }
 
-bool CreateLowBoxToken(HANDLE base_token,
+DWORD CreateLowBoxToken(HANDLE base_token,
                        TokenType token_type,
                        const base::win::Sid& package_sid,
-                       const std::vector<base::win::Sid>& capabilities,
+                        SECURITY_CAPABILITIES* security_capabilities,
                        base::win::ScopedHandle* token) {
-  if (!token) {
-    return false;
-  }
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return ERROR_CALL_NOT_IMPLEMENTED;
+
+  if (token_type != sandbox::TokenType::kPrimary && token_type != sandbox::TokenType::kImpersonation)
+    return ERROR_INVALID_PARAMETER;
+
+  if (!token)
+    return ERROR_INVALID_PARAMETER;
+
+  CreateAppContainerTokenFunction CreateAppContainerToken =
+      reinterpret_cast<CreateAppContainerTokenFunction>(::GetProcAddress(
+          ::GetModuleHandle(L"kernelbase.dll"), "CreateAppContainerToken"));
+  if (!CreateAppContainerToken)
+    return ::GetLastError();
 
-  absl::optional<base::win::AccessToken> base_token_handle;
+  base::win::ScopedHandle base_token_handle;
   if (!base_token) {
-    base_token_handle = base::win::AccessToken::FromCurrentProcess(
-        /*impersonation=*/false, TOKEN_DUPLICATE);
-  } else {
-    base_token_handle =
-        base::win::AccessToken::FromToken(base_token, TOKEN_DUPLICATE);
+    HANDLE process_token = nullptr;
+    if (!::OpenProcessToken(::GetCurrentProcess(), TOKEN_ALL_ACCESS,
+                            &process_token)) {
+      return ::GetLastError();
+    }
+    base_token_handle.Set(process_token);
+    base_token = process_token;
   }
-  if (!base_token_handle.has_value()) {
-    return false;
+  HANDLE token_lowbox = nullptr;
+  if (!CreateAppContainerToken(base_token, security_capabilities,
+                               &token_lowbox)) {
+    return ::GetLastError();
   }
 
-  absl::optional<base::win::AccessToken> token_lowbox =
-      base_token_handle->CreateAppContainer(package_sid, capabilities,
-                                            TOKEN_ALL_ACCESS);
-  if (!token_lowbox.has_value()) {
-    return false;
-  }
+  base::win::ScopedHandle token_lowbox_handle(token_lowbox);
+  DCHECK(token_lowbox_handle.IsValid());
 
-  // Default from CreateAppContainer is a Primary token.
-  if (token_type == TokenType::kPrimary) {
-    *token = token_lowbox->release();
-    return true;
+  // Default from CreateAppContainerToken is a Primary token.
+  if (token_type == sandbox::TokenType::kPrimary) {
+    *token = std::move(token_lowbox_handle);
+    return ERROR_SUCCESS;
   }
 
-  absl::optional<base::win::AccessToken> token_dup =
-      token_lowbox->DuplicateImpersonation(
-          base::win::SecurityImpersonationLevel::kImpersonation,
-          TOKEN_ALL_ACCESS);
-  if (!token_dup.has_value()) {
-    return false;
+  HANDLE dup_handle = nullptr;
+  if (!::DuplicateTokenEx(token_lowbox_handle.Get(), TOKEN_ALL_ACCESS, nullptr,
+                          ::SecurityImpersonation, ::TokenImpersonation,
+                          &dup_handle)) {
+    return ::GetLastError();
   }
 
-  absl::optional<base::win::SecurityDescriptor> sd =
-      base::win::SecurityDescriptor::FromHandle(
-          token_lowbox->get(), base::win::SecurityObjectType::kKernel,
-          DACL_SECURITY_INFORMATION);
-  if (!sd) {
-    return false;
+  // Copy security descriptor from primary token as the new object will have
+  // the DACL from the current token's default DACL.
+  base::win::ScopedHandle token_for_sd(dup_handle);
+  std::vector<char> security_desc_buffer;
+  PSECURITY_DESCRIPTOR security_desc = nullptr;
+  DWORD last_error = GetObjectSecurityDescriptor(
+      token_lowbox_handle.Get(), DACL_SECURITY_INFORMATION,
+      &security_desc_buffer, &security_desc);
+  if (last_error != ERROR_SUCCESS)
+    return last_error;
+
+  if (!::SetKernelObjectSecurity(token_for_sd.Get(), DACL_SECURITY_INFORMATION,
+                                 security_desc)) {
+    return ::GetLastError();
   }
 
-  if (!sd->WriteToHandle(token_dup->get(),
-                         base::win::SecurityObjectType::kKernel,
-                         DACL_SECURITY_INFORMATION)) {
-    return false;
-  }
+  *token = std::move(token_for_sd);
 
-  *token = token_dup->release();
-  return true;
+  return ERROR_SUCCESS;
 }
 
 bool CanLowIntegrityAccessDesktop() {
diff --git a/sandbox/win/src/restricted_token_utils.h b/sandbox/win/src/restricted_token_utils.h
index 386edddfb4290..927cb7181bc52 100644
--- a/sandbox/win/src/restricted_token_utils.h
+++ b/sandbox/win/src/restricted_token_utils.h
@@ -62,10 +62,10 @@ DWORD HardenTokenIntegrityLevelPolicy(const base::win::AccessToken& token);
 // `capabilities` is the list of AppContainer capabilities.
 // `token` is the output value containing the handle of the newly created
 // If the function succeeds, the return value is true.
-bool CreateLowBoxToken(HANDLE base_token,
+DWORD CreateLowBoxToken(HANDLE base_token,
                        TokenType token_type,
                        const base::win::Sid& package_sid,
-                       const std::vector<base::win::Sid>& capabilities,
+                        SECURITY_CAPABILITIES* security_capabilities,
                        base::win::ScopedHandle* token);
 
 // Returns true if a low IL token can access the current desktop, false
diff --git a/sandbox/win/src/sandbox.h b/sandbox/win/src/sandbox.h
index 37cc2da358347..6095322848d88 100644
--- a/sandbox/win/src/sandbox.h
+++ b/sandbox/win/src/sandbox.h
@@ -111,6 +111,9 @@ class [[clang::lto_visibility_public]] BrokerServices {
   //   process. This can be null if the exe_path parameter is not null.
   //   policy: This is the pointer to the policy object for the sandbox to
   //   be created.
+  //   last_warning: The argument will contain an indication on whether
+  //   the process security was initialized completely, Only set if the
+  //   process can be used without a serious compromise in security.
   //   last_error: If an error or warning is returned from this method this
   //   parameter will hold the last Win32 error value.
   //   target: returns the resulting target process information such as process
@@ -118,11 +121,10 @@ class [[clang::lto_visibility_public]] BrokerServices {
   //   responsible for closing the handles returned in this structure.
   // Returns:
   //   ALL_OK if successful. All other return values imply failure.
-  virtual ResultCode SpawnTarget(const wchar_t* exe_path,
-                                 const wchar_t* command_line,
-                                 std::unique_ptr<TargetPolicy> policy,
-                                 DWORD* last_error,
-                                 PROCESS_INFORMATION* target) = 0;
+  virtual ResultCode SpawnTarget(
+      const wchar_t* exe_path, const wchar_t* command_line,
+      std::unique_ptr<TargetPolicy> policy, ResultCode* last_warning,
+      DWORD* last_error, PROCESS_INFORMATION* target) = 0;
 
   // This call blocks (waits) for all the targets to terminate.
   // Returns:
diff --git a/sandbox/win/src/sandbox_policy_base.cc b/sandbox/win/src/sandbox_policy_base.cc
index 46aa13a57c02e..c57b7a9a9c15d 100644
--- a/sandbox/win/src/sandbox_policy_base.cc
+++ b/sandbox/win/src/sandbox_policy_base.cc
@@ -192,14 +192,18 @@ ResultCode ConfigBase::AddRuleInternal(SubSystem subsystem,
       break;
     }
     case SubSystem::kWin32kLockdown: {
-      DCHECK_EQ(MITIGATION_WIN32K_DISABLE,
-                mitigations_ & MITIGATION_WIN32K_DISABLE)
-          << "Enable MITIGATION_WIN32K_DISABLE before adding win32k policy "
-             "rules.";
-      if (!ProcessMitigationsWin32KLockdownPolicy::GenerateRules(
-              pattern, semantics, policy_maker_.get())) {
-        NOTREACHED();
-        return SBOX_ERROR_BAD_PARAMS;
+      // Win32k intercept rules only supported on Windows 8 and above. This must
+      // match the version checks in process_mitigations.cc for consistency.
+      if (base::win::GetVersion() >= base::win::Version::WIN8) {
+        DCHECK_EQ(MITIGATION_WIN32K_DISABLE,
+                  mitigations_ & MITIGATION_WIN32K_DISABLE)
+            << "Enable MITIGATION_WIN32K_DISABLE before adding win32k policy "
+               "rules.";
+        if (!ProcessMitigationsWin32KLockdownPolicy::GenerateRules(
+                pattern, semantics, policy_maker_.get())) {
+          NOTREACHED();
+          return SBOX_ERROR_BAD_PARAMS;
+        }
       }
       break;
     }
@@ -395,11 +399,12 @@ ResultCode ConfigBase::SetDisconnectCsrss() {
 // CreateThread EAT patch used when this is enabled.
 // See https://crbug.com/783296#c27.
 #if defined(_WIN64) && !defined(ADDRESS_SANITIZER)
-  is_csrss_connected_ = false;
-  return AddKernelObjectToClose(L"ALPC Port", nullptr);
-#else
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    is_csrss_connected_ = false;
+    return AddKernelObjectToClose(L"ALPC Port", nullptr);
+  }
+#endif  // !defined(_WIN64)
   return SBOX_ALL_OK;
-#endif  // !defined(_WIN64) || defined(ADDRESS_SANITIZER)
 }
 
 void ConfigBase::SetDesktop(Desktop desktop) {
@@ -495,8 +500,8 @@ ResultCode PolicyBase::InitJob() {
     return SBOX_ALL_OK;
 
   // Create the Windows job object.
-  DWORD result = job_.Init(config()->GetJobLevel(), config()->ui_exceptions(),
-                           config()->memory_limit());
+  DWORD result = job_.Init(config()->GetJobLevel(), nullptr,
+                           config()->ui_exceptions(), config()->memory_limit());
   if (ERROR_SUCCESS != result)
     return SBOX_ERROR_CANNOT_INIT_JOB;
 
@@ -525,7 +530,8 @@ ResultCode PolicyBase::DropActiveProcessLimit() {
 }
 
 ResultCode PolicyBase::MakeTokens(base::win::ScopedHandle* initial,
-                                  base::win::ScopedHandle* lockdown) {
+                                  base::win::ScopedHandle* lockdown,
+                                  base::win::ScopedHandle* lowbox) {
   absl::optional<base::win::Sid> random_sid;
   if (config()->add_restricting_random_sid()) {
     random_sid = base::win::Sid::GenerateRandomSid();
@@ -547,10 +553,8 @@ ResultCode PolicyBase::MakeTokens(base::win::ScopedHandle* initial,
   AppContainerBase* app_container = config()->app_container();
   if (app_container &&
       app_container->GetAppContainerType() == AppContainerType::kLowbox) {
-    // Build the lowbox lockdown (primary) token. The initial token will be
-    // put in the same lowbox later by GetAppContainerImpersonationToken.
-    ResultCode result_code = app_container->BuildLowBoxToken(lockdown);
-    if (result_code != SBOX_ALL_OK) {
+    ResultCode result_code = app_container->BuildLowBoxToken(lowbox, lockdown);
+    if (result_code != SBOX_ALL_OK){
       return result_code;
     }
   }
diff --git a/sandbox/win/src/sandbox_policy_base.h b/sandbox/win/src/sandbox_policy_base.h
index 8239851792a81..e7343bd6b9572 100644
--- a/sandbox/win/src/sandbox_policy_base.h
+++ b/sandbox/win/src/sandbox_policy_base.h
@@ -177,8 +177,8 @@ class PolicyBase final : public TargetPolicy {
   // SetJobLevel().
   ResultCode InitJob();
 
-  // Returns the handle for this policy's job, or nullptr if the job is
-  // not initialized.
+  // Returns the handle for this policy's job, or INVALID_HANDLE_VALUE if the
+  // job is not initialized.
   HANDLE GetJobHandle();
 
   // Returns true if a job is associated with this policy.
@@ -189,9 +189,11 @@ class PolicyBase final : public TargetPolicy {
   ResultCode DropActiveProcessLimit();
 
   // Creates the two tokens with the levels specified in a previous call to
-  // SetTokenLevel().
+  // SetTokenLevel(). Also creates a lowbox token if specified based on the
+  // lowbox SID.
   ResultCode MakeTokens(base::win::ScopedHandle* initial,
-                        base::win::ScopedHandle* lockdown);
+                        base::win::ScopedHandle* lockdown,
+                        base::win::ScopedHandle* lowbox);
 
   // Applies the sandbox to |target| and takes ownership. Internally a
   // call to TargetProcess::Init() is issued.
diff --git a/sandbox/win/src/service_resolver.h b/sandbox/win/src/service_resolver.h
index d27739be108ab..4a2ae0848590a 100644
--- a/sandbox/win/src/service_resolver.h
+++ b/sandbox/win/src/service_resolver.h
@@ -53,41 +53,37 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   size_t GetThunkSize() const override;
 
   // Call this to set up ntdll_base_ which will allow for local patches.
-  void AllowLocalPatches();
+  virtual void AllowLocalPatches();
 
   // Verifies that the function specified by |target_name| in |target_module| is
   // a service and copies the data from that function into |thunk_storage|. If
   // |storage_bytes| is too small, then the method fails.
-  NTSTATUS CopyThunk(const void* target_module,
-                     const char* target_name,
-                     BYTE* thunk_storage,
-                     size_t storage_bytes,
-                     size_t* storage_used);
+  virtual NTSTATUS CopyThunk(const void* target_module,
+                             const char* target_name,
+                             BYTE* thunk_storage,
+                             size_t storage_bytes,
+                             size_t* storage_used);
 
-  // Checks if a target was patched correctly for a jump. This is only for use
-  // in testing in 32-bit builds. Will always return true on 64-bit builds. Set
-  // |thunk_storage| to the same pointer passed to Setup().
-  bool VerifyJumpTargetForTesting(void* thunk_storage) const;
-
- private:
+ protected:
   // The unit test will use this member to allow local patch on a buffer.
   HMODULE ntdll_base_;
 
   // Handle of the child process.
   HANDLE process_;
 
+ private:
   // Returns true if the code pointer by target_ corresponds to the expected
   // type of function. Saves that code on the first part of the thunk pointed
   // by local_thunk (should be directly accessible from the parent).
-  bool IsFunctionAService(void* local_thunk) const;
+  virtual bool IsFunctionAService(void* local_thunk) const;
 
   // Performs the actual patch of target_.
   // local_thunk must be already fully initialized, and the first part must
   // contain the original code. The real type of this buffer is ServiceFullThunk
   // (yes, private). remote_thunk (real type ServiceFullThunk), must be
   // allocated on the child, and will contain the thunk data, after this call.
-  // Returns the appropriate status code.
-  NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
+  // Returns the apropriate status code.
+  virtual NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
 
   // Provides basically the same functionality as IsFunctionAService but it
   // continues even if it does not recognize the function code. remote_thunk
@@ -99,6 +95,74 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   ULONG relative_jump_;
 };
 
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).
+class Wow64ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64ResolverThunk(const Wow64ResolverThunk&) = delete;
+  Wow64ResolverThunk& operator=(const Wow64ResolverThunk&) = delete;
+
+  ~Wow64ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 8.
+class Wow64W8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W8ResolverThunk(const Wow64W8ResolverThunk&) = delete;
+  Wow64W8ResolverThunk& operator=(const Wow64W8ResolverThunk&) = delete;
+
+  ~Wow64W8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on Windows 8.
+class Win8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Win8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Win8ResolverThunk(const Win8ResolverThunk&) = delete;
+  Win8ResolverThunk& operator=(const Win8ResolverThunk&) = delete;
+
+  ~Win8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 10.
+class Wow64W10ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W10ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W10ResolverThunk(const Wow64W10ResolverThunk&) = delete;
+  Wow64W10ResolverThunk& operator=(const Wow64W10ResolverThunk&) = delete;
+
+  ~Wow64W10ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_SERVICE_RESOLVER_H_
diff --git a/sandbox/win/src/service_resolver_32.cc b/sandbox/win/src/service_resolver_32.cc
index 2770225448dec..44f100220ab43 100644
--- a/sandbox/win/src/service_resolver_32.cc
+++ b/sandbox/win/src/service_resolver_32.cc
@@ -21,16 +21,43 @@ namespace {
 const BYTE kMovEax = 0xB8;
 const BYTE kMovEdx = 0xBA;
 const USHORT kMovEdxEsp = 0xD48B;
+const USHORT kCallPtrEdx = 0x12FF;
 const USHORT kCallEdx = 0xD2FF;
 const BYTE kCallEip = 0xE8;
 const BYTE kRet = 0xC2;
 const BYTE kRet2 = 0xC3;
 const USHORT kJmpEdx = 0xE2FF;
+const USHORT kXorEcx = 0xC933;
+const ULONG kLeaEdx = 0x0424548D;
+const ULONG kCallFs1 = 0xC015FF64;
+const USHORT kCallFs2 = 0;
+const BYTE kCallFs3 = 0;
+const BYTE kAddEsp1 = 0x83;
+const USHORT kAddEsp2 = 0x4C4;
 const BYTE kJmp32 = 0xE9;
 const USHORT kSysenter = 0x340F;
 
-// Service code for 32 bit Windows. Introduced in Windows 8.
-struct ServiceEntry32 {
+// Service code for 32 bit systems.
+// NOTE: on win2003 "call dword ptr [edx]" is "call edx".
+struct ServiceEntry {
+  // This struct contains roughly the following code:
+  // 00 mov     eax,25h
+  // 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)
+  // 0a call    dword ptr [edx]
+  // 0c ret     2Ch
+  // 0f nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  BYTE mov_edx;         // = BA
+  ULONG stub;
+  USHORT call_ptr_edx;  // = FF 12
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for 32 bit Windows 8.
+struct ServiceEntryW8 {
   // This struct contains the following code:
   // 00 b825000000      mov     eax,25h
   // 05 e803000000      call    eip+3
@@ -51,13 +78,60 @@ struct ServiceEntry32 {
   USHORT nop;
 };
 
-// Service code for a 32 bit process under Wow64. Introduced in Windows 10.
-// Also used for the patching process.
-struct ServiceEntryWow64 {
+// Service code for a 32 bit process running on a 64 bit os.
+struct Wow64Entry {
+  // This struct may contain one of two versions of code:
+  // 1. For XP, Vista and 2K3:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 c22c00          ret     2Ch
+  //
+  // 2. For Windows 7:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 83c404          add     esp, 4
+  // 15 c22c00          ret     2Ch
+  //
+  // So we base the structure on the bigger one:
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  USHORT xor_ecx;       // = 33 C9
+  ULONG lea_edx;        // = 8D 54 24 04
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE add_esp1;        // = 83             or ret
+  USHORT add_esp2;      // = C4 04          or num_params
+  BYTE ret;             // = C2
+  USHORT num_params;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 8.
+struct Wow64EntryW8 {
+  // 00 b825000000      mov     eax, 25h
+  // 05 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 0b c22c00          ret     2Ch
+  // 0f 90              nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 10.
+struct Wow64EntryW10 {
   // 00 b828000000      mov     eax, 28h
   // 05 bab0d54877      mov     edx, 7748D5B0h
   // 09 ffd2            call    edx
-  // 0c c22800          ret     28h
+  // 0b c22800          ret     28h
   BYTE mov_eax;         // = B8
   ULONG service_id;
   BYTE mov_edx;         // = BA
@@ -65,86 +139,27 @@ struct ServiceEntryWow64 {
   USHORT call_edx;      // = FF D2
   BYTE ret;             // = C2
   USHORT num_params;
-  BYTE nop;
 };
 
 // Make sure that relaxed patching works as expected.
-const size_t kMinServiceSize = offsetof(ServiceEntryWow64, ret);
-// Maximum size of the entry, was the size of the Windows Vista WoW64 entry.
-// Keep this fixed for compatibility reasons.
-const size_t kMaxServiceSize = 24;
-static_assert(sizeof(ServiceEntry32) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntry32) < kMaxServiceSize,
-              "wrong maximum service length");
-static_assert(sizeof(ServiceEntryWow64) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntryWow64) < kMaxServiceSize,
-              "wrong maximum service length");
+const size_t kMinServiceSize = offsetof(ServiceEntry, ret);
+static_assert(sizeof(ServiceEntryW8) >= kMinServiceSize,
+              "wrong service length");
+static_assert(sizeof(Wow64Entry) >= kMinServiceSize, "wrong service length");
+static_assert(sizeof(Wow64EntryW8) >= kMinServiceSize, "wrong service length");
 
 struct ServiceFullThunk {
   union {
-    ServiceEntryWow64 original;
-    // Pad the entry to the maximum size.
-    char dummy[kMaxServiceSize];
+    ServiceEntry original;
+    ServiceEntryW8 original_w8;
+    Wow64Entry wow_64;
+    Wow64EntryW8 wow_64_w8;
   };
   int internal_thunk;  // Dummy member to the beginning of the internal thunk.
 };
 
 #pragma pack(pop)
 
-bool IsWow64Process() {
-  // We don't need to use IsWow64Process2 as this returns the expected result
-  // when running in the ARM64 x86 emulator.
-  BOOL is_wow64 = FALSE;
-  return ::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64;
-}
-
-bool IsFunctionAService32(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntry32 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
-      function_code.call_offset != 3 || kRet != function_code.ret_p ||
-      kMovEdxEsp != function_code.mov_edx_esp ||
-      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-
-  return true;
-}
-
-bool IsFunctionAServiceWow64(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntryWow64 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
-      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-  return true;
-}
-
 }  // namespace
 
 namespace sandbox {
@@ -213,14 +228,69 @@ NTSTATUS ServiceResolverThunk::CopyThunk(const void* target_module,
 }
 
 bool ServiceResolverThunk::IsFunctionAService(void* local_thunk) const {
-  static bool is_wow64 = IsWow64Process();
-  return is_wow64 ? IsFunctionAServiceWow64(process_, target_, local_thunk)
-                  : IsFunctionAService32(process_, target_, local_thunk);
+  ServiceEntry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      (kCallPtrEdx != function_code.call_ptr_edx &&
+       kCallEdx != function_code.call_ptr_edx) ||
+      kRet != function_code.ret) {
+    return false;
+  }
+
+  // Find the system call pointer if we don't already have it.
+  if (kCallEdx != function_code.call_ptr_edx) {
+    DWORD ki_system_call;
+    if (!::ReadProcessMemory(process_,
+                             base::bit_cast<const void*>(function_code.stub),
+                             &ki_system_call, sizeof(ki_system_call), &read)) {
+      return false;
+    }
+
+    if (sizeof(ki_system_call) != read)
+      return false;
+
+    HMODULE module_1, module_2;
+    // last check, call_stub should point to a KiXXSystemCall function on ntdll
+    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                           base::bit_cast<const wchar_t*>(ki_system_call),
+                           &module_1)) {
+      return false;
+    }
+
+    if (ntdll_base_) {
+      // This path is only taken when running the unit tests. We want to be
+      // able to patch a buffer in memory, so target_ is not inside ntdll.
+      module_2 = ntdll_base_;
+    } else {
+      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                             reinterpret_cast<const wchar_t*>(target_),
+                             &module_2))
+        return false;
+    }
+
+    if (module_1 != module_2)
+      return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
 }
 
 NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
                                             void* remote_thunk) {
-  ServiceEntryWow64 intercepted_code;
+  ServiceEntry intercepted_code;
   size_t bytes_to_write = sizeof(intercepted_code);
   ServiceFullThunk* full_local_thunk =
       reinterpret_cast<ServiceFullThunk*>(local_thunk);
@@ -233,15 +303,15 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   intercepted_code.mov_eax = kMovEax;
   intercepted_code.service_id = full_local_thunk->original.service_id;
   intercepted_code.mov_edx = kMovEdx;
-  intercepted_code.mov_edx_param =
+  intercepted_code.stub =
       base::bit_cast<ULONG>(&full_remote_thunk->internal_thunk);
-  intercepted_code.call_edx = kJmpEdx;
+  intercepted_code.call_ptr_edx = kJmpEdx;
   bytes_to_write = kMinServiceSize;
 
   if (relative_jump_) {
     intercepted_code.mov_eax = kJmp32;
     intercepted_code.service_id = relative_jump_;
-    bytes_to_write = offsetof(ServiceEntryWow64, mov_edx);
+    bytes_to_write = offsetof(ServiceEntry, mov_edx);
   }
 
   // setup the thunk
@@ -277,7 +347,7 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
 
 bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
                                                 void* remote_thunk) {
-  ServiceEntryWow64 function_code;
+  ServiceEntry function_code;
   SIZE_T read;
   if (!::ReadProcessMemory(process_, target_, &function_code,
                            sizeof(function_code), &read)) {
@@ -313,18 +383,100 @@ bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
   return true;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(
-    void* thunk_storage) const {
-  const size_t kJmp32Size = 5;
-  ServiceEntryWow64* patched = static_cast<ServiceEntryWow64*>(target_);
-  if (kJmp32 != patched->mov_eax) {
+bool Wow64ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64Entry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kXorEcx != function_code.xor_ecx ||
+      kLeaEdx != function_code.lea_edx || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3) {
+    return false;
+  }
+
+  if ((kAddEsp1 == function_code.add_esp1 &&
+       kAddEsp2 == function_code.add_esp2 && kRet == function_code.ret) ||
+      kRet == function_code.add_esp1) {
+    // Save the verified code
+    memcpy(local_thunk, &function_code, sizeof(function_code));
+    return true;
+  }
+
+  return false;
+}
+
+bool Wow64W8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
     return false;
   }
 
-  ULONG source_addr = base::bit_cast<ULONG>(target_);
-  ULONG target_addr = base::bit_cast<ULONG>(thunk_storage);
-  return target_addr + kMaxServiceSize - kJmp32Size - source_addr ==
-         patched->service_id;
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3 || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
+}
+
+bool Win8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  ServiceEntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
+      function_code.call_offset != 3 || kRet != function_code.ret_p ||
+      kMovEdxEsp != function_code.mov_edx_esp ||
+      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
+}
+
+bool Wow64W10ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW10 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_64.cc b/sandbox/win/src/service_resolver_64.cc
index b96816037a221..3a14dd4b6b86b 100644
--- a/sandbox/win/src/service_resolver_64.cc
+++ b/sandbox/win/src/service_resolver_64.cc
@@ -283,8 +283,9 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   return STATUS_SUCCESS;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(void*) const {
-  return true;
+bool Wow64ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  NOTREACHED_NT();
+  return false;
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_unittest.cc b/sandbox/win/src/service_resolver_unittest.cc
index aa05e37c0c0e0..f6b787a94b5af 100644
--- a/sandbox/win/src/service_resolver_unittest.cc
+++ b/sandbox/win/src/service_resolver_unittest.cc
@@ -14,52 +14,98 @@
 #include "base/bit_cast.h"
 #include "base/memory/raw_ptr.h"
 #include "sandbox/win/src/nt_internals.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/resolver.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
 
+class ResolverThunkTest {
+ public:
+  virtual ~ResolverThunkTest() {}
+
+  virtual sandbox::ServiceResolverThunk* resolver() = 0;
+
+  // Sets the interception target to the desired address.
+  void set_target(void* target) { fake_target_ = target; }
+
+ protected:
+  // Holds the address of the fake target.
+  raw_ptr<void> fake_target_;
+};
+
 // This is the concrete resolver used to perform service-call type functions
 // inside ntdll.dll.
-class ServiceResolverTest : public sandbox::ServiceResolverThunk {
+template <typename T>
+class ResolverThunkTestImpl : public T, public ResolverThunkTest {
  public:
   // The service resolver needs a child process to write to.
-  explicit ServiceResolverTest(bool relaxed)
-      : sandbox::ServiceResolverThunk(::GetCurrentProcess(), relaxed) {}
+  explicit ResolverThunkTestImpl(bool relaxed)
+      : T(::GetCurrentProcess(), relaxed) {}
 
-  ServiceResolverTest(const ServiceResolverTest&) = delete;
-  ServiceResolverTest& operator=(const ServiceResolverTest&) = delete;
+  ResolverThunkTestImpl(const ResolverThunkTestImpl&) = delete;
+  ResolverThunkTestImpl& operator=(const ResolverThunkTestImpl&) = delete;
 
-  // Sets the interception target to the desired address.
-  void set_target(void* target) { fake_target_ = target; }
+  sandbox::ServiceResolverThunk* resolver() { return this; }
 
  protected:
   // Overrides Resolver::Init
-  NTSTATUS Init(const void* target_module,
-                const void* interceptor_module,
-                const char* target_name,
-                const char* interceptor_name,
-                const void* interceptor_entry_point,
-                void* thunk_storage,
-                size_t storage_bytes) final {
+  virtual NTSTATUS Init(const void* target_module,
+                        const void* interceptor_module,
+                        const char* target_name,
+                        const char* interceptor_name,
+                        const void* interceptor_entry_point,
+                        void* thunk_storage,
+                        size_t storage_bytes) {
     NTSTATUS ret = STATUS_SUCCESS;
-    ret = sandbox::ServiceResolverThunk::Init(
-        target_module, interceptor_module, target_name, interceptor_name,
-        interceptor_entry_point, thunk_storage, storage_bytes);
+    ret = T::Init(target_module, interceptor_module, target_name,
+                  interceptor_name, interceptor_entry_point, thunk_storage,
+                  storage_bytes);
     EXPECT_EQ(STATUS_SUCCESS, ret);
 
     this->target_ = fake_target_;
 
     return ret;
   }
-
-  // Holds the address of the fake target.
-  raw_ptr<void> fake_target_;
 };
 
+typedef ResolverThunkTestImpl<sandbox::ServiceResolverThunk> WinXpResolverTest;
+
+#if !defined(_WIN64)
+typedef ResolverThunkTestImpl<sandbox::Win8ResolverThunk> Win8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64ResolverThunk> Wow64ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W8ResolverThunk>
+    Wow64W8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W10ResolverThunk>
+    Wow64W10ResolverTest;
+#endif
+
+const BYTE kJump32 = 0xE9;
+
+void CheckJump(void* source, void* target) {
+#pragma pack(push)
+#pragma pack(1)
+  struct Code {
+    BYTE jump;
+    ULONG delta;
+  };
+#pragma pack(pop)
+
+#if defined(_WIN64)
+  FAIL() << "Running 32-bit codepath";
+#else
+  Code* patched = reinterpret_cast<Code*>(source);
+  EXPECT_EQ(kJump32, patched->jump);
+
+  ULONG source_addr = base::bit_cast<ULONG>(source);
+  ULONG target_addr = base::bit_cast<ULONG>(target);
+  EXPECT_EQ(target_addr + 19 - source_addr, patched->delta);
+#endif
+}
+
 NTSTATUS PatchNtdllWithResolver(const char* function,
                                 bool relaxed,
-                                ServiceResolverTest& resolver) {
+                                ResolverThunkTest* thunk_test) {
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   EXPECT_TRUE(ntdll_base);
 
@@ -72,20 +118,21 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
   BYTE service[50];
   memcpy(service, target, sizeof(service));
 
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
-  resolver.AllowLocalPatches();
+  resolver->AllowLocalPatches();
 
-  NTSTATUS ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                                function_entry, thunk.get(), thunk_size, &used);
+  NTSTATUS ret =
+      resolver->Setup(ntdll_base, nullptr, function, nullptr, function_entry,
+                      thunk.get(), thunk_size, &used);
   if (NT_SUCCESS(ret)) {
-    const BYTE kJump32 = 0xE9;
     EXPECT_EQ(thunk_size, used);
     EXPECT_NE(0, memcmp(service, target, sizeof(service)));
     EXPECT_NE(kJump32, service[0]);
@@ -93,18 +140,38 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
     if (relaxed) {
       // It's already patched, let's patch again, and simulate a direct patch.
       service[0] = kJump32;
-      ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                           function_entry, thunk.get(), thunk_size, &used);
-      EXPECT_TRUE(resolver.VerifyJumpTargetForTesting(thunk.get()));
+      ret = resolver->Setup(ntdll_base, nullptr, function, nullptr,
+                            function_entry, thunk.get(), thunk_size, &used);
+      CheckJump(service, thunk.get());
     }
   }
 
   return ret;
 }
 
+std::unique_ptr<ResolverThunkTest> GetTestResolver(bool relaxed) {
+#if defined(_WIN64)
+  return std::make_unique<WinXpResolverTest>(relaxed);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  if (os_info->IsWowX86OnAMD64()) {
+    if (os_info->version() >= base::win::Version::WIN10)
+      return std::make_unique<Wow64W10ResolverTest>(relaxed);
+    if (os_info->version() >= base::win::Version::WIN8)
+      return std::make_unique<Wow64W8ResolverTest>(relaxed);
+    return std::make_unique<Wow64ResolverTest>(relaxed);
+  }
+
+  if (os_info->version() >= base::win::Version::WIN8)
+    return std::make_unique<Win8ResolverTest>(relaxed);
+
+  return std::make_unique<WinXpResolverTest>(relaxed);
+#endif
+}
+
 NTSTATUS PatchNtdll(const char* function, bool relaxed) {
-  ServiceResolverTest resolver(relaxed);
-  return PatchNtdllWithResolver(function, relaxed, resolver);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(relaxed);
+  return PatchNtdllWithResolver(function, relaxed, thunk_test.get());
 }
 
 TEST(ServiceResolverTest, PatchesServices) {
@@ -155,26 +222,26 @@ TEST(ServiceResolverTest, PatchesPatchedServices) {
 TEST(ServiceResolverTest, MultiplePatchedServices) {
 // We don't support "relaxed mode" for Win64 apps.
 #if !defined(_WIN64)
-  ServiceResolverTest thunk_test(true);
-  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
+  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateFile, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateMutant, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtMapViewOfSection, last error: " << ::GetLastError();
 #endif
 }
 
 TEST(ServiceResolverTest, LocalPatchesAllowed) {
-  ServiceResolverTest resolver(true);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
 
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   ASSERT_TRUE(ntdll_base);
@@ -187,25 +254,26 @@ TEST(ServiceResolverTest, LocalPatchesAllowed) {
 
   BYTE service[50];
   memcpy(service, target, sizeof(service));
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
   NTSTATUS ret = STATUS_UNSUCCESSFUL;
 
   // First try patching without having allowed local patches.
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_FALSE(NT_SUCCESS(ret));
 
   // Now allow local patches and check that things work.
-  resolver.AllowLocalPatches();
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  resolver->AllowLocalPatches();
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_EQ(STATUS_SUCCESS, ret);
 }
 
diff --git a/sandbox/win/src/startup_information_helper.cc b/sandbox/win/src/startup_information_helper.cc
index b7688c6b74d9c..200bbe88c8a1f 100644
--- a/sandbox/win/src/startup_information_helper.cc
+++ b/sandbox/win/src/startup_information_helper.cc
@@ -68,6 +68,8 @@ void StartupInformationHelper::AddInheritedHandle(HANDLE handle) {
 
 void StartupInformationHelper::SetAppContainer(
     scoped_refptr<AppContainer> container) {
+  // Only supported for Windows 8+.
+  DCHECK(base::win::GetVersion() >= base::win::Version::WIN8);
   // LowPrivilegeAppContainer only supported for Windows 10+
   DCHECK(!container->GetEnableLowPrivilegeAppContainer() ||
          base::win::GetVersion() >= base::win::Version::WIN10_RS1);
diff --git a/sandbox/win/src/startup_information_helper.h b/sandbox/win/src/startup_information_helper.h
index 791528a1c4c6e..87ea09f4e5266 100644
--- a/sandbox/win/src/startup_information_helper.h
+++ b/sandbox/win/src/startup_information_helper.h
@@ -11,6 +11,7 @@
 
 #include "base/memory/scoped_refptr.h"
 #include "base/win/startup_information.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/app_container_base.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/security_capabilities.h"
@@ -43,7 +44,8 @@ class StartupInformationHelper {
   //        PROC_THREAD_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY
   // based on |container|. |container| should be valid.
   void SetAppContainer(scoped_refptr<AppContainer> container);
-  // Creates PROC_THREAD_ATTRIBUTE_JOB_LIST with |job_handle|.
+  // Creates PROC_THREAD_ATTRIBUTE_JOB_LIST with |job_handle|. Not valid before
+  // Windows 10.
   void AddJobToAssociate(HANDLE job_handle);
 
   // Will one or more jobs be associated via the wrapped StartupInformation.
diff --git a/sandbox/win/src/target_process.cc b/sandbox/win/src/target_process.cc
index 25a47e66ed93f..83512fabcddef 100644
--- a/sandbox/win/src/target_process.cc
+++ b/sandbox/win/src/target_process.cc
@@ -22,6 +22,7 @@
 #include "base/win/current_module.h"
 #include "base/win/security_util.h"
 #include "base/win/startup_information.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/crosscall_server.h"
 #include "sandbox/win/src/policy_low_level.h"
@@ -84,8 +85,10 @@ bool GetAppContainerImpersonationToken(
   auto app_container_sid = token->AppContainerSid();
   if (!app_container_sid)
     return false;
+
+  SecurityCapabilities security_caps(*app_container_sid, capabilities);
   return CreateLowBoxToken(initial_token, TokenType::kImpersonation,
-                           *app_container_sid, capabilities,
+                           *app_container_sid, &security_caps,
                            impersonation_token);
 }
 
@@ -102,11 +105,15 @@ SANDBOX_INTERCEPT DWORD g_sentinel_value_end = 0x424F5859;
 TargetProcess::TargetProcess(
     base::win::ScopedHandle initial_token,
     base::win::ScopedHandle lockdown_token,
+    HANDLE job,
     ThreadPool* thread_pool,
     const std::vector<base::win::Sid>& impersonation_capabilities)
-    // This object owns everything initialized here except thread_pool.
+    // This object owns everything initialized here except thread_pool and
+    // the job_ handle. The Job handle is closed by BrokerServices and results
+    // eventually in a call to our dtor.
     : lockdown_token_(std::move(lockdown_token)),
       initial_token_(std::move(initial_token)),
+      job_(job),
       thread_pool_(thread_pool),
       base_address_(nullptr),
       impersonation_capabilities_(
@@ -154,6 +161,12 @@ ResultCode TargetProcess::Create(
   if (startup_info->has_extended_startup_info())
     flags |= EXTENDED_STARTUPINFO_PRESENT;
 
+  if (job_ && base::win::GetVersion() < base::win::Version::WIN8) {
+    // Windows 8 implements nested jobs, but for older systems we need to
+    // break out of any job we're in to enforce our restrictions.
+    flags |= CREATE_BREAKAWAY_FROM_JOB;
+  }
+
   std::wstring new_env;
 
   if (startup_info_helper->IsEnvironmentFiltered()) {
@@ -196,6 +209,17 @@ ResultCode TargetProcess::Create(
   }
   base::win::ScopedProcessInformation process_info(temp_process_info);
 
+  if (job_ && !startup_info_helper->HasJobsToAssociate()) {
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN10);
+    // Assign the suspended target to the windows job object. On Win 10
+    // this happens through PROC_THREAD_ATTRIBUTE_JOB_LIST.
+    if (!::AssignProcessToJobObject(job_, process_info.process_handle())) {
+      *win_error = ::GetLastError();
+      ::TerminateProcess(process_info.process_handle(), 0);
+      return SBOX_ERROR_ASSIGN_PROCESS_TO_JOB_OBJECT;
+    }
+  }
+
   if (initial_token_.IsValid()) {
     HANDLE impersonation_token = initial_token_.Get();
     base::win::ScopedHandle app_container_token;
@@ -352,6 +376,23 @@ void TargetProcess::Terminate() {
   ::TerminateProcess(sandbox_process_info_.process_handle(), 0);
 }
 
+ResultCode TargetProcess::AssignLowBoxToken(
+    const base::win::ScopedHandle& token) {
+  if (!token.IsValid())
+    return SBOX_ALL_OK;
+  PROCESS_ACCESS_TOKEN process_access_token = {};
+  process_access_token.token = token.Get();
+
+  NTSTATUS status = GetNtExports()->SetInformationProcess(
+      sandbox_process_info_.process_handle(), ProcessInformationAccessToken,
+      &process_access_token, sizeof(process_access_token));
+  if (!NT_SUCCESS(status)) {
+    ::SetLastError(GetLastErrorFromNtStatus(status));
+    return SBOX_ERROR_SET_LOW_BOX_TOKEN;
+  }
+  return SBOX_ALL_OK;
+}
+
 ResultCode TargetProcess::VerifySentinels() {
   if (!sandbox_process_info_.IsValid())
     return SBOX_ERROR_UNEXPECTED_CALL;
@@ -385,7 +426,7 @@ std::unique_ptr<TargetProcess> TargetProcess::MakeTargetProcessForTesting(
     HANDLE process,
     HMODULE base_address) {
   auto target = std::make_unique<TargetProcess>(
-      base::win::ScopedHandle(), base::win::ScopedHandle(), nullptr,
+      base::win::ScopedHandle(), base::win::ScopedHandle(), nullptr, nullptr,
       std::vector<base::win::Sid>());
   PROCESS_INFORMATION process_info = {};
   process_info.hProcess = process;
diff --git a/sandbox/win/src/target_process.h b/sandbox/win/src/target_process.h
index 2e2678714e6c5..82c46bb674fa6 100644
--- a/sandbox/win/src/target_process.h
+++ b/sandbox/win/src/target_process.h
@@ -40,6 +40,7 @@ class TargetProcess {
   // The constructor takes ownership of |initial_token| and |lockdown_token|
   TargetProcess(base::win::ScopedHandle initial_token,
                 base::win::ScopedHandle lockdown_token,
+                HANDLE job,
                 ThreadPool* thread_pool,
                 const std::vector<base::win::Sid>& impersonation_capabilities);
 
@@ -55,6 +56,11 @@ class TargetProcess {
                     base::win::ScopedProcessInformation* target_info,
                     DWORD* win_error);
 
+  // Assign a new lowbox token to the process post creation. The process
+  // must still be in its initial suspended state, however this still
+  // might fail in the presence of third-party software.
+  ResultCode AssignLowBoxToken(const base::win::ScopedHandle& token);
+
   // Destroys the target process.
   void Terminate();
 
@@ -69,6 +75,9 @@ class TargetProcess {
   // Returns the handle to the target process.
   HANDLE Process() const { return sandbox_process_info_.process_handle(); }
 
+  // Returns the handle to the job object that the target process belongs to.
+  HANDLE Job() const { return job_; }
+
   // Returns the address of the target main exe. This is used by the
   // interceptions framework.
   HMODULE MainModule() const {
@@ -115,6 +124,10 @@ class TargetProcess {
   base::win::ScopedHandle initial_token_;
   // Kernel handle to the shared memory used by the IPC server.
   base::win::ScopedHandle shared_section_;
+  // Job object containing the target process. This is used during
+  // process creation prior to Windows 10 and to identify the process in
+  // broker_services.cc.
+  HANDLE job_;
   // Reference to the IPC subsystem.
   std::unique_ptr<SharedMemIPCServer> ipc_server_;
   // Provides the threads used by the IPC. This class does not own this pointer.
diff --git a/sandbox/win/src/target_services.cc b/sandbox/win/src/target_services.cc
index 89a902c447223..5551072f0fa2f 100644
--- a/sandbox/win/src/target_services.cc
+++ b/sandbox/win/src/target_services.cc
@@ -15,6 +15,7 @@
 #include "base/logging.h"
 #include "base/win/access_token.h"
 #include "sandbox/win/src/acl.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/handle_closer_agent.h"
 #include "sandbox/win/src/heap_helper.h"
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index adb487a297004..9e3d3a94f35e5 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -593,6 +593,36 @@ absl::optional<ProcessHandleMap> GetCurrentProcessHandles() {
   return handle_map;
 }
 
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7() {
+  DWORD handle_count = UINT_MAX;
+  const int kInvalidHandleThreshold = 100;
+  const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
+
+  if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count))
+    return absl::nullopt;
+  ProcessHandleMap handle_map;
+
+  uint32_t handle_value = 0;
+  int invalid_count = 0;
+
+  // Keep incrementing until we hit the number of handles reported by
+  // GetProcessHandleCount(). If we hit a very long sequence of invalid
+  // handles we assume that we've run past the end of the table.
+  while (handle_count && invalid_count < kInvalidHandleThreshold) {
+    handle_value += kHandleOffset;
+    HANDLE handle = base::win::Uint32ToHandle(handle_value);
+    auto type_name = GetTypeNameFromHandle(handle);
+    if (!type_name) {
+      ++invalid_count;
+      continue;
+    }
+
+    --handle_count;
+    handle_map[type_name.value()].push_back(handle);
+  }
+  return handle_map;
+}
+
 }  // namespace sandbox
 
 void ResolveNTFunctionPtr(const char* name, void* ptr) {
diff --git a/sandbox/win/src/win_utils.h b/sandbox/win/src/win_utils.h
index f3540578a3980..5d80912c48d19 100644
--- a/sandbox/win/src/win_utils.h
+++ b/sandbox/win/src/win_utils.h
@@ -123,6 +123,11 @@ void* GetProcessBaseAddress(HANDLE process);
 // use them.
 absl::optional<ProcessHandleMap> GetCurrentProcessHandles();
 
+// Fallback function for GetCurrentProcessHandles. Should only be needed on
+// Windows 7 which doesn't support the API to query all process handles. This
+// uses a brute force method to get the process handles.
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7();
+
 }  // namespace sandbox
 
 // Resolves a function name in NTDLL to a function pointer. The second parameter
diff --git a/sandbox/win/src/win_utils_unittest.cc b/sandbox/win/src/win_utils_unittest.cc
index 30eb661285dbc..62e5fc082430c 100644
--- a/sandbox/win/src/win_utils_unittest.cc
+++ b/sandbox/win/src/win_utils_unittest.cc
@@ -22,6 +22,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/scoped_process_information.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/tests/common/test_utils.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -324,7 +325,13 @@ TEST(WinUtils, GetPathAndTypeFromHandle) {
 }
 
 TEST(WinUtils, GetCurrentProcessHandles) {
-  TestCurrentProcessHandles(GetCurrentProcessHandles);
+  if (base::win::GetVersion() < base::win::Version::WIN8) {
+    ASSERT_FALSE(GetCurrentProcessHandles());
+    EXPECT_EQ(DWORD{ERROR_INVALID_PARAMETER}, ::GetLastError());
+  } else {
+    TestCurrentProcessHandles(GetCurrentProcessHandles);
+  }
+  TestCurrentProcessHandles(GetCurrentProcessHandlesWin7);
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/window.cc b/sandbox/win/src/window.cc
index ad552760a7d15..eb6aa30e447c9 100644
--- a/sandbox/win/src/window.cc
+++ b/sandbox/win/src/window.cc
@@ -6,11 +6,38 @@
 
 #include <windows.h>
 
+#include <aclapi.h>
+
+#include <memory>
+
 #include "base/notreached.h"
 #include "base/win/security_descriptor.h"
 #include "base/win/sid.h"
 #include "base/win/win_util.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "base/win/windows_version.h"
+#include "sandbox/win/src/acl.h"
+
+namespace {
+
+// Gets the security attributes of a window object referenced by |handle|. The
+// lpSecurityDescriptor member of the SECURITY_ATTRIBUTES parameter returned
+// must be freed using LocalFree by the caller.
+bool GetSecurityAttributes(HANDLE handle, SECURITY_ATTRIBUTES* attributes) {
+  attributes->bInheritHandle = false;
+  attributes->nLength = sizeof(SECURITY_ATTRIBUTES);
+
+  PACL dacl = nullptr;
+  DWORD result = ::GetSecurityInfo(
+      handle, SE_WINDOW_OBJECT, DACL_SECURITY_INFORMATION, nullptr, nullptr,
+      &dacl, nullptr, &attributes->lpSecurityDescriptor);
+  if (ERROR_SUCCESS == result)
+    return true;
+
+  return false;
+}
+
+}  // namespace
 
 namespace sandbox {
 
@@ -130,6 +157,33 @@ ResultCode CreateAltDesktop(HWINSTA winsta, HDESK* desktop) {
   }
 
   if (*desktop) {
+    if (sd->dacl() && sd->dacl()->is_null()) {
+      // If the desktop had a NULL DACL, it allowed access to everything. When
+      // we apply a new ACE with |kDesktopDenyMask| below, a NULL DACL would be
+      // replaced with a new DACL with one ACE that denies access - which means
+      // there is no ACE to allow anything access to the desktop. In this case,
+      // replace the NULL DACL with one that has a single ACE that allows access
+      // to everyone, so the desktop remains accessible when we further modify
+      // the DACL. Also need WinBuiltinAnyPackageSid for AppContainer processes.
+      if (base::win::GetVersion() >= base::win::Version::WIN8) {
+        AddKnownSidToObject(*desktop, base::win::SecurityObjectType::kDesktop,
+                            base::win::WellKnownSid::kAllApplicationPackages,
+                            base::win::SecurityAccessMode::kGrant, GENERIC_ALL);
+      }
+      AddKnownSidToObject(*desktop, base::win::SecurityObjectType::kDesktop,
+                          base::win::WellKnownSid::kWorld,
+                          base::win::SecurityAccessMode::kGrant, GENERIC_ALL);
+    }
+
+    // Replace the DACL on the new Desktop with a reduced privilege version.
+    // We can soft fail on this for now, as it's just an extra mitigation.
+    static const ACCESS_MASK kDesktopDenyMask =
+        WRITE_DAC | WRITE_OWNER | DELETE | DESKTOP_CREATEMENU |
+        DESKTOP_CREATEWINDOW | DESKTOP_HOOKCONTROL | DESKTOP_JOURNALPLAYBACK |
+        DESKTOP_JOURNALRECORD | DESKTOP_SWITCHDESKTOP;
+    AddKnownSidToObject(*desktop, base::win::SecurityObjectType::kDesktop,
+                        base::win::WellKnownSid::kRestricted,
+                        base::win::SecurityAccessMode::kDeny, kDesktopDenyMask);
     return SBOX_ALL_OK;
   }
 
diff --git a/sandbox/win/tests/common/controller.cc b/sandbox/win/tests/common/controller.cc
index 740c54c8f626c..99f9cf217b4dd 100644
--- a/sandbox/win/tests/common/controller.cc
+++ b/sandbox/win/tests/common/controller.cc
@@ -222,6 +222,7 @@ int TestRunner::InternalRunTest(const wchar_t* command) {
   GetModuleFileNameW(NULL, prog_name, MAX_PATH);
 
   // Launch the sandboxed process.
+  ResultCode warning_result = SBOX_ALL_OK;
   DWORD last_error = ERROR_SUCCESS;
   PROCESS_INFORMATION target = {0};
 
@@ -238,8 +239,9 @@ int TestRunner::InternalRunTest(const wchar_t* command) {
       return SBOX_ERROR_GENERIC;
     }
   } else {
-    result = broker_->SpawnTarget(prog_name, arguments.c_str(),
-                                  std::move(policy_), &last_error, &target);
+    result =
+        broker_->SpawnTarget(prog_name, arguments.c_str(), std::move(policy_),
+                             &warning_result, &last_error, &target);
   }
 
   if (SBOX_ALL_OK != result)
diff --git a/sandbox/win/tests/integration_tests/cfi_unittest.cc b/sandbox/win/tests/integration_tests/cfi_unittest.cc
index 31c7e554484a8..cbf30b93124b3 100644
--- a/sandbox/win/tests/integration_tests/cfi_unittest.cc
+++ b/sandbox/win/tests/integration_tests/cfi_unittest.cc
@@ -9,6 +9,7 @@
 #include "base/files/scoped_temp_dir.h"
 #include "base/notreached.h"
 #include "base/path_service.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -76,6 +77,12 @@ TEST(CFGSupportTests, LongJmp) {
 // Make sure Microsoft binaries compiled with CFG cannot call indirect pointers
 // not listed in the loader config for this test binary.
 TEST(CFGSupportTests, MsIndirectFailure) {
+  // CFG is only supported on >= Win8.1 Update 3.
+  // Not checking for update, since test infra is updated and it would add
+  // a lot of complexity.
+  if (base::win::GetVersion() < base::win::Version::WIN8_1)
+    return;
+
   base::FilePath exe_path;
   ASSERT_TRUE(base::PathService::Get(base::FILE_EXE, &exe_path));
 
diff --git a/services/device/geolocation/win/location_provider_winrt_unittest.cc b/services/device/geolocation/win/location_provider_winrt_unittest.cc
index d4eabaa5bb81f..e1f47cb0e146e 100644
--- a/services/device/geolocation/win/location_provider_winrt_unittest.cc
+++ b/services/device/geolocation/win/location_provider_winrt_unittest.cc
@@ -4,12 +4,10 @@
 
 #include "services/device/geolocation/win/location_provider_winrt.h"
 
-#include <memory>
-#include <utility>
-
 #include "base/run_loop.h"
 #include "base/test/task_environment.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #include "services/device/geolocation/win/fake_geocoordinate_winrt.h"
 #include "services/device/geolocation/win/fake_geolocator_winrt.h"
 #include "services/device/public/cpp/geolocation/geoposition.h"
@@ -23,7 +21,7 @@ using ABI::Windows::Devices::Geolocation::PositionStatus;
 
 class MockLocationObserver {
  public:
-  explicit MockLocationObserver(base::OnceClosure update_called)
+  MockLocationObserver(base::OnceClosure update_called)
       : update_called_(std::move(update_called)) {}
   ~MockLocationObserver() = default;
 
@@ -92,6 +90,9 @@ class LocationProviderWinrtTest : public testing::Test {
                                       base::Unretained(observer_.get()))) {}
 
   void SetUp() override {
+    if (base::win::GetVersion() < base::win::Version::WIN8)
+      GTEST_SKIP();
+
     winrt_initializer_.emplace();
     ASSERT_TRUE(winrt_initializer_->Succeeded());
   }
diff --git a/services/device/wake_lock/power_save_blocker/power_save_blocker_win.cc b/services/device/wake_lock/power_save_blocker/power_save_blocker_win.cc
index 93d2554ea2ca9..0dd49a1d164b8 100644
--- a/services/device/wake_lock/power_save_blocker/power_save_blocker_win.cc
+++ b/services/device/wake_lock/power_save_blocker/power_save_blocker_win.cc
@@ -19,6 +19,11 @@ namespace {
 
 HANDLE CreatePowerRequest(POWER_REQUEST_TYPE type,
                           const std::string& description) {
+  if (type == PowerRequestExecutionRequired &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    return INVALID_HANDLE_VALUE;
+  }
+
   std::wstring wide_description = base::ASCIIToWide(description);
   REASON_CONTEXT context = {0};
   context.Version = POWER_REQUEST_CONTEXT_VERSION;
@@ -43,6 +48,11 @@ void DeletePowerRequest(POWER_REQUEST_TYPE type, HANDLE handle) {
   if (!request_handle.IsValid())
     return;
 
+  if (type == PowerRequestExecutionRequired &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    return;
+  }
+
   BOOL success = ::PowerClearRequest(request_handle.Get(), type);
   DCHECK(success);
 }
@@ -110,6 +120,9 @@ POWER_REQUEST_TYPE PowerSaveBlocker::Delegate::RequestType() {
       type_ == mojom::WakeLockType::kPreventDisplaySleepAllowDimming)
     return PowerRequestDisplayRequired;
 
+  if (base::win::GetVersion() == base::win::Version::WIN7)
+    return PowerRequestSystemRequired;
+
   return PowerRequestExecutionRequired;
 }
 
diff --git a/services/shape_detection/face_detection_impl_win_unittest.cc b/services/shape_detection/face_detection_impl_win_unittest.cc
index 71328dbe3fdd1..82ae5216cbe46 100644
--- a/services/shape_detection/face_detection_impl_win_unittest.cc
+++ b/services/shape_detection/face_detection_impl_win_unittest.cc
@@ -14,6 +14,7 @@
 #include "base/run_loop.h"
 #include "base/test/task_environment.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/shape_detection/face_detection_provider_win.h"
 #include "services/shape_detection/public/mojom/facedetection_provider.mojom.h"
@@ -89,6 +90,10 @@ class FaceDetectionImplWinTest : public testing::Test {
 };
 
 TEST_F(FaceDetectionImplWinTest, ScanOneFace) {
+  // FaceDetector not supported before Windows 10
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   mojo::Remote<mojom::FaceDetection> face_detector = ConnectToFaceDetector();
   std::unique_ptr<SkBitmap> image = LoadTestImage();
   ASSERT_TRUE(image);
diff --git a/services/shape_detection/face_detection_provider_win.cc b/services/shape_detection/face_detection_provider_win.cc
index d77e8723a13f5..b2a2cb55a7d55 100644
--- a/services/shape_detection/face_detection_provider_win.cc
+++ b/services/shape_detection/face_detection_provider_win.cc
@@ -12,6 +12,7 @@
 #include "base/win/core_winrt_util.h"
 #include "base/win/post_async_results.h"
 #include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/self_owned_receiver.h"
 
@@ -49,6 +50,11 @@ BitmapPixelFormat GetPreferredPixelFormat(IFaceDetectorStatics* factory) {
 void FaceDetectionProviderWin::CreateFaceDetection(
     mojo::PendingReceiver<shape_detection::mojom::FaceDetection> receiver,
     shape_detection::mojom::FaceDetectorOptionsPtr options) {
+  // FaceDetector class is only available in Win 10 onwards (v10.0.10240.0).
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    DVLOG(1) << "FaceDetector not supported before Windows 10";
+    return;
+  }
   // Loads functions dynamically at runtime to prevent library dependencies.
   if (!(base::win::ResolveCoreWinRTDelayload() &&
         ScopedHString::ResolveCoreWinRTStringDelayload())) {
diff --git a/services/shape_detection/text_detection_impl_win.cc b/services/shape_detection/text_detection_impl_win.cc
index bc153ea9ab335..9e97364683000 100644
--- a/services/shape_detection/text_detection_impl_win.cc
+++ b/services/shape_detection/text_detection_impl_win.cc
@@ -14,6 +14,7 @@
 #include "base/win/core_winrt_util.h"
 #include "base/win/post_async_results.h"
 #include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/self_owned_receiver.h"
 #include "services/shape_detection/detection_utils_win.h"
@@ -42,6 +43,15 @@ using Microsoft::WRL::ComPtr;
 // static
 void TextDetectionImpl::Create(
     mojo::PendingReceiver<mojom::TextDetection> receiver) {
+  // OcrEngine class is only available in Win 10 onwards (v10.0.10240.0) that
+  // documents in
+  // https://docs.microsoft.com/en-us/uwp/api/windows.media.ocr.ocrengine.
+  if (base::win::GetVersion() < base::win::Version::WIN10) {
+    DVLOG(1) << "Optical character recognition not supported before Windows 10";
+    return;
+  }
+  DCHECK_GE(base::win::OSInfo::GetInstance()->version_number().build, 10240u);
+
   // Loads functions dynamically at runtime to prevent library dependencies.
   if (!(base::win::ResolveCoreWinRTDelayload() &&
         ScopedHString::ResolveCoreWinRTStringDelayload())) {
diff --git a/services/shape_detection/text_detection_impl_win_unittest.cc b/services/shape_detection/text_detection_impl_win_unittest.cc
index 34cd16976ae3a..eecee2b554db7 100644
--- a/services/shape_detection/text_detection_impl_win_unittest.cc
+++ b/services/shape_detection/text_detection_impl_win_unittest.cc
@@ -13,6 +13,7 @@
 #include "base/run_loop.h"
 #include "base/test/task_environment.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/shape_detection/public/mojom/textdetection.mojom.h"
 #include "services/shape_detection/text_detection_impl.h"
@@ -54,6 +55,10 @@ class TextDetectionImplWinTest : public testing::Test {
 };
 
 TEST_F(TextDetectionImplWinTest, ScanOnce) {
+  // OCR not supported before Windows 10
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   mojo::Remote<mojom::TextDetection> text_service;
   TextDetectionImpl::Create(text_service.BindNewPipeAndPassReceiver());
 
diff --git a/third_party/blink/common/BUILD.gn b/third_party/blink/common/BUILD.gn
index 108b79fbc471c..43f1e1deaac64 100644
--- a/third_party/blink/common/BUILD.gn
+++ b/third_party/blink/common/BUILD.gn
@@ -333,6 +333,7 @@ source_set("common") {
   }
 
   if (is_win) {
+    sources += [ "dwrite_rasterizer_support/dwrite_rasterizer_support.cc" ]
     deps += [ "//ui/gfx/" ]
   }
 
diff --git a/third_party/blink/common/dwrite_rasterizer_support/dwrite_rasterizer_support.cc b/third_party/blink/common/dwrite_rasterizer_support/dwrite_rasterizer_support.cc
new file mode 100644
index 0000000000000..236d8fccb7620
--- /dev/null
+++ b/third_party/blink/common/dwrite_rasterizer_support/dwrite_rasterizer_support.cc
@@ -0,0 +1,30 @@
+// Copyright 2018 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h"
+#include "base/check_op.h"
+#include "base/win/windows_version.h"
+#include "ui/gfx/win/direct_write.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <wrl.h>
+
+namespace blink {
+
+bool DWriteRasterizerSupport::IsDWriteFactory2Available() {
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2;
+  factory.As<IDWriteFactory2>(&factory2);
+  if (!factory2.Get()) {
+    // If we were unable to get a IDWriteFactory2, check that we are actually on
+    // a Windows version where we allow it. Windows 8.1 and up should have the
+    // IDWritefactory2 available.
+    CHECK_LT(base::win::GetVersion(), base::win::Version::WIN8_1);
+  }
+  return factory2.Get();
+}
+
+}  // namespace blink
diff --git a/third_party/blink/public/common/BUILD.gn b/third_party/blink/public/common/BUILD.gn
index 773cee4df5421..cf315be1794aa 100644
--- a/third_party/blink/public/common/BUILD.gn
+++ b/third_party/blink/public/common/BUILD.gn
@@ -371,6 +371,10 @@ source_set("headers") {
   if (is_mac) {
     sources += [ "sandbox_support/sandbox_support_mac.h" ]
   }
+
+  if (is_win) {
+    sources += [ "dwrite_rasterizer_support/dwrite_rasterizer_support.h" ]
+  }
 }
 
 if (is_android || is_win) {
diff --git a/third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h b/third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h
new file mode 100644
index 0000000000000..1a8b4b87ba987
--- /dev/null
+++ b/third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h
@@ -0,0 +1,19 @@
+// Copyright 2018 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_PUBLIC_COMMON_DWRITE_RASTERIZER_SUPPORT_DWRITE_RASTERIZER_SUPPORT_H_
+#define THIRD_PARTY_BLINK_PUBLIC_COMMON_DWRITE_RASTERIZER_SUPPORT_DWRITE_RASTERIZER_SUPPORT_H_
+
+#include "third_party/blink/public/common/common_export.h"
+
+namespace blink {
+
+class BLINK_COMMON_EXPORT DWriteRasterizerSupport {
+ public:
+  static bool IsDWriteFactory2Available();
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_PUBLIC_COMMON_DWRITE_RASTERIZER_SUPPORT_DWRITE_RASTERIZER_SUPPORT_H_
diff --git a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
index a809c19539aaf..0343a0a194f49 100644
--- a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
+++ b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
@@ -35,6 +35,11 @@ struct MapCharactersResult {
   DWriteFontStyle font_style;
 };
 
+enum UniqueFontLookupMode {
+    kRetrieveTable,
+    kSingleLookups
+};
+
 interface DWriteFontProxy {
   // Locates the index of the specified font family within the system
   // collection.
@@ -58,14 +63,47 @@ interface DWriteFontProxy {
      => (array<mojo_base.mojom.FilePath> file_paths,
          array<mojo_base.mojom.ReadOnlyFile> file_handles);
 
-  // Matches a unique PostScript or full font name against the installed fonts
-  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
-  // which the unique font can be instantiated. Returns null handle and 0 ttc
-  // index if no font is found.
+  // Returns which font unique name matching lookup mode is to be used on the
+  // current machine. On DirectWrite 10 and above, single lookups can be
+  // performed directly against DirectWrite API. On older DirectWrite (Windows
+  // 7-8.1), unique font lookups need to be performed against a shared memory
+  // region which contains the lookup table. Compare GetUniqueFontLookupTable()
+  // for lookup mode kRetrieveTable and MatchUniqueFont for
+  // lookup mode kSingleLookups.
+  [Sync]
+  GetUniqueFontLookupMode() => (UniqueFontLookupMode lookup_mode);
+
+  // On supported Windows versions, matches a unique PostScript or full font
+  // name against the installed fonts using DirectWrite API. Returns a
+  // pre-opened file handle and ttc_index from which the unique font can be
+  // instantiated.  Check which mode is supported using
+  // GetFontUniqueNameLookupMode().  Returns null handle and 0 ttc index
+  // if no font is found. Must not be called if GetUniqueFontLookupMode()
+  // returned kRetrieveTable.
   [Sync]
   MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
       => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);
 
+  // Synchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion if it is available
+  // immediately without any blocking operations. Use FontTableMatcher to
+  // perform searches in it. If it is not available without blocking operations,
+  // sync_available is false and no shared memory region is provided.
+  [Sync]
+  GetUniqueNameLookupTableIfAvailable()
+      => (bool sync_available,
+          mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
+  // Asynchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion. The lookup list is built
+  // on the first renderer call to retrieving this list. Use FontTableMatcher
+  // to perform searches in it. Retrieval may take up to several seconds if the
+  // table needs rebuilding on browser side.
+  GetUniqueNameLookupTable() =>
+  (mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
   // Locates a font family that is able to render the specified text using the
   // specified style. If successful, the family_index and family_name will
   // indicate which family in the system font collection can render the
diff --git a/third_party/blink/public/platform/platform.h b/third_party/blink/public/platform/platform.h
index b2de9ae25b7ac..23feadc007358 100644
--- a/third_party/blink/public/platform/platform.h
+++ b/third_party/blink/public/platform/platform.h
@@ -626,6 +626,11 @@ class BLINK_PLATFORM_EXPORT Platform {
                                             uint16_t* udp_max_port,
                                             bool* allow_mdns_obfuscation) {}
 
+  virtual bool IsWebRtcHWH264DecodingEnabled(
+      webrtc::VideoCodecType video_coded_type) {
+    return true;
+  }
+
   virtual bool IsWebRtcHWEncodingEnabled() { return true; }
 
   virtual bool IsWebRtcHWDecodingEnabled() { return true; }
diff --git a/third_party/blink/renderer/modules/font_access/font_metadata.cc b/third_party/blink/renderer/modules/font_access/font_metadata.cc
index a7a5b4f6468a3..595a696690482 100644
--- a/third_party/blink/renderer/modules/font_access/font_metadata.cc
+++ b/third_party/blink/renderer/modules/font_access/font_metadata.cc
@@ -4,9 +4,6 @@
 
 #include "third_party/blink/renderer/modules/font_access/font_metadata.h"
 
-#include <memory>
-#include <utility>
-
 #include "base/big_endian.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/numerics/safe_conversions.h"
@@ -34,7 +31,9 @@ void SetUpFontUniqueLookupIfNecessary() {
   if (!unique_name_lookup)
     return;
   // Contrary to what the method name might imply, this is not an idempotent
-  // method. It also initializes state in the FontUniqueNameLookup object.
+  // method. It also initializes the state in the FontUniqueNameLookup object
+  // to either retrieve from tables on Windows 7, or direct lookups on
+  // Windows 10.
   unique_name_lookup->IsFontUniqueNameLookupReadyForSyncLookup();
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
index 7f19714480223..b078bf747075f 100644
--- a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
+++ b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
@@ -13,6 +13,7 @@
 #include "third_party/skia/include/core/SkTypeface.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "third_party/blink/public/common/dwrite_rasterizer_support/dwrite_rasterizer_support.h"
 #include "third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.h"
 #endif
 
@@ -156,6 +157,11 @@ sk_sp<SkFontMgr> WebFontTypefaceFactory::FreeTypeFontManager() {
 }
 
 sk_sp<SkFontMgr> WebFontTypefaceFactory::FontManagerForColrCpal() {
+#if BUILDFLAG(IS_WIN)
+  if (!blink::DWriteRasterizerSupport::IsDWriteFactory2Available())
+    return FreeTypeFontManager();
+#endif
+
 #if BUILDFLAG(IS_MAC)
   return FreeTypeFontManager();
 #else
@@ -165,9 +171,9 @@ sk_sp<SkFontMgr> WebFontTypefaceFactory::FontManagerForColrCpal() {
 
 sk_sp<SkFontMgr> WebFontTypefaceFactory::FontManagerForColrV0Variations() {
 #if BUILDFLAG(IS_WIN)
-  if (DWriteVersionSupportsVariations()) {
+  if (DWriteVersionSupportsVariations() &&
+      blink::DWriteRasterizerSupport::IsDWriteFactory2Available())
     return DefaultFontManager();
-  }
 #endif
   return FreeTypeFontManager();
 }
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
index 3b1c3db022fd0..2f825c618b83e 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -10,6 +10,7 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
 #include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
@@ -26,11 +27,14 @@ FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
     const String& font_unique_name) {
-  return MatchUniqueNameSingleLookup(font_unique_name);
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups)
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  return MatchUniqueNameLookupTable(font_unique_name);
 }
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
     const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
   base::File font_file;
   uint32_t ttc_index = 0;
 
@@ -43,6 +47,31 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
   return InstantiateFromFileAndTtcIndex(std::move(font_file), ttc_index);
 }
 
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+
+  absl::optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result)
+    return nullptr;
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+// Used for font matching with table lookup case only.
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  return SkTypeface::MakeFromFile(font_file_path.AsUTF8Unsafe().c_str(),
+                                  ttc_index);
+}
+
 // Used for font matching with single lookup case only.
 sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
     base::File file_handle,
@@ -60,11 +89,52 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
 }
 
 bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
-  if (RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
-    EnsureServiceConnected();
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
+    return true;
+
+  EnsureServiceConnected();
+
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
   }
 
-  return true;
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
+  }
+
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
 }
 
 void FontUniqueNameLookupWin::EnsureServiceConnected() {
@@ -74,11 +144,66 @@ void FontUniqueNameLookupWin::EnsureServiceConnected() {
       service_.BindNewPipeAndPassReceiver());
 }
 
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
 void FontUniqueNameLookupWin::Init() {
   if (!base::FeatureList::IsEnabled(features::kPrefetchFontLookupTables))
     return;
 
   EnsureServiceConnected();
+
+  if (lookup_mode_.has_value()) {
+    InitWithLookupMode(lookup_mode_.value());
+    return;
+  }
+
+  service_->GetUniqueFontLookupMode(base::BindOnce(
+      &FontUniqueNameLookupWin::InitWithLookupMode, base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.empty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+void FontUniqueNameLookupWin::InitWithLookupMode(
+    blink::mojom::UniqueFontLookupMode lookup_mode) {
+  lookup_mode_ = lookup_mode;
+
+  if (!font_table_matcher_.get() &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled() &&
+      lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable) {
+    // This call primes IsFontUniqueNameLookupReadyForSyncLookup() by
+    // asynchronously fetching the font table so it will be ready when needed.
+    // It isn't needed now, so base::DoNothing() is passed as the callback.
+    PrepareFontUniqueNameLookup(base::DoNothing());
+  }
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
index 7b31b5af1cabc..a9293b85a3ab5 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -14,8 +14,14 @@
 namespace blink {
 
 // Performs the IPC towards the browser process for font unique name
-// matching. Direct individual sync Mojo IPC calls are made to lookup fonts,
-// and the class reponds synchronously.
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows 7 & 8, a shared memory region is retrieved
+// asynchronously, then lookups are performed against that table. When the
+// asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
 class FontUniqueNameLookupWin : public FontUniqueNameLookup {
  public:
   FontUniqueNameLookupWin();
@@ -26,17 +32,31 @@ class FontUniqueNameLookupWin : public FontUniqueNameLookup {
 
   bool IsFontUniqueNameLookupReadyForSyncLookup() override;
 
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
   void Init() override;
 
  private:
   void EnsureServiceConnected();
 
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
   sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
 
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
   sk_sp<SkTypeface> InstantiateFromFileAndTtcIndex(base::File file_handle,
                                                    uint32_t ttc_index);
 
+  void InitWithLookupMode(blink::mojom::UniqueFontLookupMode lookup_mode);
+
   mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
+  absl::optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
+  absl::optional<bool> sync_available_;
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
index a153395827355..a91336b441fee 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_adapter.cc
@@ -571,6 +571,9 @@ std::unique_ptr<RTCVideoDecoderAdapter> RTCVideoDecoderAdapter::Create(
   const webrtc::VideoCodecType video_codec_type =
       webrtc::PayloadStringToCodecType(format.name);
 
+  if (!Platform::Current()->IsWebRtcHWH264DecodingEnabled(video_codec_type))
+    return nullptr;
+
   // Bail early for unknown codecs.
   if (WebRtcToMediaVideoCodec(video_codec_type) == media::VideoCodec::kUnknown)
     return nullptr;
diff --git a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
index 98751df6aaec4..100635beadaf1 100644
--- a/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
+++ b/third_party/blink/renderer/platform/peerconnection/rtc_video_decoder_stream_adapter.cc
@@ -278,6 +278,9 @@ RTCVideoDecoderStreamAdapter::Create(
   const webrtc::VideoCodecType video_codec_type =
       webrtc::PayloadStringToCodecType(format.name);
 
+  if (!Platform::Current()->IsWebRtcHWH264DecodingEnabled(video_codec_type))
+    return nullptr;
+
   // Bail early for unknown codecs.
   if (WebRtcToMediaVideoCodec(video_codec_type) == media::VideoCodec::kUnknown)
     return nullptr;
diff --git a/third_party/centipede/src b/third_party/centipede/src
new file mode 160000
index 0000000000000..a5a9071410e6e
--- /dev/null
+++ b/third_party/centipede/src
@@ -0,0 +1 @@
+Subproject commit a5a9071410e6e8134855b88461d0eb2c77d48cdd
diff --git a/third_party/cros-components/src b/third_party/cros-components/src
new file mode 160000
index 0000000000000..0631a9fae2b5f
--- /dev/null
+++ b/third_party/cros-components/src
@@ -0,0 +1 @@
+Subproject commit 0631a9fae2b5f424dd1f938ba03a422b22755c90
diff --git a/third_party/crossbench b/third_party/crossbench
new file mode 160000
index 0000000000000..0941f19d9b1ba
--- /dev/null
+++ b/third_party/crossbench
@@ -0,0 +1 @@
+Subproject commit 0941f19d9b1bab30137d9fcad6ee2ee44d338913
diff --git a/tools/metrics/histograms/metadata/others/histograms.xml b/tools/metrics/histograms/metadata/others/histograms.xml
index d5ebe776d8cc6..c97bcdf7968ea 100644
--- a/tools/metrics/histograms/metadata/others/histograms.xml
+++ b/tools/metrics/histograms/metadata/others/histograms.xml
@@ -10308,6 +10308,39 @@ chromium-metrics-reviews@google.com.
   </summary>
 </histogram>
 
+<histogram name="Process.Sandbox.Launch.Warning" enum="WinGetLastError"
+    expires_after="never">
+<!-- expires-never: metric needed for diagnosing sandbox issues. -->
+
+  <owner>forshaw@chromium.org</owner>
+  <owner>wfh@chromium.org</owner>
+  <summary>
+    Warnings returned while launching sandboxed process on Windows. For decoding
+    error code please refer to http://goo.gl/fJJiAv. This will only be logged
+    when SpawnTarget succeeds with SBOX_ALL_OK but the last warning result does
+    not equal SBOX_ALL_OK.
+
+    Warning: this histogram expired in M87, and was revived in M103; data may be
+    missing.
+  </summary>
+</histogram>
+
+<histogram name="Process.Sandbox.Launch.WarningResultCode"
+    enum="LaunchErrorCodes" expires_after="never">
+<!-- expires-never: metric needed for diagnosing sandbox issues. -->
+
+  <owner>forshaw@chromium.org</owner>
+  <owner>wfh@chromium.org</owner>
+  <summary>
+    The warning launch error returned while launching sandboxed process on
+    Windows. This will only be logged when SpawnTarget succeeds with SBOX_ALL_OK
+    but the last warning result does not equal SBOX_ALL_OK.
+
+    Warning: this histogram expired in M87, and was revived in M103; data may be
+    missing.
+  </summary>
+</histogram>
+
 <histogram name="Process.Sandbox.Lowbox.Launch.Error" enum="WinGetLastError"
     expires_after="never">
 <!-- expires-never: metric needed for diagnosing sandbox issues. -->
diff --git a/ui/accessibility/platform/ax_platform_node_win.cc b/ui/accessibility/platform/ax_platform_node_win.cc
index d903d3e80a4e4..22db943f9e6ba 100644
--- a/ui/accessibility/platform/ax_platform_node_win.cc
+++ b/ui/accessibility/platform/ax_platform_node_win.cc
@@ -2507,7 +2507,7 @@ IFACEMETHODIMP AXPlatformNodeWin::get_Target(
 
   // If there is no reverse relation target, IAnnotationProvider
   // should not be exposed in the first place.
-  DCHECK_GT(reverse_relations.size(), 0u);
+  DCHECK(reverse_relations.size() > 0);
   AXPlatformNodeWin* target_node;
   auto iter = reverse_relations.begin();
   target_node = static_cast<AXPlatformNodeWin*>(*iter);
@@ -5245,26 +5245,42 @@ HRESULT AXPlatformNodeWin::GetPropertyValueImpl(PROPERTYID property_id,
       // if the internal role cannot be accurately described by its UIA Control
       // Type or aria role, we should instead provide our own localized
       // description.
-      if (GetUIARoleProperties().localization_strategy ==
-          UIALocalizationStrategy::kSupply) {
-        // According to the HTML-AAM, UIA expects <output> to have a
-        // Localized Control Type of "output" whereas the Core-AAM states
-        // the Localized Control Type of the ARIA status role should be
-        // "status".
-        const std::string& html_tag =
-            GetStringAttribute(ax::mojom::StringAttribute::kHtmlTag);
-        std::u16string localized_control_type =
-            html_tag == "output" ? l10n_util::GetStringUTF16(IDS_AX_ROLE_OUTPUT)
-                                 : GetRoleDescription();
-
-        if (!localized_control_type.empty()) {
-          result->vt = VT_BSTR;
-          result->bstrVal =
-              SysAllocString(base::as_wcstr(localized_control_type));
-        }
-      }  // If a role description has not been provided, leave as VT_EMPTY.
-      break;
-    }
+      UIALocalizationStrategy localization_strategy =
+          GetUIARoleProperties().localization_strategy;
+      switch (localization_strategy) {
+        case UIALocalizationStrategy::kDeferToControlType:
+          break;
+        case UIALocalizationStrategy::kDeferToAriaRole:
+          if (base::win::GetVersion() >= base::win::Version::WIN8) {
+            // On Windows 8 onward, UIA can provide localization from the
+            // aria role.
+            break;
+          }
+          // On versions before 8, we should not rely on UIA to generate
+          // localization from the aria role, instead we should supply our own
+          // localization.
+          ABSL_FALLTHROUGH_INTENDED;
+        case UIALocalizationStrategy::kSupply:
+          // According to the HTML-AAM, UIA expects <output> to have a
+          // Localized Control Type of "output" whereas the Core-AAM states
+          // the Localized Control Type of the ARIA status role should be
+          // "status".
+          const std::string& html_tag =
+              GetStringAttribute(ax::mojom::StringAttribute::kHtmlTag);
+          std::u16string localized_control_type =
+              html_tag == "output"
+                  ? l10n_util::GetStringUTF16(IDS_AX_ROLE_OUTPUT)
+                  : GetRoleDescription();
+
+          if (!localized_control_type.empty()) {
+            result->vt = VT_BSTR;
+            result->bstrVal =
+                SysAllocString(base::as_wcstr(localized_control_type));
+          }
+          // If a role description has not been provided, leave as VT_EMPTY.
+      }
+    } break;
+
     case UIA_NamePropertyId:
       if (IsNameExposed()) {
         result->vt = VT_BSTR;
diff --git a/ui/accessibility/platform/inspect/ax_inspect_test_helper.cc b/ui/accessibility/platform/inspect/ax_inspect_test_helper.cc
index d1808f75a06f6..86748f9bd5e8a 100644
--- a/ui/accessibility/platform/inspect/ax_inspect_test_helper.cc
+++ b/ui/accessibility/platform/inspect/ax_inspect_test_helper.cc
@@ -4,9 +4,6 @@
 
 #include "ui/accessibility/platform/inspect/ax_inspect_test_helper.h"
 
-#include <string>
-#include <vector>
-
 #include "base/command_line.h"
 #include "base/files/file_util.h"
 #include "base/logging.h"
@@ -20,6 +17,9 @@
 #include "ui/accessibility/platform/inspect/ax_inspect_scenario.h"
 #include "ui/base/buildflags.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
 #if BUILDFLAG(USE_ATK)
 extern "C" {
 #include <atk/atk.h>
@@ -355,6 +355,15 @@ FilePath::StringType AXInspectTestHelper::GetExpectedFileSuffix(
 
 FilePath::StringType AXInspectTestHelper::GetVersionSpecificExpectedFileSuffix(
     const base::FilePath::StringType& expectations_qualifier) const {
+#if BUILDFLAG(IS_WIN)
+  if (expectation_type_ == "uia" &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    FilePath::StringType suffix;
+    if (!expectations_qualifier.empty())
+      suffix = FILE_PATH_LITERAL("-") + expectations_qualifier;
+    return suffix + FILE_PATH_LITERAL("-expected-uia-win7.txt");
+  }
+#endif
 #if BUILDFLAG(USE_ATK)
   if (expectation_type_ == "linux") {
     FilePath::StringType version_name;
diff --git a/ui/aura/native_window_occlusion_tracker_unittest.cc b/ui/aura/native_window_occlusion_tracker_unittest.cc
index acd313dbd3eae..0cf616764a58a 100644
--- a/ui/aura/native_window_occlusion_tracker_unittest.cc
+++ b/ui/aura/native_window_occlusion_tracker_unittest.cc
@@ -4,16 +4,18 @@
 
 #include "ui/aura/native_window_occlusion_tracker_win.h"
 
-#include <dwmapi.h>
 #include <winuser.h>
 
 #include "base/win/scoped_gdi_object.h"
 #include "base/win/scoped_hdc.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/aura/test/aura_test_base.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/win/window_impl.h"
 
+#include "dwmapi.h"
+
 namespace aura {
 
 // Test wrapper around native window HWND.
@@ -228,6 +230,9 @@ TEST_F(NativeWindowOcclusionTrackerTest, PopupWindow) {
 }
 
 TEST_F(NativeWindowOcclusionTrackerTest, CloakedWindow) {
+  // Cloaking is only supported in Windows 8 and above.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
   HWND hwnd = CreateNativeWindow(/*style=*/0, /*ex_style=*/0);
   gfx::Rect win_rect;
   BOOL cloak = TRUE;
diff --git a/ui/aura/native_window_occlusion_tracker_win.cc b/ui/aura/native_window_occlusion_tracker_win.cc
index 41c3d067b72d4..a4fea246c5295 100644
--- a/ui/aura/native_window_occlusion_tracker_win.cc
+++ b/ui/aura/native_window_occlusion_tracker_win.cc
@@ -22,6 +22,7 @@
 #include "base/task/task_traits.h"
 #include "base/task/thread_pool.h"
 #include "base/win/scoped_gdi_object.h"
+#include "base/win/windows_version.h"
 #include "ui/aura/window_occlusion_tracker.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/base/ui_base_features.h"
@@ -427,8 +428,10 @@ NativeWindowOcclusionTrackerWin::WindowOcclusionCalculator::
       calculate_occluded_region_(base::FeatureList::IsEnabled(
           features::kApplyNativeOccludedRegionToWindowTracker)),
       update_occlusion_state_callback_(update_occlusion_state_callback) {
-  ::CoCreateInstance(__uuidof(VirtualDesktopManager), nullptr, CLSCTX_ALL,
-                     IID_PPV_ARGS(&virtual_desktop_manager_));
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    ::CoCreateInstance(__uuidof(VirtualDesktopManager), nullptr, CLSCTX_ALL,
+                       IID_PPV_ARGS(&virtual_desktop_manager_));
+  }
   DETACH_FROM_SEQUENCE(sequence_checker_);
 }
 
diff --git a/ui/aura/native_window_occlusion_tracker_win_interactive_test.cc b/ui/aura/native_window_occlusion_tracker_win_interactive_test.cc
index 13115dfc8b706..7a4bc97c2320e 100644
--- a/ui/aura/native_window_occlusion_tracker_win_interactive_test.cc
+++ b/ui/aura/native_window_occlusion_tracker_win_interactive_test.cc
@@ -16,6 +16,7 @@
 #include "base/test/bind.h"
 #include "base/test/scoped_feature_list.h"
 #include "base/win/scoped_gdi_object.h"
+#include "base/win/windows_version.h"
 #include "mojo/core/embedder/embedder.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/aura/env.h"
@@ -558,6 +559,13 @@ TEST_F(NativeWindowOcclusionTrackerTest,
 // Test that a maximized aura window that is covered by a fullscreen window
 // is marked as occluded.
 TEST_F(NativeWindowOcclusionTrackerTest, MaximizedOccludedByFullscreenWindow) {
+  // Win7 has non rectangular windows and odd padding; this breaks fullscreen
+  // window occlusion of maximized windows, which makes this test fail on Win7.
+  // Win7 support is going away soon and shouldn't get in the way of this test
+  // coverage.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   // Create an aura window that is maximized.
   base::RunLoop run_loop1;
   MockWindowTreeHostObserver observer(run_loop1.QuitClosure());
diff --git a/ui/base/ime/init/input_method_factory.cc b/ui/base/ime/init/input_method_factory.cc
index 5d4a41a4d64c2..31ad0c6590ab7 100644
--- a/ui/base/ime/init/input_method_factory.cc
+++ b/ui/base/ime/init/input_method_factory.cc
@@ -13,6 +13,7 @@
 #include "ui/gfx/switches.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "ui/base/ime/win/input_method_win_imm32.h"
 #include "ui/base/ime/win/input_method_win_tsf.h"
 #elif BUILDFLAG(IS_APPLE)
@@ -54,7 +55,8 @@ std::unique_ptr<InputMethod> CreateInputMethod(
     return base::WrapUnique(new MockInputMethod(ime_key_event_dispatcher));
 
 #if BUILDFLAG(IS_WIN)
-  if (base::FeatureList::IsEnabled(features::kTSFImeSupport)) {
+  if (base::FeatureList::IsEnabled(features::kTSFImeSupport) &&
+      base::win::GetVersion() > base::win::Version::WIN7) {
     return std::make_unique<InputMethodWinTSF>(ime_key_event_dispatcher,
                                                widget);
   }
diff --git a/ui/base/ime/win/input_method_win_base.cc b/ui/base/ime/win/input_method_win_base.cc
index 39211bbd51040..56db6e995aaa3 100644
--- a/ui/base/ime/win/input_method_win_base.cc
+++ b/ui/base/ime/win/input_method_win_base.cc
@@ -8,9 +8,6 @@
 #include <stdint.h>
 #include <cwctype>
 
-#include <memory>
-#include <vector>
-
 #include "base/auto_reset.h"
 #include "base/command_line.h"
 #include "base/functional/bind.h"
@@ -40,10 +37,11 @@ std::unique_ptr<VirtualKeyboardController> CreateKeyboardController(
       base::win::GetVersion() >= base::win::Version::WIN10_RS4) {
     return std::make_unique<OnScreenKeyboardDisplayManagerInputPane>(
         attached_window_handle);
-  } else {
+  } else if (base::win::GetVersion() >= base::win::Version::WIN8) {
     return std::make_unique<OnScreenKeyboardDisplayManagerTabTip>(
         attached_window_handle);
   }
+  return nullptr;
 }
 
 // Checks if a given primary language ID is a RTL language.
diff --git a/ui/base/ime/win/on_screen_keyboard_display_manager_tab_tip.cc b/ui/base/ime/win/on_screen_keyboard_display_manager_tab_tip.cc
index b555d53332335..fb7dd1270f7c9 100644
--- a/ui/base/ime/win/on_screen_keyboard_display_manager_tab_tip.cc
+++ b/ui/base/ime/win/on_screen_keyboard_display_manager_tab_tip.cc
@@ -20,6 +20,7 @@
 #include "base/win/registry.h"
 #include "base/win/scoped_co_mem.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ime/virtual_keyboard_controller_observer.h"
 #include "ui/base/win/hidden_window.h"
 #include "ui/display/win/screen_win.h"
@@ -255,7 +256,9 @@ void OnScreenKeyboardDetector::HandleKeyboardHidden() {
 // OnScreenKeyboardDisplayManagerTabTip member definitions.
 OnScreenKeyboardDisplayManagerTabTip::OnScreenKeyboardDisplayManagerTabTip(
     HWND hwnd)
-    : hwnd_(hwnd) {}
+    : hwnd_(hwnd) {
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN8);
+}
 
 OnScreenKeyboardDisplayManagerTabTip::~OnScreenKeyboardDisplayManagerTabTip() {}
 
diff --git a/ui/base/ime/win/on_screen_keyboard_display_manager_unittest.cc b/ui/base/ime/win/on_screen_keyboard_display_manager_unittest.cc
index 97fc29307d550..2af05b9961e5a 100644
--- a/ui/base/ime/win/on_screen_keyboard_display_manager_unittest.cc
+++ b/ui/base/ime/win/on_screen_keyboard_display_manager_unittest.cc
@@ -141,6 +141,10 @@ class OnScreenKeyboardTest : public ::testing::Test {
 // This test validates the on screen keyboard path (tabtip.exe) which is read
 // from the registry.
 TEST_F(OnScreenKeyboardTest, OSKPath) {
+  // The on screen keyboard is only available on Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return;
+
   std::unique_ptr<OnScreenKeyboardDisplayManagerTabTip>
       keyboard_display_manager(CreateTabTip());
   EXPECT_NE(nullptr, keyboard_display_manager);
diff --git a/ui/base/ime/win/tsf_input_scope.cc b/ui/base/ime/win/tsf_input_scope.cc
index b138707be2238..bbedf1e33ac53 100644
--- a/ui/base/ime/win/tsf_input_scope.cc
+++ b/ui/base/ime/win/tsf_input_scope.cc
@@ -10,8 +10,10 @@
 #include "base/compiler_specific.h"
 #include "base/containers/contains.h"
 #include "base/task/current_thread.h"
+#include "base/win/windows_version.h"
 
-namespace ui::tsf_inputscope {
+namespace ui {
+namespace tsf_inputscope {
 namespace {
 
 void AppendNonTrivialInputScope(std::vector<InputScope>* input_scopes,
@@ -187,8 +189,9 @@ ITfInputScope* CreateInputScope(TextInputType text_input_type,
                                 bool should_do_learning) {
   std::vector<InputScope> input_scopes;
   // Should set input scope to IS_PRIVATE if we are in "incognito" or "guest"
-  // mode.
-  if (!should_do_learning) {
+  // mode. Note that the IS_PRIVATE input scope is only support from WIN10.
+  if (!should_do_learning &&
+      (base::win::GetVersion() >= base::win::Version::WIN10)) {
     input_scopes.push_back(IS_PRIVATE);
   } else {
     input_scopes = GetInputScopes(text_input_type, text_input_mode);
@@ -208,4 +211,5 @@ void SetInputScopeForTsfUnawareWindow(HWND window_handle,
                      NULL, 0, NULL, NULL);
 }
 
-}  // namespace ui::tsf_inputscope
+}  // namespace tsf_inputscope
+}  // namespace ui
diff --git a/ui/base/ime/win/tsf_input_scope_unittest.cc b/ui/base/ime/win/tsf_input_scope_unittest.cc
index e222981ea01a4..57c891c45d456 100644
--- a/ui/base/ime/win/tsf_input_scope_unittest.cc
+++ b/ui/base/ime/win/tsf_input_scope_unittest.cc
@@ -8,6 +8,7 @@
 #include <stddef.h>
 #include <wrl/client.h>
 
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace ui {
@@ -133,6 +134,8 @@ const CreateInputScopesTestCase kCreateInputScopesTestCases[] = {
     {TEXT_INPUT_TYPE_NUMBER, TEXT_INPUT_MODE_NUMERIC, false, 1, {IS_PRIVATE}},
 };
 TEST_P(TSFCreateInputScopeTest, CreateInputScopes) {
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
   const CreateInputScopesTestCase& test_case = GetParam();
   Microsoft::WRL::ComPtr<ITfInputScope> input_scope =
       tsf_inputscope::CreateInputScope(test_case.input_type,
diff --git a/ui/base/pointer/touch_ui_controller.cc b/ui/base/pointer/touch_ui_controller.cc
index 9d2f88df875ab..d3e582ed3c27e 100644
--- a/ui/base/pointer/touch_ui_controller.cc
+++ b/ui/base/pointer/touch_ui_controller.cc
@@ -18,6 +18,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/gfx/win/singleton_hwnd.h"
 #include "ui/gfx/win/singleton_hwnd_observer.h"
 #endif
@@ -78,7 +79,8 @@ TouchUiController* TouchUiController::Get() {
 TouchUiController::TouchUiController(TouchUiState touch_ui_state)
     : touch_ui_state_(touch_ui_state) {
 #if BUILDFLAG(IS_WIN)
-  if (base::CurrentUIThread::IsSet()) {
+  if (base::CurrentUIThread::IsSet() &&
+      base::win::GetVersion() >= base::win::Version::WIN10) {
     singleton_hwnd_observer_ =
         std::make_unique<gfx::SingletonHwndObserver>(base::BindRepeating(
             [](HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam) {
diff --git a/ui/base/ui_base_features.cc b/ui/base/ui_base_features.cc
index 672bea5e24308..3297162251b3e 100644
--- a/ui/base/ui_base_features.cc
+++ b/ui/base/ui_base_features.cc
@@ -11,6 +11,10 @@
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/build_info.h"
 #endif
@@ -250,7 +254,8 @@ BASE_FEATURE(kPointerEventsForTouch,
 BASE_FEATURE(kTSFImeSupport, "TSFImeSupport", base::FEATURE_ENABLED_BY_DEFAULT);
 
 bool IsUsingWMPointerForTouch() {
-  return base::FeatureList::IsEnabled(kPointerEventsForTouch);
+  return base::win::GetVersion() >= base::win::Version::WIN8 &&
+         base::FeatureList::IsEnabled(kPointerEventsForTouch);
 }
 
 #endif  // BUILDFLAG(IS_WIN)
diff --git a/ui/base/ui_base_switches.cc b/ui/base/ui_base_switches.cc
index fd28b0bf699c2..f8556679a79d8 100644
--- a/ui/base/ui_base_switches.cc
+++ b/ui/base/ui_base_switches.cc
@@ -34,6 +34,9 @@ const char kEnableResourcesFileSharing[] = "enable-resources-file-sharing";
 // Disables layer-edge anti-aliasing in the compositor.
 const char kDisableCompositedAntialiasing[] = "disable-composited-antialiasing";
 
+// Disables use of DWM composition for top level windows.
+const char kDisableDwmComposition[] = "disable-dwm-composition";
+
 // Disables touch event based drag and drop.
 const char kDisableTouchDragDrop[] = "disable-touch-drag-drop";
 
diff --git a/ui/base/ui_base_switches.h b/ui/base/ui_base_switches.h
index 7f8155d24a560..d35e544f2bc2f 100644
--- a/ui/base/ui_base_switches.h
+++ b/ui/base/ui_base_switches.h
@@ -28,6 +28,7 @@ COMPONENT_EXPORT(UI_BASE) extern const char kEnableResourcesFileSharing[];
 #endif
 
 COMPONENT_EXPORT(UI_BASE) extern const char kDisableCompositedAntialiasing[];
+COMPONENT_EXPORT(UI_BASE) extern const char kDisableDwmComposition[];
 COMPONENT_EXPORT(UI_BASE) extern const char kDisableTouchDragDrop[];
 COMPONENT_EXPORT(UI_BASE) extern const char kEnableTouchDragDrop[];
 COMPONENT_EXPORT(UI_BASE) extern const char kForceCaptionStyle[];
diff --git a/ui/base/win/lock_state.cc b/ui/base/win/lock_state.cc
index e2136ed96ee92..791720d4a9b79 100644
--- a/ui/base/win/lock_state.cc
+++ b/ui/base/win/lock_state.cc
@@ -9,6 +9,7 @@
 
 #include "base/functional/bind.h"
 #include "base/no_destructor.h"
+#include "base/win/windows_version.h"
 #include "ui/base/win/session_change_observer.h"
 
 namespace ui {
@@ -24,8 +25,13 @@ bool IsSessionLocked() {
                                    WTSSessionInfoEx, &buffer, &buffer_length) &&
       buffer_length >= sizeof(WTSINFOEXW)) {
     auto* info = reinterpret_cast<WTSINFOEXW*>(buffer);
-    is_locked =
-        info->Data.WTSInfoExLevel1.SessionFlags == WTS_SESSIONSTATE_LOCK;
+    auto session_flags = info->Data.WTSInfoExLevel1.SessionFlags;
+    // For Windows 7 SessionFlags has inverted logic:
+    // https://msdn.microsoft.com/en-us/library/windows/desktop/ee621019.
+    if (base::win::GetVersion() == base::win::Version::WIN7)
+      is_locked = session_flags == WTS_SESSIONSTATE_UNLOCK;
+    else
+      is_locked = session_flags == WTS_SESSIONSTATE_LOCK;
   }
   if (buffer)
     ::WTSFreeMemory(buffer);
diff --git a/ui/base/win/shell.cc b/ui/base/win/shell.cc
index 024a6e4cf1638..36741dc9546de 100644
--- a/ui/base/win/shell.cc
+++ b/ui/base/win/shell.cc
@@ -11,6 +11,7 @@
 #include <shellapi.h>
 #include <wrl/client.h>
 
+#include "base/command_line.h"
 #include "base/debug/alias.h"
 #include "base/files/file.h"
 #include "base/files/file_path.h"
@@ -20,9 +21,11 @@
 #include "base/threading/scoped_blocking_call.h"
 #include "base/threading/scoped_thread_priority.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_switches.h"
 
-namespace ui::win {
+namespace ui {
+namespace win {
 
 namespace {
 
@@ -176,4 +179,28 @@ void ClearWindowPropertyStore(HWND hwnd) {
   DCHECK(FAILED(pps->GetCount(&property_count)) || property_count == 0);
 }
 
-}  // namespace ui::win
+bool IsAeroGlassEnabled() {
+  // For testing in Win8 (where it is not possible to disable composition) the
+  // user can specify this command line switch to mimic the behavior.  In this
+  // mode, cross-HWND transparency is not supported and various types of
+  // widgets fallback to more simplified rendering behavior.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableDwmComposition))
+    return false;
+
+  // If composition is not enabled, we behave like on XP.
+  return IsDwmCompositionEnabled();
+}
+
+bool IsDwmCompositionEnabled() {
+  // As of Windows 8, DWM composition is always enabled.
+  // In Windows 7 this can change at runtime.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    return true;
+  }
+  BOOL is_enabled;
+  return SUCCEEDED(DwmIsCompositionEnabled(&is_enabled)) && is_enabled;
+}
+
+}  // namespace win
+}  // namespace ui
diff --git a/ui/base/win/shell.h b/ui/base/win/shell.h
index 043abb1452e00..3a48c8870b7c9 100644
--- a/ui/base/win/shell.h
+++ b/ui/base/win/shell.h
@@ -15,7 +15,8 @@ namespace base {
 class FilePath;
 }
 
-namespace ui::win {
+namespace ui {
+namespace win {
 
 // Open the folder at |full_path| via the Windows shell. It is an error if
 // |full_path| does not refer to a folder.
@@ -75,6 +76,16 @@ void SetRelaunchDetailsForWindow(const std::wstring& relaunch_command,
 // Clears the Window Property Store on an HWND.
 COMPONENT_EXPORT(UI_BASE) void ClearWindowPropertyStore(HWND hwnd);
 
-}  // namespace ui::win
+// Returns true if dwm composition is available and turned on on the current
+// platform.
+// This method supports a command-line override for testing.
+COMPONENT_EXPORT(UI_BASE) bool IsAeroGlassEnabled();
+
+// Returns true if dwm composition is available and turned on on the current
+// platform.
+COMPONENT_EXPORT(UI_BASE) bool IsDwmCompositionEnabled();
+
+}  // namespace win
+}  // namespace ui
 
 #endif  // UI_BASE_WIN_SHELL_H_
diff --git a/ui/color/win/accent_color_observer.cc b/ui/color/win/accent_color_observer.cc
index 7de55ad8dfff4..6845d90149e60 100644
--- a/ui/color/win/accent_color_observer.cc
+++ b/ui/color/win/accent_color_observer.cc
@@ -7,6 +7,7 @@
 #include <utility>
 
 #include "base/no_destructor.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/skia_utils_win.h"
 #include "ui/gfx/color_utils.h"
 
@@ -19,12 +20,13 @@ AccentColorObserver* AccentColorObserver::Get() {
 }
 
 AccentColorObserver::AccentColorObserver() {
-  dwm_key_ = std::make_unique<base::win::RegKey>(
-      HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\DWM", KEY_READ);
-  if (dwm_key_->Valid()) {
-    OnDwmKeyUpdated();
-  } else {
-    dwm_key_.reset();
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    dwm_key_ = std::make_unique<base::win::RegKey>(
+        HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\DWM", KEY_READ);
+    if (dwm_key_->Valid())
+      OnDwmKeyUpdated();
+    else
+      dwm_key_.reset();
   }
 }
 
@@ -65,18 +67,20 @@ void AccentColorObserver::OnDwmKeyUpdated() {
 
   accent_color_ = absl::nullopt;
   accent_color_inactive_ = absl::nullopt;
-  DWORD accent_color, color_prevalence;
-  bool use_dwm_frame_color =
-      dwm_key_->ReadValueDW(L"AccentColor", &accent_color) == ERROR_SUCCESS &&
-      dwm_key_->ReadValueDW(L"ColorPrevalence", &color_prevalence) ==
-          ERROR_SUCCESS &&
-      color_prevalence == 1;
-  if (use_dwm_frame_color) {
-    accent_color_ = skia::COLORREFToSkColor(accent_color);
-    DWORD accent_color_inactive;
-    if (dwm_key_->ReadValueDW(L"AccentColorInactive", &accent_color_inactive) ==
-        ERROR_SUCCESS) {
-      accent_color_inactive_ = skia::COLORREFToSkColor(accent_color_inactive);
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    DWORD accent_color, color_prevalence;
+    bool use_dwm_frame_color =
+        dwm_key_->ReadValueDW(L"AccentColor", &accent_color) == ERROR_SUCCESS &&
+        dwm_key_->ReadValueDW(L"ColorPrevalence", &color_prevalence) ==
+            ERROR_SUCCESS &&
+        color_prevalence == 1;
+    if (use_dwm_frame_color) {
+      accent_color_ = skia::COLORREFToSkColor(accent_color);
+      DWORD accent_color_inactive;
+      if (dwm_key_->ReadValueDW(L"AccentColorInactive",
+                                &accent_color_inactive) == ERROR_SUCCESS) {
+        accent_color_inactive_ = skia::COLORREFToSkColor(accent_color_inactive);
+      }
     }
   }
 
diff --git a/ui/display/win/uwp_text_scale_factor.cc b/ui/display/win/uwp_text_scale_factor.cc
index 2d2d18c212bca..02b20a1b172db 100644
--- a/ui/display/win/uwp_text_scale_factor.cc
+++ b/ui/display/win/uwp_text_scale_factor.cc
@@ -10,8 +10,6 @@
 #include <wrl/client.h>
 #include <wrl/event.h>
 
-#include <memory>
-
 #include "base/lazy_instance.h"
 #include "base/logging.h"
 #include "base/strings/string_piece.h"
@@ -19,8 +17,10 @@
 #include "base/win/core_winrt_util.h"
 #include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_hstring.h"
+#include "base/win/windows_version.h"
 
-namespace display::win {
+namespace display {
+namespace win {
 
 namespace {
 
@@ -89,6 +89,11 @@ class UwpTextScaleFactorImpl : public UwpTextScaleFactor {
  public:
   UwpTextScaleFactorImpl()
       : text_scale_factor_changed_token_(kInvalidEventRegistrationToken) {
+    // There's no point in doing this initialization if we're earlier than
+    // Windows 10, since UWP is a Win10 feature.
+    if (base::win::GetVersion() < base::win::Version::WIN10)
+      return;
+
     // We want to bracket all use of our COM object with COM initialization
     // in order to be sure we don't leak COM listeners into the OS. This may
     // extend the lifetime of COM on this thread but we do not expect it to be
@@ -228,4 +233,5 @@ void UwpTextScaleFactor::Observer::OnUwpTextScaleFactorCleanup(
   source->RemoveObserver(this);
 }
 
-}  // namespace display::win
+}  // namespace win
+}  // namespace display
diff --git a/ui/gfx/font_fallback_unittest.cc b/ui/gfx/font_fallback_unittest.cc
index d662ab15c867e..62558cc547478 100644
--- a/ui/gfx/font_fallback_unittest.cc
+++ b/ui/gfx/font_fallback_unittest.cc
@@ -19,6 +19,10 @@
 #include "ui/gfx/platform_font.h"
 #include "ui/gfx/test/font_fallback_test_data.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gfx {
 
 namespace {
@@ -166,6 +170,15 @@ TEST_P(GetFallbackFontTest, GetFallbackFont) {
                          base_font_option_.weight);
   }
 
+#if BUILDFLAG(IS_WIN)
+  // Skip testing this call to GetFallbackFont on older windows versions. Some
+  // fonts only got introduced on windows 10 and the test will fail on previous
+  // versions.
+  const bool is_win10 = base::win::GetVersion() >= base::win::Version::WIN10;
+  if (test_case_.is_win10 && !is_win10)
+    return;
+#endif
+
   // Retrieve the name of the current script.
   script_name_ = uscript_getName(test_case_.script);
 
diff --git a/ui/gfx/font_fallback_win_unittest.cc b/ui/gfx/font_fallback_win_unittest.cc
index 880bc893a0838..76a2f76f4045e 100644
--- a/ui/gfx/font_fallback_win_unittest.cc
+++ b/ui/gfx/font_fallback_win_unittest.cc
@@ -6,6 +6,7 @@
 
 #include "base/strings/string_piece.h"
 #include "base/test/task_environment.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace gfx {
@@ -105,6 +106,10 @@ TEST_F(FontFallbackWinTest, NulTerminatedStringPiece) {
 }
 
 TEST_F(FontFallbackWinTest, CJKLocaleFallback) {
+  // The uniscribe fallback used by win7 does not support locale.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return;
+
   // Han unification is an effort to map multiple character sets of the CJK
   // languages into a single set of unified characters. Han characters are a
   // common feature of written Chinese (hanzi), Japanese (kanji), and Korean
diff --git a/ui/gfx/render_text.cc b/ui/gfx/render_text.cc
index 68a3c1f68f6c1..67fbf128ea158 100644
--- a/ui/gfx/render_text.cc
+++ b/ui/gfx/render_text.cc
@@ -42,6 +42,10 @@
 #include "ui/gfx/text_utils.h"
 #include "ui/gfx/utf16_indexing.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gfx {
 
 namespace {
@@ -253,23 +257,25 @@ UChar32 ReplaceControlCharacter(UChar32 codepoint) {
     // Support Microsoft defined PUA on Windows.
     // see:
     // https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font
-    switch (codepoint) {
-      case 0xF093:  // ButtonA
-      case 0xF094:  // ButtonB
-      case 0xF095:  // ButtonY
-      case 0xF096:  // ButtonX
-      case 0xF108:  // LeftStick
-      case 0xF109:  // RightStick
-      case 0xF10A:  // TriggerLeft
-      case 0xF10B:  // TriggerRight
-      case 0xF10C:  // BumperLeft
-      case 0xF10D:  // BumperRight
-      case 0xF10E:  // Dpad
-      case 0xEECA:  // ButtonView2
-      case 0xEDE3:  // ButtonMenu
-        return codepoint;
-      default:
-        break;
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      switch (codepoint) {
+        case 0xF093:  // ButtonA
+        case 0xF094:  // ButtonB
+        case 0xF095:  // ButtonY
+        case 0xF096:  // ButtonX
+        case 0xF108:  // LeftStick
+        case 0xF109:  // RightStick
+        case 0xF10A:  // TriggerLeft
+        case 0xF10B:  // TriggerRight
+        case 0xF10C:  // BumperLeft
+        case 0xF10D:  // BumperRight
+        case 0xF10E:  // Dpad
+        case 0xEECA:  // ButtonView2
+        case 0xEDE3:  // ButtonMenu
+          return codepoint;
+        default:
+          break;
+      }
     }
 #endif
     const int8_t codepoint_category = u_charType(codepoint);
diff --git a/ui/gfx/render_text_unittest.cc b/ui/gfx/render_text_unittest.cc
index 0a9ecc97d6f94..206c521b8e178 100644
--- a/ui/gfx/render_text_unittest.cc
+++ b/ui/gfx/render_text_unittest.cc
@@ -10,8 +10,6 @@
 
 #include <memory>
 #include <numeric>
-#include <set>
-#include <tuple>
 
 #include "base/format_macros.h"
 #include "base/i18n/break_iterator.h"
@@ -57,6 +55,8 @@
 
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
+
+#include "base/win/windows_version.h"
 #endif
 
 #if BUILDFLAG(IS_APPLE)
@@ -3451,8 +3451,7 @@ TEST_F(RenderTextTest, GetDisplayTextDirection) {
     for (size_t j = 0; j < std::size(cases); j++) {
       render_text->SetText(cases[j].text);
       render_text->SetDirectionalityMode(DIRECTIONALITY_FROM_TEXT);
-      EXPECT_EQ(render_text->GetDisplayTextDirection(),
-                cases[j].text_direction);
+      EXPECT_EQ(render_text->GetDisplayTextDirection(),cases[j].text_direction);
       render_text->SetDirectionalityMode(DIRECTIONALITY_FROM_UI);
       EXPECT_EQ(render_text->GetDisplayTextDirection(), ui_direction);
       render_text->SetDirectionalityMode(DIRECTIONALITY_FORCE_LTR);
@@ -6443,7 +6442,11 @@ TEST_F(RenderTextTest, MicrosoftSpecificPrivateUseCharacterReplacement) {
     RenderText* render_text = GetRenderText();
     render_text->SetText(codepoint);
 #if BUILDFLAG(IS_WIN)
-    EXPECT_EQ(codepoint, render_text->GetDisplayText());
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      EXPECT_EQ(codepoint, render_text->GetDisplayText());
+    } else {
+      EXPECT_EQ(u"\uFFFD", render_text->GetDisplayText());
+    }
 #else
     EXPECT_EQ(u"\uFFFD", render_text->GetDisplayText());
 #endif
@@ -6929,8 +6932,11 @@ TEST_F(RenderTextTest, HarfBuzz_ShapeRunsWithMultipleFonts) {
   EXPECT_EQ("[0->2][3][4->6]", GetRunListStructureString());
 
 #if BUILDFLAG(IS_WIN)
-  const std::vector<std::string> expected_fonts = {"Segoe UI Emoji", "Segoe UI",
-                                                   "Segoe UI Symbol"};
+  std::vector<std::string> expected_fonts;
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    expected_fonts = {"Segoe UI", "Segoe UI", "Segoe UI Symbol"};
+  else
+    expected_fonts = {"Segoe UI Emoji", "Segoe UI", "Segoe UI Symbol"};
 
   std::vector<std::string> mapped_fonts;
   for (const auto& font_span : GetFontSpans())
diff --git a/ui/gfx/test/font_fallback_test_data.cc b/ui/gfx/test/font_fallback_test_data.cc
index 1087cd15173e5..b968b878f28fa 100644
--- a/ui/gfx/test/font_fallback_test_data.cc
+++ b/ui/gfx/test/font_fallback_test_data.cc
@@ -10,6 +10,10 @@
 
 namespace gfx {
 
+#if BUILDFLAG(IS_WIN)
+constexpr bool kWin10Only = true;
+#endif
+
 FallbackFontTestCase::FallbackFontTestCase() = default;
 FallbackFontTestCase::FallbackFontTestCase(const FallbackFontTestCase& other) =
     default;
@@ -18,11 +22,13 @@ FallbackFontTestCase::FallbackFontTestCase(
     UScriptCode script_arg,
     std::string language_tag_arg,
     std::u16string text_arg,
-    std::vector<std::string> fallback_fonts_arg)
+    std::vector<std::string> fallback_fonts_arg,
+    bool is_win10_arg)
     : script(script_arg),
       language_tag(language_tag_arg),
       text(text_arg),
-      fallback_fonts(fallback_fonts_arg) {}
+      fallback_fonts(fallback_fonts_arg),
+      is_win10(is_win10_arg) {}
 
 FallbackFontTestCase::~FallbackFontTestCase() = default;
 
@@ -33,7 +39,7 @@ FallbackFontTestCase::~FallbackFontTestCase() = default;
 // TODO(drott): Some of the test cases lack a valid language tag as it's unclear
 // which language in particular would be expressed with the respective ancient
 // script. Ideally we'd find a meaningful language tag for those.
-const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
+std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
     {USCRIPT_ARABIC,
      "ar",
      u"\u062A\u062D",
@@ -44,31 +50,55 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
      {"Segoe UI", "Tahoma", "Sylfaen", "Times New Roman"}},
     {USCRIPT_BENGALI, "bn", u"\u09B8\u09AE", {"Nirmala UI", "Vrinda"}},
     {USCRIPT_BRAILLE, "en-us-brai", u"\u2870\u2871", {"Segoe UI Symbol"}},
-    {USCRIPT_BUGINESE, "bug", u"\u1A00\u1A01", {"Leelawadee UI"}},
+    {USCRIPT_BUGINESE, "bug", u"\u1A00\u1A01", {"Leelawadee UI"}, kWin10Only},
     {USCRIPT_CANADIAN_ABORIGINAL,
      "cans",
      u"\u1410\u1411",
      {"Gadugi", "Euphemia"}},
 
-    {USCRIPT_CARIAN, "xcr", u"\U000102A0\U000102A1", {"Segoe UI Historic"}},
+    {USCRIPT_CARIAN,
+     "xcr",
+     u"\U000102A0\U000102A1",
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_CHEROKEE,
      "chr",
      u"\u13A1\u13A2",
      {"Gadugi", "Plantagenet Cherokee"}},
 
-    {USCRIPT_COPTIC, "copt", u"\u2C81\u2C82", {"Segoe UI Historic"}},
+    {USCRIPT_COPTIC,
+     "copt",
+     u"\u2C81\u2C82",
+     {"Segoe UI Historic"},
+     kWin10Only},
 
-    {USCRIPT_CUNEIFORM, "akk", u"\U00012000\U0001200C", {"Segoe UI Historic"}},
+    {USCRIPT_CUNEIFORM,
+     "akk",
+     u"\U00012000\U0001200C",
+     {"Segoe UI Historic"},
+     kWin10Only},
 
-    {USCRIPT_CYPRIOT, "ecy", u"\U00010800\U00010801", {"Segoe UI Historic"}},
+    {USCRIPT_CYPRIOT,
+     "ecy",
+     u"\U00010800\U00010801",
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_CYRILLIC, "ru", u"\u0410\u0411\u0412", {"Times New Roman"}},
 
-    {USCRIPT_DESERET, "en", u"\U00010400\U00010401", {"Segoe UI Symbol"}},
+    {USCRIPT_DESERET,
+     "en",
+     u"\U00010400\U00010401",
+     {"Segoe UI Symbol"},
+     kWin10Only},
 
     {USCRIPT_ETHIOPIC, "am", u"\u1201\u1202", {"Ebrima", "Nyala"}},
-    {USCRIPT_GEORGIAN, "ka", u"\u10A0\u10A1", {"Sylfaen", "Segoe UI"}},
+    {USCRIPT_GEORGIAN,
+     "ka",
+     u"\u10A0\u10A1",
+     {"Sylfaen", "Segoe UI"},
+     kWin10Only},
     {USCRIPT_GREEK, "el", u"\u0391\u0392", {"Times New Roman"}},
     {USCRIPT_GURMUKHI, "pa", u"\u0A21\u0A22", {"Raavi", "Nirmala UI"}},
     {USCRIPT_HAN,
@@ -88,7 +118,11 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
      u"\u6211",
      {"Microsoft JhengHei", "Microsoft JhengHei UI"}},
     {USCRIPT_HAN, "ja", u"\u6211", {"Meiryo UI", "Yu Gothic UI", "Yu Gothic"}},
-    {USCRIPT_HANGUL, "ko", u"\u1100\u1101", {"Malgun Gothic", "Gulim"}},
+    {USCRIPT_HANGUL,
+     "ko",
+     u"\u1100\u1101",
+     {"Malgun Gothic", "Gulim"},
+     kWin10Only},
     {USCRIPT_HEBREW,
      "he",
      u"\u05D1\u05D2",
@@ -101,39 +135,57 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
     {USCRIPT_IMPERIAL_ARAMAIC,
      "arc",
      u"\U00010841\U00010842",
-     {"Segoe UI Historic"}},
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_INSCRIPTIONAL_PAHLAVI,
      "pal",
      u"\U00010B61\U00010B62",
-     {"Segoe UI Historic"}},
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_INSCRIPTIONAL_PARTHIAN,
      "xpr",
      u"\U00010B41\U00010B42",
-     {"Segoe UI Historic"}},
+     {"Segoe UI Historic"},
+     kWin10Only},
 
-    {USCRIPT_JAVANESE, "jv", u"\uA991\uA992", {"Javanese Text"}},
-    {USCRIPT_KHAROSHTHI, "sa", u"\U00010A10\U00010A11", {"Segoe UI Historic"}},
+    {USCRIPT_JAVANESE, "jv", u"\uA991\uA992", {"Javanese Text"}, kWin10Only},
+    {USCRIPT_KANNADA, "kn", u"\u0CA1\u0CA2", {"Nirmala UI", "Tunga"}},
+
+    {USCRIPT_KHAROSHTHI,
+     "sa",
+     u"\U00010A10\U00010A11",
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_LAO,
      "lo",
      u"\u0ED0\u0ED1",
      {"Lao UI", "Leelawadee UI", "Segoe UI"}},
-    {USCRIPT_LISU, "lis", u"\uA4D0\uA4D1", {"Segoe UI"}},
+    {USCRIPT_LISU, "lis", u"\uA4D0\uA4D1", {"Segoe UI"}, kWin10Only},
 
-    {USCRIPT_LYCIAN, "xlc", u"\U00010281\U00010282", {"Segoe UI Historic"}},
+    {USCRIPT_LYCIAN,
+     "xlc",
+     u"\U00010281\U00010282",
+     {"Segoe UI Historic"},
+     kWin10Only},
 
-    {USCRIPT_LYDIAN, "xld", u"\U00010921\U00010922", {"Segoe UI Historic"}},
+    {USCRIPT_LYDIAN,
+     "xld",
+     u"\U00010921\U00010922",
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_MALAYALAM, "ml", u"\u0D21\u0D22", {"Kartika", "Nirmala UI"}},
 
     {USCRIPT_MEROITIC_CURSIVE,
      "",
      u"\U000109A1\U000109A2",
-     {"Segoe UI Historic"}},
+     {"Segoe UI Historic"},
+     kWin10Only},
 
-    {USCRIPT_MYANMAR, "my", u"\u1000\u1001", {"Myanmar Text"}},
+    {USCRIPT_MYANMAR, "my", u"\u1000\u1001", {"Myanmar Text"}, kWin10Only},
     {USCRIPT_NEW_TAI_LUE, "", u"\u1981\u1982", {"Microsoft New Tai Lue"}},
     {USCRIPT_NKO, "nko", u"\u07C1\u07C2", {"Ebrima", "Segoe UI"}},
 
@@ -142,7 +194,7 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
      u"\u1680\u1681",
      {"Segoe UI Symbol", "Segoe UI Historic"}},
 
-    {USCRIPT_OL_CHIKI, "", u"\u1C51\u1C52", {"Nirmala UI"}},
+    {USCRIPT_OL_CHIKI, "", u"\u1C51\u1C52", {"Nirmala UI"}, kWin10Only},
 
     {USCRIPT_OLD_ITALIC,
      "",
@@ -152,12 +204,14 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
     {USCRIPT_OLD_PERSIAN,
      "peo",
      u"\U000103A1\U000103A2",
-     {"Segoe UI Historic"}},
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_OLD_SOUTH_ARABIAN,
      "",
      u"\U00010A61\U00010A62",
-     {"Segoe UI Historic"}},
+     {"Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_ORIYA, "or", u"\u0B21\u0B22", {"Kalinga", "Nirmala UI"}},
     {USCRIPT_PHAGS_PA, "", u"\uA841\uA842", {"Microsoft PhagsPa"}},
@@ -170,11 +224,16 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
     {USCRIPT_SHAVIAN,
      "",
      u"\U00010451\U00010452",
-     {"Segoe UI", "Segoe UI Historic"}},
+     {"Segoe UI", "Segoe UI Historic"},
+     kWin10Only},
 
     {USCRIPT_SINHALA, "si", u"\u0D91\u0D92", {"Iskoola Pota", "Nirmala UI"}},
 
-    {USCRIPT_SORA_SOMPENG, "", u"\U000110D1\U000110D2", {"Nirmala UI"}},
+    {USCRIPT_SORA_SOMPENG,
+     "",
+     u"\U000110D1\U000110D2",
+     {"Nirmala UI"},
+     kWin10Only},
 
     {USCRIPT_SYRIAC,
      "syr",
@@ -188,7 +247,8 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
     {USCRIPT_THAI,
      "th",
      u"\u0e01\u0e02",
-     {"Tahoma", "Leelawadee UI", "Leelawadee"}},
+     {"Tahoma", "Leelawadee UI", "Leelawadee"},
+     kWin10Only},
     {USCRIPT_TIBETAN, "bo", u"\u0F01\u0F02", {"Microsoft Himalaya"}},
     {USCRIPT_TIFINAGH, "", u"\u2D31\u2D32", {"Ebrima"}},
     {USCRIPT_VAI, "vai", u"\uA501\uA502", {"Ebrima"}},
@@ -200,7 +260,7 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
 // On linux, font-config configuration and fonts are mock. The config
 // can be found in '${build}/etc/fonts/fonts.conf' and the test fonts
 // can be found in '${build}/test_fonts/*'.
-const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
+std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
     {USCRIPT_BENGALI, "bn", u"\u09B8\u09AE", {"Mukti Narrow"}},
     {USCRIPT_DEVANAGARI, "hi", u"\u0905\u0906", {"Lohit Devanagari"}},
     {USCRIPT_GURMUKHI, "pa", u"\u0A21\u0A22", {"Lohit Gurmukhi"}},
@@ -213,7 +273,7 @@ const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {
 #else
 
 // No fallback font tests are defined on that platform.
-const std::vector<FallbackFontTestCase> kGetFontFallbackTests = {};
+std::vector<FallbackFontTestCase> kGetFontFallbackTests = {};
 
 #endif
 
diff --git a/ui/gfx/test/font_fallback_test_data.h b/ui/gfx/test/font_fallback_test_data.h
index 24bf19f56e8fe..c4bf426c939dd 100644
--- a/ui/gfx/test/font_fallback_test_data.h
+++ b/ui/gfx/test/font_fallback_test_data.h
@@ -18,16 +18,18 @@ struct FallbackFontTestCase {
   FallbackFontTestCase(UScriptCode script_arg,
                        std::string language_tag_arg,
                        std::u16string text_arg,
-                       std::vector<std::string> fallback_fonts_arg);
+                       std::vector<std::string> fallback_fonts_arg,
+                       bool is_win10_arg = false);
   FallbackFontTestCase(const FallbackFontTestCase& other);
   ~FallbackFontTestCase();
   UScriptCode script;
   std::string language_tag;
   std::u16string text;
   std::vector<std::string> fallback_fonts;
+  bool is_win10 = false;
 };
 
-extern const std::vector<FallbackFontTestCase> kGetFontFallbackTests;
+extern std::vector<FallbackFontTestCase> kGetFontFallbackTests;
 
 }  // namespace gfx
 
diff --git a/ui/gfx/win/direct_write.cc b/ui/gfx/win/direct_write.cc
index bc17d6e4ccd4b..089a6bc5c35b5 100644
--- a/ui/gfx/win/direct_write.cc
+++ b/ui/gfx/win/direct_write.cc
@@ -9,9 +9,11 @@
 #include <string>
 
 #include "base/debug/alias.h"
+#include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/fontmgr_default.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
@@ -60,11 +62,37 @@ void InitializeDirectWrite() {
   CHECK(!!factory);
   SetDirectWriteFactory(factory.Get());
 
+  // The skia call to create a new DirectWrite font manager instance can fail
+  // if we are unable to get the system font collection from the DirectWrite
+  // factory. The GetSystemFontCollection method in the IDWriteFactory
+  // interface fails with E_INVALIDARG on certain Windows 7 gold versions
+  // (6.1.7600.*).
   sk_sp<SkFontMgr> direct_write_font_mgr =
       SkFontMgr_New_DirectWrite(factory.Get());
-  if (!direct_write_font_mgr) {
-    direct_write_font_mgr = SkFontMgr_New_GDI();
+  int iteration = 0;
+  if (!direct_write_font_mgr &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    // Windows (win7_rtm) may fail to map the service sections
+    // (crbug.com/956064).
+    constexpr int kMaxRetries = 5;
+    constexpr base::TimeDelta kRetrySleepTime = base::Microseconds(500);
+    while (iteration < kMaxRetries) {
+      base::PlatformThread::Sleep(kRetrySleepTime);
+      direct_write_font_mgr = SkFontMgr_New_DirectWrite(factory.Get());
+      if (direct_write_font_mgr)
+        break;
+      ++iteration;
+    }
   }
+  if (!direct_write_font_mgr)
+    iteration = -1;
+  base::UmaHistogramSparse("DirectWrite.Fonts.Gfx.InitializeLoopCount",
+                           iteration);
+  // TODO(crbug.com/956064): Move to a CHECK when the cause of the crash is
+  // fixed and remove the if statement that fallback to GDI font manager.
+  DCHECK(!!direct_write_font_mgr);
+  if (!direct_write_font_mgr)
+    direct_write_font_mgr = SkFontMgr_New_GDI();
 
   // Override the default skia font manager. This must be called before any
   // use of the skia font manager is done (e.g. before any call to
diff --git a/ui/gl/direct_composition_child_surface_win.cc b/ui/gl/direct_composition_child_surface_win.cc
index 72a07a75be17d..b2094da1f5fb2 100644
--- a/ui/gl/direct_composition_child_surface_win.cc
+++ b/ui/gl/direct_composition_child_surface_win.cc
@@ -16,6 +16,7 @@
 #include "base/synchronization/waitable_event.h"
 #include "base/trace_event/trace_event.h"
 #include "base/trace_event/traced_value.h"
+#include "base/win/windows_version.h"
 #include "ui/gfx/color_space_win.h"
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gl/direct_composition_support.h"
@@ -52,7 +53,9 @@ bool IsVerifyDrawOffsetEnabled() {
 }
 
 bool IsWaitableSwapChainEnabled() {
-  return base::FeatureList::IsEnabled(features::kDXGIWaitableSwapChain);
+  // Waitable swap chains were first enabled in Win 8.1/DXGI 1.3
+  return (base::win::GetVersion() >= base::win::Version::WIN8_1) &&
+         base::FeatureList::IsEnabled(features::kDXGIWaitableSwapChain);
 }
 
 UINT GetMaxWaitableQueuedFrames() {
diff --git a/ui/message_center/views/message_view.cc b/ui/message_center/views/message_view.cc
index 22994c2effa66..a61fd4d378df9 100644
--- a/ui/message_center/views/message_view.cc
+++ b/ui/message_center/views/message_view.cc
@@ -39,13 +39,17 @@
 #include "base/time/time.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
+#endif
+
 namespace message_center {
 
 namespace {
 
 bool ShouldShowAeroShadowBorder() {
 #if BUILDFLAG(IS_WIN)
-  return true;
+  return ui::win::IsAeroGlassEnabled();
 #else
   return false;
 #endif
diff --git a/ui/native_theme/caption_style_win.cc b/ui/native_theme/caption_style_win.cc
index ece5fe25b53e7..a8b745c946aea 100644
--- a/ui/native_theme/caption_style_win.cc
+++ b/ui/native_theme/caption_style_win.cc
@@ -14,6 +14,7 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/skia_utils_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/color_utils.h"
@@ -172,6 +173,7 @@ std::string GetCssColorWithAlpha(CC::ClosedCaptionColor caption_color,
 
 absl::optional<CaptionStyle> InitializeFromSystemSettings() {
   TRACE_EVENT0("ui", "InitializeFromSystemSettings");
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
   DCHECK(base::FeatureList::IsEnabled(features::kSystemCaptionStyle));
 
   // Need to do this check before using ScopedHString.
@@ -278,10 +280,12 @@ absl::optional<CaptionStyle> InitializeFromSystemSettings() {
 }  // namespace
 
 absl::optional<CaptionStyle> CaptionStyle::FromSystemSettings() {
-  if (base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
     return InitializeFromSystemSettings();
   }
-  // Return default CaptionStyle if kSystemCaptionStyle is not enabled.
+  // Return default CaptionStyle for pre Win10 versions since system settings
+  // don't allow caption styling.
   return absl::nullopt;
 }
 
diff --git a/ui/native_theme/caption_style_win_unittest.cc b/ui/native_theme/caption_style_win_unittest.cc
index 53a70a339c37d..6364d352d2d8f 100644
--- a/ui/native_theme/caption_style_win_unittest.cc
+++ b/ui/native_theme/caption_style_win_unittest.cc
@@ -6,32 +6,35 @@
 
 #include "base/test/scoped_feature_list.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/base/ui_base_features.h"
 
 namespace ui {
 
 // Test to ensure closed caption styling from system settings can be obtained
-// (we obtain a CaptionStyle).
+// (we obtain a CaptionStyle) on Windows 10.
 TEST(CaptionStyleWinTest, TestWinCaptionStyle) {
   base::test::ScopedFeatureList scoped_feature_list;
   scoped_feature_list.InitAndEnableFeature(features::kSystemCaptionStyle);
 
-  base::win::ScopedCOMInitializer com_initializer;
-  ASSERT_TRUE(com_initializer.Succeeded());
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+    base::win::ScopedCOMInitializer com_initializer;
+    ASSERT_TRUE(com_initializer.Succeeded());
 
-  absl::optional<ui::CaptionStyle> caption_style =
-      ui::CaptionStyle::FromSystemSettings();
-  // On Windows out of the box, all caption style properties are set to
-  // Default. In which case, each of these should be empty.
-  ASSERT_TRUE(caption_style.has_value());
-  EXPECT_TRUE(caption_style->background_color.empty());
-  EXPECT_TRUE(caption_style->font_family.empty());
-  EXPECT_TRUE(caption_style->font_variant.empty());
-  EXPECT_TRUE(caption_style->text_color.empty());
-  EXPECT_TRUE(caption_style->text_shadow.empty());
-  EXPECT_TRUE(caption_style->text_size.empty());
-  EXPECT_TRUE(caption_style->window_color.empty());
+    absl::optional<ui::CaptionStyle> caption_style =
+        ui::CaptionStyle::FromSystemSettings();
+    // On Windows out of the box, all caption style properties are set to
+    // Default. In which case, each of these should be empty.
+    ASSERT_TRUE(caption_style.has_value());
+    EXPECT_TRUE(caption_style->background_color.empty());
+    EXPECT_TRUE(caption_style->font_family.empty());
+    EXPECT_TRUE(caption_style->font_variant.empty());
+    EXPECT_TRUE(caption_style->text_color.empty());
+    EXPECT_TRUE(caption_style->text_shadow.empty());
+    EXPECT_TRUE(caption_style->text_size.empty());
+    EXPECT_TRUE(caption_style->window_color.empty());
+  }
 }
 
 }  // namespace ui
diff --git a/ui/platform_window/win/win_window.cc b/ui/platform_window/win/win_window.cc
index 605e36bdc1562..7677a2a6fc7c0 100644
--- a/ui/platform_window/win/win_window.cc
+++ b/ui/platform_window/win/win_window.cc
@@ -14,6 +14,7 @@
 #include "base/notreached.h"
 #include "base/strings/string_util_win.h"
 #include "ui/base/cursor/platform_cursor.h"
+#include "ui/base/win/shell.h"
 #include "ui/base/win/win_cursor.h"
 #include "ui/events/event.h"
 #include "ui/events/event_utils.h"
@@ -186,9 +187,9 @@ bool WinWindow::ShouldWindowContentsBeTransparent() const {
   // by the DWM rather than Chrome, so that area can show through.  This
   // function does not describe the transparency of the whole window appearance,
   // but merely of the content Chrome draws, so even when the system titlebars
-  // appear opaque, the content above them needs to be transparent, or they'll
-  // be covered by a black (undrawn) region.
-  return !IsFullscreen();
+  // appear opaque (Win 8+), the content above them needs to be transparent, or
+  // they'll be covered by a black (undrawn) region.
+  return ui::win::IsAeroGlassEnabled() && !IsFullscreen();
 }
 
 void WinWindow::SetZOrderLevel(ZOrderLevel order) {
diff --git a/ui/shell_dialogs/select_file_dialog_win_unittest.cc b/ui/shell_dialogs/select_file_dialog_win_unittest.cc
index 8465e5ecba3fb..4527e1fdc438a 100644
--- a/ui/shell_dialogs/select_file_dialog_win_unittest.cc
+++ b/ui/shell_dialogs/select_file_dialog_win_unittest.cc
@@ -21,6 +21,7 @@
 #include "base/test/test_timeouts.h"
 #include "base/threading/platform_thread.h"
 #include "base/win/scoped_com_initializer.h"
+#include "base/win/windows_version.h"
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
@@ -198,6 +199,10 @@ class SelectFileDialogWinTest : public ::testing::Test,
 };
 
 TEST_F(SelectFileDialogWinTest, CancelAllDialogs) {
+  // TODO(crbug.com/1265379): Flaky on Windows 7.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    GTEST_SKIP() << "Skipping test for Windows 7";
+
   // Intentionally not testing SELECT_UPLOAD_FOLDER because the dialog is
   // customized for that case.
   struct {
diff --git a/ui/snapshot/snapshot_aura_unittest.cc b/ui/snapshot/snapshot_aura_unittest.cc
index ce57e77c4b273..d595d2491955b 100644
--- a/ui/snapshot/snapshot_aura_unittest.cc
+++ b/ui/snapshot/snapshot_aura_unittest.cc
@@ -212,10 +212,10 @@ TEST_F(SnapshotAuraTest, MAYBE_FullScreenWindow) {
         // BUILDFLAG(IS_FUCHSIA)
 
 #if BUILDFLAG(IS_WIN)
-  // TODO(https://crbug.com/850556): Make work on Windows.
-  if (::testing::internal::AlwaysTrue()) {
-    GTEST_SKIP();
-  }
+  // TODO(https://crbug.com/850556): Make work on Win10.
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10)
+    return;
 #endif
   SetupTestWindow(root_window()->bounds());
   WaitForDraw();
@@ -228,10 +228,10 @@ TEST_F(SnapshotAuraTest, MAYBE_FullScreenWindow) {
 
 TEST_F(SnapshotAuraTest, PartialBounds) {
 #if BUILDFLAG(IS_WIN)
-  // TODO(https://crbug.com/850556): Make work on Windows.
-  if (::testing::internal::AlwaysTrue()) {
-    GTEST_SKIP();
-  }
+  // TODO(https://crbug.com/850556): Make work on Win10.
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10)
+    return;
 #endif
   gfx::Rect test_bounds(100, 100, 300, 200);
   SetupTestWindow(test_bounds);
@@ -244,10 +244,10 @@ TEST_F(SnapshotAuraTest, PartialBounds) {
 
 TEST_F(SnapshotAuraTest, Rotated) {
 #if BUILDFLAG(IS_WIN)
-  // TODO(https://crbug.com/850556): Make work on Windows.
-  if (::testing::internal::AlwaysTrue()) {
-    GTEST_SKIP();
-  }
+  // TODO(https://crbug.com/850556): Make work on Win10.
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10)
+    return;
 #endif
   test_screen()->SetDisplayRotation(display::Display::ROTATE_90);
 
@@ -262,10 +262,10 @@ TEST_F(SnapshotAuraTest, Rotated) {
 
 TEST_F(SnapshotAuraTest, UIScale) {
 #if BUILDFLAG(IS_WIN)
-  // TODO(https://crbug.com/850556): Make work on Windows.
-  if (::testing::internal::AlwaysTrue()) {
-    GTEST_SKIP();
-  }
+  // TODO(https://crbug.com/850556): Make work on Win10.
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10)
+    return;
 #endif
   const float kUIScale = 0.5f;
   test_screen()->SetUIScale(kUIScale);
@@ -286,10 +286,10 @@ TEST_F(SnapshotAuraTest, UIScale) {
 
 TEST_F(SnapshotAuraTest, DeviceScaleFactor) {
 #if BUILDFLAG(IS_WIN)
-  // TODO(https://crbug.com/850556): Make work on Windows.
-  if (::testing::internal::AlwaysTrue()) {
-    GTEST_SKIP();
-  }
+  // TODO(https://crbug.com/850556): Make work on Win10.
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10)
+    return;
 #endif
   test_screen()->SetDeviceScaleFactor(2.0f);
 
@@ -309,10 +309,10 @@ TEST_F(SnapshotAuraTest, DeviceScaleFactor) {
 
 TEST_F(SnapshotAuraTest, RotateAndUIScale) {
 #if BUILDFLAG(IS_WIN)
-  // TODO(https://crbug.com/850556): Make work on Windows.
-  if (::testing::internal::AlwaysTrue()) {
-    GTEST_SKIP();
-  }
+  // TODO(https://crbug.com/850556): Make work on Win10.
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10)
+    return;
 #endif
   const float kUIScale = 0.5f;
   test_screen()->SetUIScale(kUIScale);
@@ -334,10 +334,10 @@ TEST_F(SnapshotAuraTest, RotateAndUIScale) {
 
 TEST_F(SnapshotAuraTest, RotateAndUIScaleAndScaleFactor) {
 #if BUILDFLAG(IS_WIN)
-  // TODO(https://crbug.com/850556): Make work on Windows.
-  if (::testing::internal::AlwaysTrue()) {
-    GTEST_SKIP();
-  }
+  // TODO(https://crbug.com/850556): Make work on Win10.
+  base::win::Version version = base::win::GetVersion();
+  if (version >= base::win::Version::WIN10)
+    return;
 #endif
   test_screen()->SetDeviceScaleFactor(2.0f);
   const float kUIScale = 0.5f;
diff --git a/ui/snapshot/snapshot_win.cc b/ui/snapshot/snapshot_win.cc
index 74d600db1ea5e..c7afae3de99f7 100644
--- a/ui/snapshot/snapshot_win.cc
+++ b/ui/snapshot/snapshot_win.cc
@@ -5,7 +5,6 @@
 #include "ui/snapshot/snapshot_win.h"
 
 #include <memory>
-#include <utility>
 
 #include "base/functional/callback.h"
 #include "base/win/windows_version.h"
@@ -21,6 +20,17 @@
 #include "ui/snapshot/snapshot.h"
 #include "ui/snapshot/snapshot_aura.h"
 
+namespace {
+
+// Windows 8.1 is the first version that supports PW_RENDERFULLCONTENT.
+// Without that flag PrintWindow may not correctly capture what's actually
+// onscreen.
+bool UseAuraSnapshot() {
+  return (base::win::GetVersion() < base::win::Version::WIN8_1);
+}
+
+}  // namespace
+
 namespace ui {
 
 namespace internal {
@@ -85,6 +95,11 @@ bool GrabViewSnapshot(gfx::NativeView view_handle,
 bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
                         const gfx::Rect& snapshot_bounds,
                         gfx::Image* image) {
+  if (UseAuraSnapshot()) {
+    // Not supported in Aura.  Callers should fall back to the async version.
+    return false;
+  }
+
   DCHECK(window_handle);
   gfx::Rect window_bounds = window_handle->GetBoundsInRootWindow();
   aura::WindowTreeHost* host = window_handle->GetHost();
@@ -109,6 +124,10 @@ bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
 void GrabWindowSnapshotAsync(gfx::NativeWindow window,
                              const gfx::Rect& source_rect,
                              GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(window, source_rect, std::move(callback));
+    return;
+  }
   gfx::Image image;
   GrabWindowSnapshot(window, source_rect, &image);
   std::move(callback).Run(image);
@@ -117,6 +136,10 @@ void GrabWindowSnapshotAsync(gfx::NativeWindow window,
 void GrabViewSnapshotAsync(gfx::NativeView view,
                            const gfx::Rect& source_rect,
                            GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(view, source_rect, std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
@@ -125,6 +148,11 @@ void GrabWindowSnapshotAndScaleAsync(gfx::NativeWindow window,
                                      const gfx::Rect& source_rect,
                                      const gfx::Size& target_size,
                                      GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAndScaleAsyncAura(window, source_rect, target_size,
+                                        std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
diff --git a/ui/views/BUILD.gn b/ui/views/BUILD.gn
index accb869030e59..215a0852380a6 100644
--- a/ui/views/BUILD.gn
+++ b/ui/views/BUILD.gn
@@ -723,10 +723,12 @@ component("views") {
       "accessibility/ax_widget_obj_wrapper.h",
       "accessibility/ax_window_obj_wrapper.h",
       "controls/native/native_view_host_aura.h",
+      "corewm/cursor_height_provider_win.h",
       "corewm/tooltip.h",
       "corewm/tooltip_aura.h",
       "corewm/tooltip_controller.h",
       "corewm/tooltip_state_manager.h",
+      "corewm/tooltip_win.h",
       "event_monitor_aura.h",
       "native_window_tracker_aura.h",
       "touchui/touch_selection_controller_impl.h",
@@ -770,6 +772,12 @@ component("views") {
       "widget/tooltip_manager_aura.cc",
       "widget/window_reorderer.cc",
     ]
+    if (is_win) {
+      sources += [
+        "corewm/cursor_height_provider_win.cc",
+        "corewm/tooltip_win.cc",
+      ]
+    }
     if (!is_chromeos_ash) {
       sources += [
         "accessibility/views_ax_tree_manager.cc",
diff --git a/ui/views/bubble/bubble_border.cc b/ui/views/bubble/bubble_border.cc
index 103d09a5e2273..cdaa8495ddcdd 100644
--- a/ui/views/bubble/bubble_border.cc
+++ b/ui/views/bubble/bubble_border.cc
@@ -344,8 +344,8 @@ gfx::Rect BubbleBorder::GetBounds(const gfx::Rect& anchor_rect,
 
   // With NO_SHADOW, there should be further insets, but the same logic is
   // used to position the bubble origin according to |anchor_rect|.
-  DCHECK(shadow_ != NO_SHADOW || insets_.has_value() ||
-         shadow_insets.IsEmpty() || visible_arrow_);
+  DCHECK((shadow_ != NO_SHADOW && shadow_ != NO_SHADOW_LEGACY) ||
+         insets_.has_value() || shadow_insets.IsEmpty() || visible_arrow_);
   if (!avoid_shadow_overlap_)
     contents_bounds.Inset(-shadow_insets);
 
@@ -445,13 +445,17 @@ void BubbleBorder::Paint(const views::View& view, gfx::Canvas* canvas) {
     return;
   }
 
-  gfx::ScopedCanvas scoped(canvas);
-  SkRRect r_rect = GetClientRect(view);
-  canvas->sk_canvas()->clipRRect(r_rect, SkClipOp::kDifference,
-                                 true /*doAntiAlias*/);
-  DrawBorderAndShadowImpl(r_rect, &cc::PaintCanvas::drawRRect, canvas,
-                          view.GetColorProvider(), md_shadow_elevation_,
-                          shadow_);
+  if (shadow_ == NO_SHADOW_LEGACY) {
+    PaintNoShadowLegacy(view, canvas);
+  } else {
+    gfx::ScopedCanvas scoped(canvas);
+    SkRRect r_rect = GetClientRect(view);
+    canvas->sk_canvas()->clipRRect(r_rect, SkClipOp::kDifference,
+                                   true /*doAntiAlias*/);
+    DrawBorderAndShadowImpl(r_rect, &cc::PaintCanvas::drawRRect, canvas,
+                            view.GetColorProvider(), md_shadow_elevation_,
+                            shadow_);
+  }
 
   if (visible_arrow_)
     PaintVisibleArrow(view, canvas);
@@ -475,6 +479,9 @@ gfx::Insets BubbleBorder::GetInsets() const {
   gfx::Insets insets;
 
   switch (shadow_) {
+    case NO_SHADOW_LEGACY:
+      insets = gfx::Insets(kBorderThicknessDip);
+      break;
     case STANDARD_SHADOW:
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     case CHROMEOS_SYSTEM_UI_SHADOW:
@@ -689,6 +696,19 @@ void BubbleBorder::PaintNoShadow(const View& view, gfx::Canvas* canvas) {
   canvas->sk_canvas()->drawColor(SkColors::kTransparent, SkBlendMode::kSrc);
 }
 
+void BubbleBorder::PaintNoShadowLegacy(const View& view, gfx::Canvas* canvas) {
+  gfx::RectF bounds(view.GetLocalBounds());
+  bounds.Inset(gfx::InsetsF(kBorderThicknessDip / 2.0f));
+  cc::PaintFlags flags;
+  flags.setAntiAlias(true);
+  flags.setStyle(cc::PaintFlags::kStroke_Style);
+  flags.setStrokeWidth(kBorderThicknessDip);
+  SkColor kBorderColor =
+      view.GetColorProvider()->GetColor(ui::kColorBubbleBorder);
+  flags.setColor(kBorderColor);
+  canvas->DrawRoundRect(bounds, corner_radius(), flags);
+}
+
 void BubbleBorder::PaintVisibleArrow(const View& view, gfx::Canvas* canvas) {
   gfx::Point arrow_origin = visible_arrow_rect_.origin();
   View::ConvertPointFromScreen(&view, &arrow_origin);
diff --git a/ui/views/bubble/bubble_border.h b/ui/views/bubble/bubble_border.h
index 50929120456a1..b9db87afb618c 100644
--- a/ui/views/bubble/bubble_border.h
+++ b/ui/views/bubble/bubble_border.h
@@ -66,7 +66,10 @@ class VIEWS_EXPORT BubbleBorder : public Border {
   };
 
   enum Shadow {
-    STANDARD_SHADOW = 0,
+    // NO_SHADOW_LEGACY is obsolete. Used only for Win7 where custom shadows are
+    // not supported.
+    NO_SHADOW_LEGACY = 0,
+    STANDARD_SHADOW,
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     // CHROMEOS_SYSTEM_UI_SHADOW uses ChromeOS system UI shadow style.
     CHROMEOS_SYSTEM_UI_SHADOW,
@@ -292,6 +295,10 @@ class VIEWS_EXPORT BubbleBorder : public Border {
   // to make the window shape based on insets and GetBorderCornerRadius().
   void PaintNoShadow(const View& view, gfx::Canvas* canvas);
 
+  // Paint for the NO_SHADOW_LEGACY shadow type. This paints a simple line
+  // border.
+  void PaintNoShadowLegacy(const View& view, gfx::Canvas* canvas);
+
   // Paint a visible arrow pointing to the anchor region.
   void PaintVisibleArrow(const View& view, gfx::Canvas* canvas);
 
diff --git a/ui/views/bubble/bubble_border_unittest.cc b/ui/views/bubble/bubble_border_unittest.cc
index 2496869a09fdb..69647acce946e 100644
--- a/ui/views/bubble/bubble_border_unittest.cc
+++ b/ui/views/bubble/bubble_border_unittest.cc
@@ -212,7 +212,8 @@ TEST_F(BubbleBorderTest, IsArrowAtCenter) {
 }
 
 TEST_F(BubbleBorderTest, GetSizeForContentsSizeTest) {
-  views::BubbleBorder border(BubbleBorder::NONE, BubbleBorder::NO_SHADOW);
+  views::BubbleBorder border(BubbleBorder::NONE,
+                             BubbleBorder::NO_SHADOW_LEGACY);
 
   const gfx::Insets kInsets = border.GetInsets();
 
diff --git a/ui/views/bubble/bubble_dialog_delegate_view.cc b/ui/views/bubble/bubble_dialog_delegate_view.cc
index fea3d6b66ab44..455d8e7d18b95 100644
--- a/ui/views/bubble/bubble_dialog_delegate_view.cc
+++ b/ui/views/bubble/bubble_dialog_delegate_view.cc
@@ -142,13 +142,23 @@ class BubbleDialogFrameView : public BubbleFrameView {
   gfx::Size GetMaximumSize() const override { return gfx::Size(); }
 };
 
+bool CustomShadowsSupported() {
+#if BUILDFLAG(IS_WIN)
+  return ui::win::IsAeroGlassEnabled();
+#else
+  return true;
+#endif
+}
+
 // Create a widget to host the bubble.
 Widget* CreateBubbleWidget(BubbleDialogDelegate* bubble) {
   DCHECK(bubble->owned_by_widget());
   Widget* bubble_widget = new BubbleWidget();
   Widget::InitParams bubble_params(Widget::InitParams::TYPE_BUBBLE);
   bubble_params.delegate = bubble;
-  bubble_params.opacity = Widget::InitParams::WindowOpacity::kTranslucent;
+  bubble_params.opacity = CustomShadowsSupported()
+                              ? Widget::InitParams::WindowOpacity::kTranslucent
+                              : Widget::InitParams::WindowOpacity::kOpaque;
   bubble_params.accept_events = bubble->accept_events();
   bubble_params.remove_standard_frame = true;
   bubble_params.layer_type = bubble->GetLayerType();
@@ -156,8 +166,10 @@ Widget* CreateBubbleWidget(BubbleDialogDelegate* bubble) {
   // Use a window default shadow if the bubble doesn't provides its own.
   if (bubble->GetShadow() == BubbleBorder::NO_SHADOW)
     bubble_params.shadow_type = Widget::InitParams::ShadowType::kDefault;
-  else
+  else if (CustomShadowsSupported())
     bubble_params.shadow_type = Widget::InitParams::ShadowType::kNone;
+  else
+    bubble_params.shadow_type = Widget::InitParams::ShadowType::kDrop;
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   bubble_params.background_elevation =
       ui::ColorProviderManager::ElevationMode::kHigh;
@@ -526,9 +538,8 @@ BubbleDialogDelegate::CreateNonClientFrameView(Widget* widget) {
   std::unique_ptr<BubbleBorder> border =
       std::make_unique<BubbleBorder>(arrow(), GetShadow());
   border->SetColor(color());
-  if (GetParams().round_corners) {
+  if (CustomShadowsSupported() && GetParams().round_corners)
     border->SetCornerRadius(GetCornerRadius());
-  }
 
   frame->SetBubbleBorder(std::move(border));
   return frame;
@@ -603,7 +614,9 @@ void BubbleDialogDelegate::OnAnchorWidgetBoundsChanged() {
 
 
 BubbleBorder::Shadow BubbleDialogDelegate::GetShadow() const {
-  return shadow_;
+  if (CustomShadowsSupported() || shadow_ == BubbleBorder::NO_SHADOW)
+    return shadow_;
+  return BubbleBorder::NO_SHADOW_LEGACY;
 }
 
 View* BubbleDialogDelegate::GetAnchorView() const {
diff --git a/ui/views/bubble/bubble_dialog_delegate_view_unittest.cc b/ui/views/bubble/bubble_dialog_delegate_view_unittest.cc
index fb94feafbb57d..0bc5c08632e39 100644
--- a/ui/views/bubble/bubble_dialog_delegate_view_unittest.cc
+++ b/ui/views/bubble/bubble_dialog_delegate_view_unittest.cc
@@ -37,6 +37,10 @@
 #include "ui/views/widget/widget.h"
 #include "ui/views/widget/widget_observer.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
+#endif
+
 namespace views {
 
 using test::TestInkDrop;
@@ -405,13 +409,21 @@ TEST_F(BubbleDialogDelegateViewTest, NonClientHitTest) {
   BubbleDialogDelegateView::CreateBubble(bubble_delegate);
   BubbleFrameView* frame = bubble_delegate->GetBubbleFrameView();
 
+#if BUILDFLAG(IS_WIN)
+  bool is_aero_glass_enabled = ui::win::IsAeroGlassEnabled();
+#endif
+
   struct {
     const int point;
     const int hit;
   } kTestCases[] = {
-      {0, HTTRANSPARENT},
-      {60, HTCLIENT},
-      {1000, HTNOWHERE},
+#if BUILDFLAG(IS_WIN)
+    {0, is_aero_glass_enabled ? HTTRANSPARENT : HTNOWHERE},
+#else
+    {0, HTTRANSPARENT},
+#endif
+    {60, HTCLIENT},
+    {1000, HTNOWHERE},
   };
 
   for (const auto& test_case : kTestCases) {
diff --git a/ui/views/bubble/bubble_frame_view_unittest.cc b/ui/views/bubble/bubble_frame_view_unittest.cc
index 0966f76b6f2a9..5db8334da3ab3 100644
--- a/ui/views/bubble/bubble_frame_view_unittest.cc
+++ b/ui/views/bubble/bubble_frame_view_unittest.cc
@@ -214,7 +214,7 @@ TEST_F(BubbleFrameViewTest, GetUpdatedWindowBounds) {
   gfx::Rect window_bounds;
 
   frame.SetBubbleBorder(
-      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW));
+      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW_LEGACY));
 
   // Test that the info bubble displays normally when it fits.
   frame.SetArrow(BubbleBorder::TOP_LEFT);
@@ -376,7 +376,7 @@ TEST_F(BubbleFrameViewTest, TestMirroringForCenteredArrow) {
 TEST_F(BubbleFrameViewTest, GetUpdatedWindowBoundsDontTryMirror) {
   TestBubbleFrameView frame(this);
   frame.SetBubbleBorder(std::make_unique<BubbleBorder>(
-      BubbleBorder::TOP_RIGHT, BubbleBorder::NO_SHADOW));
+      BubbleBorder::TOP_RIGHT, BubbleBorder::NO_SHADOW_LEGACY));
   gfx::Rect window_bounds = frame.GetUpdatedWindowBounds(
       gfx::Rect(100, 900, 0, 0),       // |anchor_rect|
       BubbleBorder::Arrow::TOP_RIGHT,  // |delegate_arrow|
@@ -394,7 +394,7 @@ TEST_F(BubbleFrameViewTest, GetUpdatedWindowBoundsCenterArrows) {
   gfx::Rect window_bounds;
 
   frame.SetBubbleBorder(
-      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW));
+      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW_LEGACY));
 
   // Some of these tests may go away once --secondary-ui-md becomes the
   // default. Under Material Design mode, the BubbleBorder doesn't support all
@@ -458,7 +458,7 @@ TEST_F(BubbleFrameViewTest, GetUpdatedWindowBoundsForBubbleWithAnchorWindow) {
   gfx::Rect window_bounds;
 
   frame.SetBubbleBorder(
-      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW));
+      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW_LEGACY));
 
   // Test that the bubble displays normally when it fits.
   frame.SetArrow(BubbleBorder::TOP_LEFT);
@@ -576,7 +576,7 @@ TEST_F(BubbleFrameViewTest,
   gfx::Rect window_bounds;
 
   frame.SetBubbleBorder(
-      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW));
+      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW_LEGACY));
 
   // Test bubble fitting anchor window and not fitting screen on right.
   //     ________________________
@@ -648,7 +648,7 @@ TEST_F(BubbleFrameViewTest, MirroringNotStickyForGetUpdatedWindowBounds) {
   gfx::Rect window_bounds;
 
   frame.SetBubbleBorder(
-      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW));
+      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW_LEGACY));
 
   // Test bubble fitting anchor window and not fitting screen on right.
   frame.SetAvailableAnchorWindowBounds(gfx::Rect(700, 200, 400, 400));
@@ -685,7 +685,7 @@ TEST_F(BubbleFrameViewTest, GetUpdatedWindowBoundsForBubbleSetToOffset) {
   gfx::Rect window_bounds;
 
   frame.SetBubbleBorder(
-      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW));
+      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW_LEGACY));
 
   // Test that the bubble displays normally when it fits.
   frame.SetArrow(BubbleBorder::TOP_LEFT);
@@ -743,7 +743,7 @@ TEST_F(BubbleFrameViewTest,
   gfx::Rect window_bounds;
 
   frame.SetBubbleBorder(
-      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW));
+      std::make_unique<BubbleBorder>(kArrow, BubbleBorder::NO_SHADOW_LEGACY));
 
   // Test that the bubble exiting right side of anchor window displays against
   // left edge of anchor window bounds if larger than anchor window.
diff --git a/ui/views/corewm/cursor_height_provider_win.cc b/ui/views/corewm/cursor_height_provider_win.cc
new file mode 100644
index 0000000000000..aed9fdce181db
--- /dev/null
+++ b/ui/views/corewm/cursor_height_provider_win.cc
@@ -0,0 +1,178 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/corewm/cursor_height_provider_win.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include <windows.h>
+
+#include <algorithm>
+#include <map>
+#include <memory>
+
+#include "base/numerics/safe_conversions.h"
+#include "base/win/scoped_hdc.h"
+
+namespace {
+using PixelData = std::unique_ptr<uint32_t[]>;
+using HeightStorage = std::map<HCURSOR, int>;
+
+const uint32_t kBitsPeruint32 = sizeof(uint32_t) * 8;
+// All bits are 1 for transparent portion of monochromatic mask.
+constexpr uint32_t kTransparentMask = 0xffffffff;
+// This is height of default pointer arrow in Windows 7.
+constexpr int kDefaultHeight = 20;
+// Masks are monochromatic.
+constexpr size_t kNumberOfColors = 2;
+const size_t kHeaderAndPalette =
+    sizeof(BITMAPINFOHEADER) + kNumberOfColors * sizeof(RGBQUAD);
+
+HeightStorage* cached_heights = nullptr;
+
+// Extracts the pixel data of provided bitmap
+PixelData GetBitmapData(HBITMAP handle, const BITMAPINFO& info, HDC hdc) {
+  PixelData data;
+  // Masks are monochromatic.
+  DCHECK_EQ(info.bmiHeader.biBitCount, 1);
+  if (info.bmiHeader.biBitCount != 1)
+    return data;
+
+  // When getting pixel data palette is appended to memory pointed by
+  // BITMAPINFO passed so allocate additional memory to store additional data.
+  auto header = std::make_unique<char[]>(kHeaderAndPalette);
+  memcpy(header.get(), &(info.bmiHeader), sizeof(info.bmiHeader));
+
+  data = std::make_unique<uint32_t[]>(info.bmiHeader.biSizeImage /
+                                      sizeof(uint32_t));
+
+  int result = GetDIBits(
+      hdc, handle, 0, static_cast<UINT>(info.bmiHeader.biHeight), data.get(),
+      reinterpret_cast<BITMAPINFO*>(header.get()), DIB_RGB_COLORS);
+
+  if (result == 0)
+    data.reset();
+
+  return data;
+}
+
+// Checks if the specifed row is transparent in provided bitmap.
+bool IsRowTransparent(const PixelData& data,
+                      const uint32_t row_size,
+                      const uint32_t last_byte_mask,
+                      const uint32_t y) {
+  // Set the padding bits to 1 to make mask matching easier.
+  *(data.get() + (y + 1) * row_size - 1) |= last_byte_mask;
+  for (uint32_t i = y * row_size; i < (y + 1) * row_size; ++i) {
+    if (*(data.get() + i) != kTransparentMask)
+      return false;
+  }
+  return true;
+}
+
+// Gets the vertical offset between specified cursor's hotpoint and its bottom.
+//
+// Gets the cursor image data and extract cursor's visible height.
+// Based on that gets what should be the vertical offset between cursor's
+// hot point and the tooltip.
+int CalculateCursorHeight(HCURSOR cursor_handle) {
+  base::win::ScopedGetDC hdc(nullptr);
+
+  ICONINFO icon = {0};
+  GetIconInfo(cursor_handle, &icon);
+
+  BITMAPINFO bitmap_info = {};
+  bitmap_info.bmiHeader.biSize = sizeof(bitmap_info.bmiHeader);
+  if (GetDIBits(hdc, icon.hbmMask, 0, 0, nullptr, &bitmap_info,
+                DIB_RGB_COLORS) == 0)
+    return kDefaultHeight;
+
+  // Rows are padded to full DWORDs. OR with this mask will set them to 1
+  // to simplify matching with |transparent_mask|.
+  uint32_t last_byte_mask = 0xFFFFFFFF;
+  const auto width = static_cast<uint32_t>(bitmap_info.bmiHeader.biWidth);
+  const unsigned char bits_to_shift =
+      sizeof(last_byte_mask) * 8 - (width % kBitsPeruint32);
+  if (bits_to_shift != kBitsPeruint32)
+    last_byte_mask = (last_byte_mask << bits_to_shift);
+  else
+    last_byte_mask = 0;
+
+  const uint32_t row_size = (width + kBitsPeruint32 - 1) / kBitsPeruint32;
+  PixelData data(GetBitmapData(icon.hbmMask, bitmap_info, hdc));
+  if (data == nullptr)
+    return kDefaultHeight;
+
+  // There are 2 types of cursors: Ones that cover the area underneath
+  // completely (i.e. hand cursor) and ones that partially cover
+  // and partially blend with background (i. e. I-beam cursor).
+  // These will have either 1 square mask or 2 masks stacked on top
+  // of each other (xor mask and and mask).
+  const bool has_xor_mask =
+      bitmap_info.bmiHeader.biHeight == 2 * bitmap_info.bmiHeader.biWidth;
+  const auto height = static_cast<uint32_t>(bitmap_info.bmiHeader.biHeight);
+  const uint32_t cursor_height = has_xor_mask ? height / 2 : height;
+  uint32_t xor_offset;
+  if (has_xor_mask) {
+    for (xor_offset = 0; xor_offset < cursor_height; ++xor_offset) {
+      const uint32_t row_start = row_size * xor_offset;
+      const uint32_t row_boundary = row_start + row_size;
+      for (uint32_t i = row_start; i < row_boundary; ++i)
+        data.get()[i] = ~(data.get()[i]);
+      if (!IsRowTransparent(data, row_size, last_byte_mask, xor_offset)) {
+        break;
+      }
+    }
+  } else {
+    xor_offset = cursor_height;
+  }
+
+  uint32_t and_offset;
+
+  for (and_offset = has_xor_mask ? cursor_height : 0; and_offset < height;
+       ++and_offset) {
+    if (!IsRowTransparent(data, row_size, last_byte_mask, and_offset)) {
+      break;
+    }
+  }
+  if (has_xor_mask) {
+    and_offset -= cursor_height;
+  }
+  const uint32_t offset = std::min(xor_offset, and_offset);
+
+  DeleteObject(icon.hbmColor);
+  DeleteObject(icon.hbmMask);
+
+  // Apparently it's possible for the calculation here to underflow, and thus
+  // result in a negative value, maybe if the hotspot is below any visible
+  // portion of the cursor.  Not sure if this case should return 0 instead.
+  return static_cast<int>(cursor_height - offset - icon.yHotspot + 1);
+}
+
+}  // namespace
+
+namespace views {
+namespace corewm {
+
+int GetCurrentCursorVisibleHeight() {
+  CURSORINFO cursor = {0};
+  cursor.cbSize = sizeof(cursor);
+  GetCursorInfo(&cursor);
+
+  if (cached_heights == nullptr)
+    cached_heights = new HeightStorage;
+
+  HeightStorage::const_iterator cached_height =
+      cached_heights->find(cursor.hCursor);
+  if (cached_height != cached_heights->end())
+    return cached_height->second;
+
+  const int height = CalculateCursorHeight(cursor.hCursor);
+  (*cached_heights)[cursor.hCursor] = height;
+
+  return height;
+}
+
+}  // namespace corewm
+}  // namespace views
diff --git a/ui/views/corewm/cursor_height_provider_win.h b/ui/views/corewm/cursor_height_provider_win.h
new file mode 100644
index 0000000000000..ce0bf65a96948
--- /dev/null
+++ b/ui/views/corewm/cursor_height_provider_win.h
@@ -0,0 +1,21 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
+#define UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
+
+namespace views {
+namespace corewm {
+
+// Gets the visible height of current cursor.
+//
+// The height is offset between cursor's hot point and it's
+// bottom edge, derived from first non-transparent row of cursor's mask.
+
+int GetCurrentCursorVisibleHeight();
+
+}  // namespace corewm
+}  // namespace views
+
+#endif  // UI_VIEWS_COREWM_CURSOR_HEIGHT_PROVIDER_WIN_H_
diff --git a/ui/views/corewm/tooltip_win.cc b/ui/views/corewm/tooltip_win.cc
new file mode 100644
index 0000000000000..fa6e9c769e407
--- /dev/null
+++ b/ui/views/corewm/tooltip_win.cc
@@ -0,0 +1,186 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/views/corewm/tooltip_win.h"
+
+#include "base/i18n/rtl.h"
+#include "base/logging.h"
+#include "base/strings/string_util_win.h"
+#include "base/win/windowsx_shim.h"
+#include "ui/aura/window.h"
+#include "ui/base/l10n/l10n_util_win.h"
+#include "ui/display/display.h"
+#include "ui/display/screen.h"
+#include "ui/display/win/screen_win.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/system_fonts_win.h"
+#include "ui/views/corewm/cursor_height_provider_win.h"
+
+namespace views::corewm {
+
+TooltipWin::TooltipWin(HWND parent)
+    : parent_hwnd_(parent), tooltip_hwnd_(nullptr), showing_(false) {
+  memset(&toolinfo_, 0, sizeof(toolinfo_));
+  toolinfo_.cbSize = sizeof(toolinfo_);
+  toolinfo_.uFlags = TTF_IDISHWND | TTF_TRACK | TTF_ABSOLUTE;
+  toolinfo_.uId = reinterpret_cast<UINT_PTR>(parent_hwnd_);
+  toolinfo_.hwnd = parent_hwnd_;
+  toolinfo_.lpszText = nullptr;
+  toolinfo_.lpReserved = nullptr;
+  SetRectEmpty(&toolinfo_.rect);
+}
+
+TooltipWin::~TooltipWin() {
+  if (tooltip_hwnd_)
+    DestroyWindow(tooltip_hwnd_);
+}
+
+bool TooltipWin::HandleNotify(int w_param, NMHDR* l_param, LRESULT* l_result) {
+  if (tooltip_hwnd_ == nullptr)
+    return false;
+
+  switch (l_param->code) {
+    case TTN_POP:
+      showing_ = false;
+      return true;
+    case TTN_SHOW:
+      *l_result = TRUE;
+      PositionTooltip();
+      showing_ = true;
+      return true;
+    default:
+      break;
+  }
+  return false;
+}
+
+bool TooltipWin::EnsureTooltipWindow() {
+  if (tooltip_hwnd_)
+    return true;
+
+  tooltip_hwnd_ =
+      CreateWindowEx(WS_EX_TRANSPARENT | l10n_util::GetExtendedTooltipStyles(),
+                     TOOLTIPS_CLASS, nullptr, TTS_NOPREFIX | WS_POPUP, 0, 0, 0,
+                     0, parent_hwnd_, nullptr, nullptr, nullptr);
+  if (!tooltip_hwnd_) {
+    PLOG(WARNING) << "tooltip creation failed, disabling tooltips";
+    return false;
+  }
+
+  MaybeOverrideFont();
+
+  SendMessage(tooltip_hwnd_, TTM_ADDTOOL, 0,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+  return true;
+}
+
+void TooltipWin::PositionTooltip() {
+  gfx::Point screen_point =
+      display::win::ScreenWin::DIPToScreenPoint(anchor_point_);
+  const int cursoroffset = GetCurrentCursorVisibleHeight();
+  screen_point.Offset(0, cursoroffset);
+
+  LRESULT tooltip_size = SendMessage(tooltip_hwnd_, TTM_GETBUBBLESIZE, 0,
+                                     reinterpret_cast<LPARAM>(&toolinfo_));
+  const gfx::Size size(LOWORD(tooltip_size), HIWORD(tooltip_size));
+
+  const display::Display display(
+      display::Screen::GetScreen()->GetDisplayNearestPoint(anchor_point_));
+
+  gfx::Rect tooltip_bounds(screen_point, size);
+  // Align the center of the tooltip with the position when the tooltip is not
+  // following the cursor.
+  if (trigger_ == TooltipTrigger::kKeyboard)
+    tooltip_bounds.Offset(-size.width() / 2, 0);
+  else if (base::i18n::IsRTL())
+    tooltip_bounds.Offset(-size.width(), 0);
+  tooltip_bounds.AdjustToFit(display::win::ScreenWin::DIPToScreenRect(
+      parent_hwnd_, display.work_area()));
+  SetWindowPos(tooltip_hwnd_, nullptr, tooltip_bounds.x(), tooltip_bounds.y(),
+               0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
+
+  MaybeOverrideFont();
+}
+
+void TooltipWin::MaybeOverrideFont() {
+  gfx::win::FontAdjustment font_adjustment;
+  const HFONT old_font = GetWindowFont(tooltip_hwnd_);
+
+  // Determine if we need to override the font.
+  if ((!override_font_.get() || override_font_.get() != old_font) &&
+      l10n_util::NeedOverrideDefaultUIFont(
+          &font_adjustment.font_family_override, &font_adjustment.font_scale)) {
+    // Determine if we need to regenerate the font.
+    // There are a number of situations under which Windows can replace the
+    // font in a tooltip, but we don't actually need to regenerate our override
+    // font unless the underlying text/DPI scale of the window has changed.
+    const float current_scale =
+        display::win::ScreenWin::GetScaleFactorForHWND(tooltip_hwnd_);
+    if (!override_font_.get() || current_scale != override_scale_) {
+      override_font_.reset(
+          gfx::win::AdjustExistingSystemFont(old_font, font_adjustment));
+      override_scale_ = current_scale;
+    }
+
+    // Override the font in the tooltip.
+    SetWindowFont(tooltip_hwnd_, override_font_.get(), FALSE);
+  }
+}
+
+int TooltipWin::GetMaxWidth(const gfx::Point& location) const {
+  const gfx::Point screen_point =
+      display::win::ScreenWin::DIPToScreenPoint(location);
+  display::Display display(
+      display::Screen::GetScreen()->GetDisplayNearestPoint(screen_point));
+  const gfx::Rect monitor_bounds = display.bounds();
+  return (monitor_bounds.width() + 1) / 2;
+}
+
+void TooltipWin::Update(aura::Window* window,
+                        const std::u16string& tooltip_text,
+                        const gfx::Point& position,
+                        const TooltipTrigger trigger) {
+  if (!EnsureTooltipWindow())
+    return;
+
+  // See comment in header for details on why `anchor_point_` and `trigger_` are
+  // needed here.
+  anchor_point_ = position + window->GetBoundsInScreen().OffsetFromOrigin();
+  trigger_ = trigger;
+
+  std::u16string adjusted_text(tooltip_text);
+  base::i18n::AdjustStringForLocaleDirection(&adjusted_text);
+  toolinfo_.lpszText = base::as_writable_wcstr(adjusted_text);
+  SendMessage(tooltip_hwnd_, TTM_SETTOOLINFO, 0,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+
+  int max_width = GetMaxWidth(anchor_point_);
+  SendMessage(tooltip_hwnd_, TTM_SETMAXTIPWIDTH, 0, max_width);
+}
+
+void TooltipWin::Show() {
+  if (!EnsureTooltipWindow())
+    return;
+
+  SendMessage(tooltip_hwnd_, TTM_TRACKACTIVATE, TRUE,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+
+  // Bring the window to the front.
+  SetWindowPos(tooltip_hwnd_, HWND_TOPMOST, 0, 0, 0, 0,
+               SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSIZE);
+}
+
+void TooltipWin::Hide() {
+  if (!tooltip_hwnd_)
+    return;
+
+  SendMessage(tooltip_hwnd_, TTM_TRACKACTIVATE, FALSE,
+              reinterpret_cast<LPARAM>(&toolinfo_));
+}
+
+bool TooltipWin::IsVisible() {
+  return showing_;
+}
+
+}  // namespace views::corewm
diff --git a/ui/views/corewm/tooltip_win.h b/ui/views/corewm/tooltip_win.h
new file mode 100644
index 0000000000000..8f131b8d1bf86
--- /dev/null
+++ b/ui/views/corewm/tooltip_win.h
@@ -0,0 +1,92 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_VIEWS_COREWM_TOOLTIP_WIN_H_
+#define UI_VIEWS_COREWM_TOOLTIP_WIN_H_
+
+#include <windows.h>  // Must come before other Windows system headers.
+
+#include <commctrl.h>
+
+#include <string>
+
+#include "base/win/scoped_gdi_object.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/views/corewm/tooltip.h"
+
+namespace wm {
+class TooltipObserver;
+}
+
+namespace views::corewm {
+
+// Implementation of Tooltip that uses the native win32 control for showing the
+// tooltip.
+class VIEWS_EXPORT TooltipWin : public Tooltip {
+ public:
+  explicit TooltipWin(HWND parent);
+
+  TooltipWin(const TooltipWin&) = delete;
+  TooltipWin& operator=(const TooltipWin&) = delete;
+
+  ~TooltipWin() override;
+
+  void AddObserver(wm::TooltipObserver* observer) override {}
+  void RemoveObserver(wm::TooltipObserver* observer) override {}
+
+  // HandleNotify() is forwarded from DesktopWindowTreeHostWin to keep the
+  // native tooltip in sync.
+  bool HandleNotify(int w_param, NMHDR* l_param, LRESULT* l_result);
+
+ private:
+  // Ensures |tooltip_hwnd_| is valid. Returns true if valid, false if there
+  // a problem creating |tooltip_hwnd_|.
+  bool EnsureTooltipWindow();
+
+  // Sets the position of the tooltip.
+  void PositionTooltip();
+
+  // Might override the font size for localization (e.g. Hindi).
+  void MaybeOverrideFont();
+
+  // Tooltip:
+  int GetMaxWidth(const gfx::Point& location) const override;
+  void Update(aura::Window* window,
+              const std::u16string& tooltip_text,
+              const gfx::Point& position,
+              const TooltipTrigger trigger) override;
+  void Show() override;
+  void Hide() override;
+  bool IsVisible() override;
+
+  // Font we're currently overriding our UI font with.
+  // Should outlast |tooltip_hwnd_|.
+  base::win::ScopedHFONT override_font_;
+
+  // The window |tooltip_hwnd_| is parented to.
+  HWND parent_hwnd_;
+
+  // Shows the tooltip.
+  HWND tooltip_hwnd_;
+
+  // Used to modify the tooltip.
+  TOOLINFO toolinfo_;
+
+  // Is the tooltip showing?
+  bool showing_;
+
+  // In order to position the tooltip we need to know the size. The size is only
+  // available from TTN_SHOW, so we have to cache `anchor_point_` and `trigger_`
+  // which are required to calculate its position.
+  gfx::Point anchor_point_;
+  TooltipTrigger trigger_ = TooltipTrigger::kCursor;
+
+  // What the scale was the last time we overrode the font, to see if we can
+  // re-use our previous override.
+  float override_scale_ = 0.0f;
+};
+
+}  // namespace views::corewm
+
+#endif  // UI_VIEWS_COREWM_TOOLTIP_WIN_H_
diff --git a/ui/views/examples/bubble_example.cc b/ui/views/examples/bubble_example.cc
index d03e0bbdc9f5f..3fa359f08a6ec 100644
--- a/ui/views/examples/bubble_example.cc
+++ b/ui/views/examples/bubble_example.cc
@@ -98,6 +98,11 @@ void BubbleExample::CreateExampleView(View* container) {
   container->SetLayoutManager(std::make_unique<BoxLayout>(
       BoxLayout::Orientation::kHorizontal, gfx::Insets(), 10));
 
+  no_shadow_legacy_ = container->AddChildView(std::make_unique<LabelButton>(
+      base::BindRepeating(&BubbleExample::ShowBubble, base::Unretained(this),
+                          &no_shadow_legacy_, BubbleBorder::NO_SHADOW_LEGACY,
+                          false),
+      u"No Shadow Legacy"));
   standard_shadow_ = container->AddChildView(std::make_unique<LabelButton>(
       base::BindRepeating(&BubbleExample::ShowBubble, base::Unretained(this),
                           &standard_shadow_, BubbleBorder::STANDARD_SHADOW,
@@ -109,7 +114,7 @@ void BubbleExample::CreateExampleView(View* container) {
       u"No Shadow"));
   persistent_ = container->AddChildView(std::make_unique<LabelButton>(
       base::BindRepeating(&BubbleExample::ShowBubble, base::Unretained(this),
-                          &persistent_, BubbleBorder::NO_SHADOW, true),
+                          &persistent_, BubbleBorder::NO_SHADOW_LEGACY, true),
       u"Persistent"));
 }
 
diff --git a/ui/views/examples/bubble_example.h b/ui/views/examples/bubble_example.h
index 274a7bec469b4..1d6c6ac84ba89 100644
--- a/ui/views/examples/bubble_example.h
+++ b/ui/views/examples/bubble_example.h
@@ -35,6 +35,7 @@ class VIEWS_EXAMPLES_EXPORT BubbleExample : public ExampleBase {
                   bool persistent,
                   const ui::Event& event);
 
+  Button* no_shadow_legacy_;
   Button* standard_shadow_;
   Button* no_shadow_;
   Button* persistent_;
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
index 0be1688818063..6cd8df67b5b72 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
@@ -16,6 +16,7 @@
 #include "base/ranges/algorithm.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "third_party/skia/include/core/SkPath.h"
 #include "third_party/skia/include/core/SkRegion.h"
 #include "ui/aura/client/aura_constants.h"
@@ -28,6 +29,7 @@
 #include "ui/base/ime/input_method.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/event_creation_utils.h"
+#include "ui/base/win/shell.h"
 #include "ui/base/win/win_cursor.h"
 #include "ui/compositor/compositor.h"
 #include "ui/compositor/layer.h"
@@ -43,6 +45,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/path_win.h"
 #include "ui/views/corewm/tooltip_aura.h"
+#include "ui/views/corewm/tooltip_win.h"
 #include "ui/views/views_features.h"
 #include "ui/views/views_switches.h"
 #include "ui/views/widget/desktop_aura/desktop_drag_drop_client_win.h"
@@ -75,9 +78,8 @@ namespace {
 const int kMouseCaptureRegionBorder = 5;
 
 gfx::Size GetExpandedWindowSize(bool is_translucent, gfx::Size size) {
-  if (!is_translucent) {
+  if (!is_translucent || !ui::win::IsAeroGlassEnabled())
     return size;
-  }
 
   // Some AMD drivers can't display windows that are less than 64x64 pixels,
   // so expand them to be at least that size. http://crbug.com/286609
@@ -133,7 +135,8 @@ DesktopWindowTreeHostWin::DesktopWindowTreeHostWin(
       drag_drop_client_(nullptr),
       should_animate_window_close_(false),
       pending_close_(false),
-      has_non_client_view_(false) {}
+      has_non_client_view_(false),
+      tooltip_(nullptr) {}
 
 DesktopWindowTreeHostWin::~DesktopWindowTreeHostWin() {
   desktop_native_widget_aura_->OnDesktopWindowTreeHostDestroyed(this);
@@ -225,7 +228,14 @@ void DesktopWindowTreeHostWin::OnActiveWindowChanged(bool active) {}
 void DesktopWindowTreeHostWin::OnWidgetInitDone() {}
 
 std::unique_ptr<corewm::Tooltip> DesktopWindowTreeHostWin::CreateTooltip() {
-  return std::make_unique<corewm::TooltipAura>();
+  bool force_legacy_tooltips =
+      (base::win::GetVersion() < base::win::Version::WIN8);
+  if (!force_legacy_tooltips)
+    return std::make_unique<corewm::TooltipAura>();
+
+  DCHECK(!tooltip_);
+  tooltip_ = new corewm::TooltipWin(GetAcceleratedWidget());
+  return base::WrapUnique(tooltip_.get());
 }
 
 std::unique_ptr<aura::client::DragDropClient>
@@ -587,7 +597,7 @@ bool DesktopWindowTreeHostWin::IsAnimatingClosed() const {
 }
 
 bool DesktopWindowTreeHostWin::IsTranslucentWindowOpacitySupported() const {
-  return true;
+  return ui::win::IsAeroGlassEnabled();
 }
 
 void DesktopWindowTreeHostWin::SizeConstraintsChanged() {
@@ -1146,6 +1156,12 @@ void DesktopWindowTreeHostWin::HandlePaintAccelerated(
     compositor()->ScheduleRedrawRect(invalid_rect);
 }
 
+bool DesktopWindowTreeHostWin::HandleTooltipNotify(int w_param,
+                                                   NMHDR* l_param,
+                                                   LRESULT* l_result) {
+  return tooltip_ && tooltip_->HandleNotify(w_param, l_param, l_result);
+}
+
 void DesktopWindowTreeHostWin::HandleMenuLoop(bool in_menu_loop) {
   if (in_menu_loop) {
     tooltip_disabler_ = std::make_unique<wm::ScopedTooltipDisabler>(window());
diff --git a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
index b23ba1bf3a49f..58c13ba424645 100644
--- a/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
+++ b/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
@@ -38,6 +38,10 @@ class DesktopDragDropClientWin;
 class HWNDMessageHandler;
 class NonClientFrameView;
 
+namespace corewm {
+class TooltipWin;
+}
+
 namespace test {
 class DesktopWindowTreeHostWinTestApi;
 }
@@ -247,6 +251,9 @@ class VIEWS_EXPORT DesktopWindowTreeHostWin
   void HandleInputLanguageChange(DWORD character_set,
                                  HKL input_language_id) override;
   void HandlePaintAccelerated(const gfx::Rect& invalid_rect) override;
+  bool HandleTooltipNotify(int w_param,
+                           NMHDR* l_param,
+                           LRESULT* l_result) override;
   void HandleMenuLoop(bool in_menu_loop) override;
   bool PreHandleMSG(UINT message,
                     WPARAM w_param,
@@ -319,6 +326,10 @@ class VIEWS_EXPORT DesktopWindowTreeHostWin
   // True if the window should have the frame removed.
   bool remove_standard_frame_;
 
+  // Owned by TooltipController, but we need to forward events to it so we keep
+  // a reference.
+  raw_ptr<corewm::TooltipWin> tooltip_;
+
   // Visibility of the cursor. On Windows we can have multiple root windows and
   // the implementation of ::ShowCursor() is based on a counter, so making this
   // member static ensures that ::ShowCursor() is always called exactly once
diff --git a/ui/views/widget/widget_hwnd_utils.cc b/ui/views/widget/widget_hwnd_utils.cc
index b162f426dbceb..d24c447bb8030 100644
--- a/ui/views/widget/widget_hwnd_utils.cc
+++ b/ui/views/widget/widget_hwnd_utils.cc
@@ -14,6 +14,10 @@
 #include "ui/views/widget/widget_delegate.h"
 #include "ui/views/win/hwnd_message_handler.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
+#endif
+
 namespace views {
 
 namespace {
@@ -103,7 +107,12 @@ void CalculateWindowStylesFromInitParams(
     case Widget::InitParams::TYPE_MENU:
       *style |= WS_POPUP;
       if (params.remove_standard_frame) {
-        *style |= WS_THICKFRAME;
+        // If the platform doesn't support drop shadow, decorate the Window
+        // with just a border.
+        if (ui::win::IsAeroGlassEnabled())
+          *style |= WS_THICKFRAME;
+        else
+          *style |= WS_BORDER;
       }
       if (!params.force_show_in_taskbar)
         *ex_style |= WS_EX_TOOLWINDOW;
@@ -154,9 +163,11 @@ void ConfigureWindowStyles(
   //    not have not have WM_SIZEBOX, WS_THICKFRAME or WS_CAPTION in its
   //    style.
   //
+  // This doesn't work when Aero is disabled, so disable it in that case.
   // Software composited windows can continue to use WS_EX_LAYERED.
   bool is_translucent =
-      (params.opacity == Widget::InitParams::WindowOpacity::kTranslucent);
+      (params.opacity == Widget::InitParams::WindowOpacity::kTranslucent &&
+       (ui::win::IsAeroGlassEnabled() || params.force_software_compositing));
 
   CalculateWindowStylesFromInitParams(params, widget_delegate,
                                       native_widget_delegate, is_translucent,
diff --git a/ui/views/widget/widget_interactive_uitest.cc b/ui/views/widget/widget_interactive_uitest.cc
index ebf4e377240d4..e46ae2d0838b3 100644
--- a/ui/views/widget/widget_interactive_uitest.cc
+++ b/ui/views/widget/widget_interactive_uitest.cc
@@ -18,6 +18,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/time/time.h"
 #include "base/timer/timer.h"
+#include "base/win/windows_version.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "ui/base/ime/input_method.h"
@@ -463,6 +464,11 @@ class TouchEventHandler : public ui::EventHandler {
 
 // TODO(dtapuska): Disabled due to it being flaky crbug.com/817531
 TEST_F(DesktopWidgetTestInteractive, DISABLED_TouchNoActivateWindow) {
+  // ui_controls::SendTouchEvents which uses InjectTouchInput API only works
+  // on Windows 8 and up.
+  if (base::win::GetVersion() <= base::win::Version::WIN7)
+    return;
+
   View* focusable_view = new View;
   focusable_view->SetFocusBehavior(View::FocusBehavior::ALWAYS);
   WidgetAutoclosePtr widget(CreateTopLevelNativeWidget());
diff --git a/ui/views/win/fullscreen_handler.cc b/ui/views/win/fullscreen_handler.cc
index bf14eb24f08b1..4a2d4d0c5c541 100644
--- a/ui/views/win/fullscreen_handler.cc
+++ b/ui/views/win/fullscreen_handler.cc
@@ -7,6 +7,7 @@
 #include <memory>
 
 #include "base/win/win_util.h"
+#include "ui/base/win/shell.h"
 #include "ui/display/types/display_constants.h"
 #include "ui/display/win/screen_win.h"
 #include "ui/display/win/screen_win_display.h"
@@ -61,6 +62,12 @@ void FullscreenHandler::ProcessFullscreen(bool fullscreen,
                                           int64_t target_display_id) {
   std::unique_ptr<ScopedFullscreenVisibility> visibility;
 
+  // With Aero enabled disabling the visibility causes the window to disappear
+  // for several frames, which looks worse than doing other updates
+  // non-atomically.
+  if (!ui::win::IsAeroGlassEnabled())
+    visibility = std::make_unique<ScopedFullscreenVisibility>(hwnd_);
+
   // Save current window state if not already fullscreen.
   if (!fullscreen_) {
     saved_window_info_.style = GetWindowLong(hwnd_, GWL_STYLE);
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index 22bb24f2afcef..f6772899b5913 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -29,6 +29,7 @@
 #include "base/win/dark_mode_support.h"
 #include "base/win/scoped_gdi_object.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "services/tracing/public/cpp/perfetto/macros.h"
 #include "third_party/perfetto/protos/perfetto/trace/track_event/chrome_window_handle_event_info.pbzero.h"
 #include "third_party/skia/include/core/SkPath.h"
@@ -45,6 +46,7 @@
 #include "ui/base/win/lock_state.h"
 #include "ui/base/win/mouse_wheel_util.h"
 #include "ui/base/win/session_change_observer.h"
+#include "ui/base/win/shell.h"
 #include "ui/base/win/touch_input.h"
 #include "ui/base/win/win_cursor.h"
 #include "ui/display/types/display_constants.h"
@@ -231,6 +233,13 @@ void EnableMenuItemByCommand(HMENU menu, UINT command, bool enabled) {
   EnableMenuItem(menu, command, flags);
 }
 
+// Callback used to notify child windows that the top level window received a
+// DWMCompositionChanged message.
+BOOL CALLBACK SendDwmCompositionChanged(HWND window, LPARAM param) {
+  SendMessage(window, WM_DWMCOMPOSITIONCHANGED, 0, 0);
+  return TRUE;
+}
+
 // The thickness of an auto-hide taskbar in pixels.
 constexpr int kAutoHideTaskbarThicknessPx = 2;
 
@@ -361,7 +370,8 @@ class HWNDMessageHandler::ScopedRedrawLock {
         cancel_unlock_(false),
         should_lock_(owner_->IsVisible() && !owner->HasChildRenderingWindow() &&
                      ::IsWindow(hwnd_) && !owner_->IsHeadless() &&
-                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION))) {
+                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION) ||
+                      !ui::win::IsAeroGlassEnabled())) {
     if (should_lock_)
       owner_->LockUpdates();
   }
@@ -422,6 +432,7 @@ HWNDMessageHandler::HWNDMessageHandler(HWNDMessageHandlerDelegate* delegate,
       touch_down_contexts_(0),
       last_mouse_hwheel_time_(0),
       dwm_transition_desired_(false),
+      dwm_composition_enabled_(ui::win::IsDwmCompositionEnabled()),
       sent_window_size_changing_(false),
       did_return_uia_object_(false),
       left_button_down_on_caption_(false),
@@ -623,7 +634,8 @@ void HWNDMessageHandler::SetBounds(const gfx::Rect& bounds_in_pixels,
 }
 
 void HWNDMessageHandler::SetDwmFrameExtension(DwmFrameState state) {
-  if (!delegate_->HasFrame() && !is_translucent_) {
+  if (!delegate_->HasFrame() && ui::win::IsAeroGlassEnabled() &&
+      !is_translucent_) {
     MARGINS m = {0, 0, 0, 0};
     if (state == DwmFrameState::kOn && !IsMaximized())
       m = {0, 0, 1, 0};
@@ -1794,6 +1806,29 @@ void HWNDMessageHandler::OnDisplayChange(UINT bits_per_pixel,
   SendFrameChanged();
 }
 
+LRESULT HWNDMessageHandler::OnDwmCompositionChanged(UINT msg,
+                                                    WPARAM /* w_param */,
+                                                    LPARAM /* l_param */) {
+  TRACE_EVENT0("ui", "HWNDMessageHandler::OnDwmCompositionChanged");
+
+  if (!delegate_->HasNonClientView()) {
+    SetMsgHandled(FALSE);
+    return 0;
+  }
+
+  bool dwm_composition_enabled = ui::win::IsDwmCompositionEnabled();
+  if (dwm_composition_enabled_ != dwm_composition_enabled) {
+    // Do not cause the Window to be hidden and shown unless there was
+    // an actual change in the theme. This filter is necessary because
+    // Windows sends redundant WM_DWMCOMPOSITIONCHANGED messages when
+    // a laptop is reopened, and our theme change code causes wonky
+    // focus issues. See http://crbug.com/895855 for more information.
+    dwm_composition_enabled_ = dwm_composition_enabled;
+    FrameTypeChanged();
+  }
+  return 0;
+}
+
 LRESULT HWNDMessageHandler::OnDpiChanged(UINT msg,
                                          WPARAM w_param,
                                          LPARAM l_param) {
@@ -1852,7 +1887,8 @@ void HWNDMessageHandler::OnEnterSizeMove() {
 
 LRESULT HWNDMessageHandler::OnEraseBkgnd(HDC dc) {
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
+  if (ui::win::IsAeroGlassEnabled() &&
+      delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
       needs_dwm_frame_clear_) {
     // This is necessary to avoid white flashing in the titlebar area around the
     // minimize/maximize/close buttons.
@@ -2091,6 +2127,12 @@ LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
 LRESULT HWNDMessageHandler::OnPointerEvent(UINT message,
                                            WPARAM w_param,
                                            LPARAM l_param) {
+  // WM_POINTER is not supported on Windows 7.
+  if (base::win::GetVersion() == base::win::Version::WIN7) {
+    SetMsgHandled(FALSE);
+    return -1;
+  }
+
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   POINTER_INPUT_TYPE pointer_type;
@@ -2423,28 +2465,30 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
   // It's required to avoid some native painting artifacts from appearing when
   // the window is resized.
   if (!delegate_->HasNonClientView() || IsFrameSystemDrawn()) {
-    // The default WM_NCPAINT handler under Aero Glass doesn't clear the
-    // nonclient area, so it'll remain the default white color. That area is
-    // invisible initially (covered by the window border) but can become
-    // temporarily visible on maximizing or fullscreening, so clear it here.
-    HDC dc = GetWindowDC(hwnd());
-    RECT client_rect;
-    ::GetClientRect(hwnd(), &client_rect);
-    ::MapWindowPoints(hwnd(), nullptr, reinterpret_cast<POINT*>(&client_rect),
-                      2);
-    ::OffsetRect(&client_rect, -window_rect.left, -window_rect.top);
-    // client_rect now is in window space.
-
-    base::win::ScopedRegion base(::CreateRectRgnIndirect(&dirty_region));
-    base::win::ScopedRegion client(::CreateRectRgnIndirect(&client_rect));
-    base::win::ScopedRegion nonclient(::CreateRectRgn(0, 0, 0, 0));
-    ::CombineRgn(nonclient.get(), base.get(), client.get(), RGN_DIFF);
-
-    ::SelectClipRgn(dc, nonclient.get());
-    HBRUSH brush = CreateSolidBrush(0);
-    ::FillRect(dc, &dirty_region, brush);
-    ::DeleteObject(brush);
-    ::ReleaseDC(hwnd(), dc);
+    if (ui::win::IsAeroGlassEnabled()) {
+      // The default WM_NCPAINT handler under Aero Glass doesn't clear the
+      // nonclient area, so it'll remain the default white color. That area is
+      // invisible initially (covered by the window border) but can become
+      // temporarily visible on maximizing or fullscreening, so clear it here.
+      HDC dc = GetWindowDC(hwnd());
+      RECT client_rect;
+      ::GetClientRect(hwnd(), &client_rect);
+      ::MapWindowPoints(hwnd(), nullptr, reinterpret_cast<POINT*>(&client_rect),
+                        2);
+      ::OffsetRect(&client_rect, -window_rect.left, -window_rect.top);
+      // client_rect now is in window space.
+
+      base::win::ScopedRegion base(::CreateRectRgnIndirect(&dirty_region));
+      base::win::ScopedRegion client(::CreateRectRgnIndirect(&client_rect));
+      base::win::ScopedRegion nonclient(::CreateRectRgn(0, 0, 0, 0));
+      ::CombineRgn(nonclient.get(), base.get(), client.get(), RGN_DIFF);
+
+      ::SelectClipRgn(dc, nonclient.get());
+      HBRUSH brush = CreateSolidBrush(0);
+      ::FillRect(dc, &dirty_region, brush);
+      ::DeleteObject(brush);
+      ::ReleaseDC(hwnd(), dc);
+    }
     SetMsgHandled(FALSE);
     return;
   }
@@ -2485,6 +2529,12 @@ LRESULT HWNDMessageHandler::OnNCUAHDrawFrame(UINT message,
   return 0;
 }
 
+LRESULT HWNDMessageHandler::OnNotify(int w_param, NMHDR* l_param) {
+  LRESULT l_result = 0;
+  SetMsgHandled(delegate_->HandleTooltipNotify(w_param, l_param, &l_result));
+  return l_result;
+}
+
 void HWNDMessageHandler::OnPaint(HDC dc) {
   // Call BeginPaint()/EndPaint() around the paint handling, as that seems
   // to do more to actually validate the window's drawing region. This only
@@ -2784,6 +2834,18 @@ LRESULT HWNDMessageHandler::OnTouchEvent(UINT message,
       POINT point;
       point.x = TOUCH_COORD_TO_PIXEL(input[i].x);
       point.y = TOUCH_COORD_TO_PIXEL(input[i].y);
+
+      if (base::win::GetVersion() == base::win::Version::WIN7) {
+        // Windows 7 sends touch events for touches in the non-client area,
+        // whereas Windows 8 does not. In order to unify the behaviour, always
+        // ignore touch events in the non-client area.
+        LPARAM l_param_ht = MAKELPARAM(point.x, point.y);
+        LRESULT hittest = SendMessage(hwnd(), WM_NCHITTEST, 0, l_param_ht);
+
+        if (hittest != HTCLIENT)
+          return 0;
+      }
+
       ScreenToClient(hwnd(), &point);
 
       last_touch_or_pen_message_time_ = ::GetMessageTime();
@@ -3475,13 +3537,18 @@ void HWNDMessageHandler::PerformDwmTransition() {
     SetWindowPos(hwnd(), nullptr, 0, 0, 0, 0, flags | SWP_HIDEWINDOW);
     SetWindowPos(hwnd(), nullptr, 0, 0, 0, 0, flags | SWP_SHOWWINDOW);
   }
+  // WM_DWMCOMPOSITIONCHANGED is only sent to top level windows, however we want
+  // to notify our children too, since we can have MDI child windows who need to
+  // update their appearance.
+  EnumChildWindows(hwnd(), &SendDwmCompositionChanged, NULL);
 }
 
 void HWNDMessageHandler::UpdateDwmFrame() {
   TRACE_EVENT0("ui", "HWNDMessageHandler::UpdateDwmFrame");
 
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets)) {
+  if (ui::win::IsAeroGlassEnabled() &&
+      delegate_->GetDwmFrameInsetsInPixels(&insets)) {
     MARGINS margins = {insets.left(), insets.right(), insets.top(),
                        insets.bottom()};
     DwmExtendFrameIntoClientArea(hwnd(), &margins);
diff --git a/ui/views/win/hwnd_message_handler.h b/ui/views/win/hwnd_message_handler.h
index 7d2cf25ace022..5972a9f7ac03a 100644
--- a/ui/views/win/hwnd_message_handler.h
+++ b/ui/views/win/hwnd_message_handler.h
@@ -368,6 +368,9 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
     CR_MESSAGE_HANDLER_EX(WM_NCUAHDRAWCAPTION, OnNCUAHDrawCaption)
     CR_MESSAGE_HANDLER_EX(WM_NCUAHDRAWFRAME, OnNCUAHDrawFrame)
 
+    // Vista and newer
+    CR_MESSAGE_HANDLER_EX(WM_DWMCOMPOSITIONCHANGED, OnDwmCompositionChanged)
+
     // Win 8.1 and newer
     CR_MESSAGE_HANDLER_EX(WM_DPICHANGED, OnDpiChanged)
 
@@ -447,6 +450,7 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
     CR_MSG_WM_NCCREATE(OnNCCreate)
     CR_MSG_WM_NCHITTEST(OnNCHitTest)
     CR_MSG_WM_NCPAINT(OnNCPaint)
+    CR_MSG_WM_NOTIFY(OnNotify)
     CR_MSG_WM_PAINT(OnPaint)
     CR_MSG_WM_SETFOCUS(OnSetFocus)
     CR_MSG_WM_SETICON(OnSetIcon)
@@ -477,6 +481,7 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
   void OnDestroy();
   void OnDisplayChange(UINT bits_per_pixel, const gfx::Size& screen_size);
   LRESULT OnDpiChanged(UINT msg, WPARAM w_param, LPARAM l_param);
+  LRESULT OnDwmCompositionChanged(UINT msg, WPARAM w_param, LPARAM l_param);
   void OnEnterMenuLoop(BOOL from_track_popup_menu);
   void OnEnterSizeMove();
   LRESULT OnEraseBkgnd(HDC dc);
@@ -503,6 +508,7 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
   void OnNCPaint(HRGN rgn);
   LRESULT OnNCUAHDrawCaption(UINT message, WPARAM w_param, LPARAM l_param);
   LRESULT OnNCUAHDrawFrame(UINT message, WPARAM w_param, LPARAM l_param);
+  LRESULT OnNotify(int w_param, NMHDR* l_param);
   void OnPaint(HDC dc);
   LRESULT OnReflectedMessage(UINT message, WPARAM w_param, LPARAM l_param);
   LRESULT OnScrollMessage(UINT message, WPARAM w_param, LPARAM l_param);
@@ -739,6 +745,11 @@ class VIEWS_EXPORT HWNDMessageHandler : public gfx::WindowImpl,
   // glass. Defaults to false.
   bool dwm_transition_desired_;
 
+  // Is DWM composition currently enabled?
+  // Note: According to MSDN docs for DwmIsCompositionEnabled(), this is always
+  // true starting in Windows 8.
+  bool dwm_composition_enabled_;
+
   // True if HandleWindowSizeChanging has been called in the delegate, but not
   // HandleClientSizeChanged.
   bool sent_window_size_changing_;
diff --git a/ui/views/win/hwnd_message_handler_delegate.h b/ui/views/win/hwnd_message_handler_delegate.h
index da6afe2ae8940..08e46c7b92f6c 100644
--- a/ui/views/win/hwnd_message_handler_delegate.h
+++ b/ui/views/win/hwnd_message_handler_delegate.h
@@ -215,6 +215,11 @@ class VIEWS_EXPORT HWNDMessageHandlerDelegate {
   // Called to compel the delegate to paint |invalid_rect| accelerated.
   virtual void HandlePaintAccelerated(const gfx::Rect& invalid_rect) = 0;
 
+  // Called to forward a WM_NOTIFY message to the tooltip manager.
+  virtual bool HandleTooltipNotify(int w_param,
+                                   NMHDR* l_param,
+                                   LRESULT* l_result) = 0;
+
   // Invoked on entering/exiting a menu loop.
   virtual void HandleMenuLoop(bool in_menu_loop) = 0;
 
diff --git a/ui/views/window/dialog_delegate.cc b/ui/views/window/dialog_delegate.cc
index fca1500246f01..19afca4b395cf 100644
--- a/ui/views/window/dialog_delegate.cc
+++ b/ui/views/window/dialog_delegate.cc
@@ -31,6 +31,10 @@
 #include "ui/views/window/dialog_client_view.h"
 #include "ui/views/window/dialog_observer.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/base/win/shell.h"
+#endif
+
 namespace views {
 
 // Debug information for https://crbug.com/1215247.
@@ -78,6 +82,11 @@ bool DialogDelegate::CanSupportCustomFrame(gfx::NativeView parent) {
   // The new style doesn't support unparented dialogs on Linux desktop.
   return parent != nullptr;
 #else
+#if BUILDFLAG(IS_WIN)
+  // The new style doesn't support unparented dialogs on Windows Classic themes.
+  if (!ui::win::IsAeroGlassEnabled())
+    return parent != nullptr;
+#endif
   return true;
 #endif
 }
-- 
2.35.1.windows.2

